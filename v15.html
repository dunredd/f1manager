<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Team Manager</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Basic styling for the body */
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Styling for the main application container */
        #app {
            width: 95%;
            max-width: 1200px;
            padding: 25px;
            border-radius: 12px;
            background-color: rgba(20, 20, 20, 0.85);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.6);
            margin-top: 80px;
            margin-bottom: 30px;
            box-sizing: border-box;
            position: relative;
             border: 1px solid #333;
        }

        /* Styling for the main title */
        h1 {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            margin-bottom: 1.5rem;
            color: #ff8700;
            text-shadow: 0 0 6px rgba(255, 135, 0, 0.7);
            font-size: 2rem;
        }

        /* Styling for section titles */
        h2 {
            margin-top: 2.5rem;
            margin-bottom: 1.2rem;
            color: #ff8700;
            font-size: 1.5rem;
            border-bottom: 2px solid #ff8700;
            padding-bottom: 0.6rem;
            font-weight: 700;
            text-shadow: none;
        }
        h3 {
             margin-top: 1rem;
            margin-bottom: 0.8rem;
            color: #ff9a21;
            font-size: 1.25rem;
             font-weight: 700;
             text-shadow: none;
        }
        h4{
             margin-top: 0;
            margin-bottom: 0.6rem;
            color: #cccccc;
            font-size: 1.05rem;
             font-weight: 700;
             border-bottom: 1px dotted #555;
             padding-bottom: 0.4rem;
        }

        /* Styling for the fixed budget display */
        #budget-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(10, 10, 10, 0.9);
            color: #fff;
            padding: 0.8rem 1.6rem;
            border-radius: 6px;
            z-index: 100;
            font-size: 1.15rem;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            border: 1px solid #ff8700;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
        }

        /* Styling for the Race HQ & Driver Market Buttons */
        #run-qualifying-button, #start-race-button, #accelerate-race-button, #next-gp-button, #next-season-button, #confirm-drivers-button, #clear-notifications-button {
            padding: 0.8rem 1.6rem;
            border-radius: 6px;
            background-color: #e57300;
            color: #ffffff;
            border: none;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            transition: background-color 0.2s ease, opacity 0.2s ease, transform 0.1s ease;
            margin: 0 0.5rem 1rem 0.5rem;
            max-width: 280px;
            display: inline-block;
            vertical-align: middle;
            border-bottom: 2px solid #a05200;
        }
         #race-controls, #driver-market-controls {
             text-align: center;
             margin-bottom: 2rem;
         }

         #run-qualifying-button:hover:not(:disabled),
         #start-race-button:hover:not(:disabled),
         #accelerate-race-button:hover:not(:disabled),
         #next-gp-button:hover:not(:disabled),
         #next-season-button:hover:not(:disabled),
         #confirm-drivers-button:hover:not(:disabled),
         #clear-notifications-button:hover:not(:disabled) {
            background-color: #ff8700;
            transform: translateY(-1px);
        }
         #run-qualifying-button:active:not(:disabled),
         #start-race-button:active:not(:disabled),
         #accelerate-race-button:active:not(:disabled),
         #next-gp-button:active:not(:disabled),
         #next-season-button:active:not(:disabled),
         #confirm-drivers-button:active:not(:disabled),
         #clear-notifications-button:active:not(:disabled) {
             transform: translateY(1px);
             border-bottom-width: 1px;
         }

         #run-qualifying-button:disabled,
         #start-race-button:disabled,
         #accelerate-race-button:disabled,
         #next-gp-button:disabled,
         #next-season-button:disabled,
         #confirm-drivers-button:disabled,
         #clear-notifications-button:disabled {
            background-color: #777;
            cursor: not-allowed;
            opacity: 0.6;
             border-bottom-color: #555;
        }
         #start-race-button { background-color: #0d47a1; border-bottom-color: #05306e; display: none; }
         #start-race-button:hover:not(:disabled) { background-color: #1565c0; }
         #accelerate-race-button { background-color: #FFB300; color: #111; border-bottom-color: #cc8f00; display: none; }
         #accelerate-race-button:hover:not(:disabled) { background-color: #FFCA28; }
         #next-gp-button { background-color: #6a1b9a; border-bottom-color: #4a148c; display: none; }
         #next-gp-button:hover:not(:disabled) { background-color: #8e24aa; }
         #next-season-button { background-color: #2e7d32; border-bottom-color: #1b5e20; display: none; }
         #next-season-button:hover:not(:disabled) { background-color: #388e3c; }
         #confirm-drivers-button { background-color: #2e7d32; border-bottom-color: #1b5e20; }
         #confirm-drivers-button:hover:not(:disabled) { background-color: #388e3c; }
         #clear-notifications-button { background-color: #c62828; border-bottom-color: #8e0000; max-width: 200px; display: block; margin-left: auto; margin-right: auto;}
         #clear-notifications-button:hover:not(:disabled) { background-color: #d32f2f; }


        /* Styling for the grid containers */
        #initial-budget-selection, #ecurie-selection, #drivers-list, #cars-list,
        #car-upgrade-options, #opponent-cars-list, #drivers-list-management,
        #driver-market-list { /* REMOVED #next-season-investment-options */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2.5rem;
        }
        #season-standings-list, #calendar-list {
            grid-template-columns: 1fr;
            display: grid;
            gap: 0.6rem;
        }

        /* Styling for individual cards */
        .card {
            background-color: #2c2c2c;
            padding: 1.8rem;
            border-radius: 10px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            border: 1px solid #404040;
        }
        .card:not(.disabled):hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(255, 135, 0, 0.2);
            border-color: #ff8700;
        }
        .card h3 {
            margin-top: 0; margin-bottom: 1.2rem; color: #fff; font-size: 1.15rem;
            border-bottom: 1px solid #666; padding-bottom: 0.6rem; font-weight: 700;
        }
        .card ul { list-style: none; padding: 0; margin-bottom: 1.2rem; flex-grow: 1; }
        .card li { margin-bottom: 0.6rem; color: #d0d0d0; font-size: 0.95rem; }
         /* Driver Market Card Styles */
         .card.market-selected { border: 2px solid #4CAF50; box-shadow: 0 0 10px rgba(76, 175, 80, 0.5); }
         .card.market-current-player { border: 2px solid #00BCD4; }
         .card.disabled:not(.market-selected):not(.market-current-player) { opacity: 0.6; cursor: not-allowed; border-color: #555; } /* Ensure non-selected/current disabled cards are styled */
         /* REMOVED Investment Card Styles */

        .card li.selected-driver { color: #ff8700; font-weight: bold; } /* Highlight driver name in management list */
        /* Player team card highlight in driver management tab */
        #drivers-list-management .card.player-team { border: 2px solid #ffae42; background-color: rgba(255, 174, 66, 0.05); }

        .stat-increase { color: #81c784; font-size: 0.8em; margin-left: 5px; font-weight: bold; }
        /* Stat change indicators in Driver Market */
        .stat-change { font-size: 0.8em; margin-left: 5px; font-weight: bold;}
        .stat-change.positive { color: #81c784; }
        .stat-change.negative { color: #ef5350; }
        .card button {
             padding: 0.8rem 1.6rem; border-radius: 6px; background-color: #ff8700; color: #ffffff; border: none; cursor: pointer; font-size: 0.9rem; transition: background-color 0.2s ease, transform 0.1s ease; width: 100%; box-sizing: border-box; margin-top: auto; font-family: 'Roboto', sans-serif; font-weight: 700; border-bottom: 2px solid #a05200;
         }
        .card button:hover:not(:disabled) { background-color: #ffa033; transform: translateY(-1px); }
        .card button:active:not(:disabled) { transform: translateY(1px); border-bottom-width: 1px; }
        .card button:disabled { background-color: #777; cursor: not-allowed; color: #bbb; border-bottom-color: #555;}
         /* REMOVED Investment button style override */


        /* Race HQ Specific Styles */
         #qualifying-results-area { background-color: #252525; padding: 1.2rem; border-radius: 8px; border: 1px solid #444; margin-bottom: 2rem; }
         #qualifying-results-area h3 { margin-top: 0; color: #ff9a21; }
         #qualifying-results-area h4 { color: #ccc; font-size: 1rem; margin-bottom: 0.5rem; border-bottom: 1px dotted #666; padding-bottom: 0.4rem; font-weight: 700;}
         #qualifying-results-area ol { list-style: none; padding: 0; margin: 0; font-size: 0.9rem; }
         #qualifying-results-area ol li { padding: 0.4rem 0.2rem; border-bottom: 1px dotted #555; display: flex; justify-content: space-between; } /* Use flex for alignment */
         #qualifying-results-area ol li:last-child { border-bottom: none; }
         #qualifying-results-area ol li.player-driver { color: #ffae42; font-weight: bold; background-color: rgba(255, 135, 0, 0.05); border-radius: 3px; padding-left: 5px; }
         #qualifying-results-area .time-display { font-family: monospace; color: #eee; margin-left: 10px; min-width: 70px; text-align: right; } /* Style for time */

         #live-race-area { border: 1px dashed #ff8700; padding: 1.5rem; background-color: rgba(10,10,10,0.3); border-radius: 8px; margin-bottom: 2rem; }
         #live-race-area h3 { margin-top: 0; color: #ff9a21; }
         #live-lap-counter { font-size: 1.2rem; text-align: center; margin-bottom: 1.2rem; color: #eee; font-weight: 700; }
         #live-leaderboard h4 { color: #ccc; font-size: 1rem; margin-bottom: 0.5rem; font-weight: 700; }
         #live-leaderboard ol { list-style: none; padding: 0; margin: 0; font-size: 0.95rem; }
         #live-leaderboard ol li { padding: 0.45rem 0.3rem; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s ease; } /* Added align-items */
         #live-leaderboard ol li:last-child { border-bottom: none; }
         #live-leaderboard ol li:nth-child(odd) { background-color: rgba(255, 255, 255, 0.02); }
         #live-leaderboard ol li.player-driver { color: #ffae42; font-weight: bold; background-color: rgba(255, 135, 0, 0.1); border-left: 3px solid #ff8700; padding-left: 8px;}
         #live-leaderboard ol li .status-dnf { color: #ef5350; font-weight: bold; margin-left: 8px; }
         /* Style for Gap Display */
         #live-leaderboard ol li .gap-display {
             font-size: 0.85em;
             color: #aaa;
             min-width: 80px; /* Adjust as needed */
             text-align: right;
             font-family: monospace; /* Good for aligning numbers */
             margin-left: 10px; /* Space between name and gap */
         }
         #live-leaderboard ol li.player-driver .gap-display {
             color: #ffae42; /* Make player gap stand out */
         }
         /* End Gap Display Style */
        #race-results { margin-top: 0; padding: 1.8rem; border-radius: 10px; background-color: #252525; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); border: 1px solid #444; }
        #race-results h3 { margin-top: 0; margin-bottom: 1.2rem; color: #ff9a21; font-size: 1.3rem; }
        #race-results ol { padding-left: 0; margin-bottom: 1.2rem; list-style: none; counter-reset: race-position; }
        #race-results ol li { margin-bottom: 0.6rem; color: #d0d0d0; font-size: 1rem; display: flex; align-items: center; padding: 0.5rem 0; border-bottom: 1px dotted #555; }
        #race-results ol li:last-child { border-bottom: none; }
        #race-results ol li::before { content: counter(race-position) ". "; counter-increment: race-position; font-weight: bold; color: #ff8700; margin-right: 1rem; min-width: 2.2em; text-align: right; }
        #race-results ol li.player-driver { background-color: rgba(255, 135, 0, 0.1); padding-left: 0.8rem; border-radius: 4px; font-weight: bold; color: #ffae42;}
        #race-results ol li .status-dnf { color: #ef5350; font-weight: bold; margin-left: 8px; }
        #race-results p#race-message { font-size: 0.95rem; color: #bbb; margin-top: 1.2rem; margin-bottom: 1.8rem; }
        #prize-money-earned { margin-top: 1.8rem; padding-top: 1.2rem; border-top: 1px solid #555; }
        #prize-money-earned h4 { color: #ff9a21; margin-bottom: 1rem; font-size: 1.1rem; }
        #prize-money-earned ul { list-style: none; padding: 0; margin: 0 0 0.8rem 0; }
        #prize-money-earned li { margin-bottom: 0.4rem; font-size: 0.95rem; color: #d0d0d0; }
        #prize-money-earned p { font-weight: bold; color: #fff; margin-top: 1rem; font-size: 1.05rem; }
        #visual-simulation-placeholder { display: none; } /* Keep hidden for now */

        /* General Styles */
        .disabled{ opacity: 0.6; cursor: not-allowed; border-color: #555; }
        .message-box { position: fixed; top: 80px; left: 50%; transform: translateX(-50%) translateY(-20px); background-color: rgba(10, 10, 10, 0.95); color: #fff; padding: 1rem 2rem; border-radius: 6px; z-index: 101; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; opacity: 0; pointer-events: none; box-shadow: 0 3px 7px rgba(0,0,0,0.6); border: 1px solid #ff8700; text-align: center; font-size: 0.95rem; font-family: 'Roboto', sans-serif; }
        .message-box.show { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: all; }
        .message-box.error { background-color: rgba(198, 40, 40, 0.95); border-color: #ef5350; }
        .message-box.success { background-color: rgba(46, 125, 50, 0.95); border-color: #66bb6a; }
        .message-box.info { background-color: rgba(13, 71, 161, 0.95); border-color: #42a5f5; }

        /* --- Main Tab Styles --- */
        .tabs { display: flex; margin-bottom: 2rem; border-bottom: 2px solid #ff8700; flex-wrap: wrap; }
        .tab-button { padding: 0.8rem 1.6rem; border: none; background-color: transparent; color: #ccc; cursor: pointer; font-family: 'Roboto', sans-serif; font-weight: 700; font-size: 1rem; transition: color 0.2s ease, border-bottom 0.2s ease, background-color 0.2s ease; border-bottom: 3px solid transparent; margin-bottom: -2px; text-align: center; flex-grow: 1; }
        .tab-button.active { color: #ff8700; border-bottom-color: #ff8700; background-color: rgba(255, 135, 0, 0.08); }
        .tab-button:hover:not(.active) { color: #fff; background-color: rgba(255, 255, 255, 0.05); }
        .tab-content { display: none; padding-top: 1.5rem; border-top: 1px solid #444; margin-top: -1px; }
        .tab-content.active { display: block; } /* Added for potential future use */

        /* --- Sub-Tab Styles --- */
        .sub-tabs { display: flex; margin-bottom: 1.5rem; border-bottom: 1px solid #555; flex-wrap: wrap; }
        .sub-tab-button { padding: 0.6rem 1.2rem; border: none; background-color: transparent; color: #aaa; cursor: pointer; font-family: 'Roboto', sans-serif; font-size: 0.9rem; font-weight: 700; transition: color 0.2s ease, border-bottom 0.2s ease, background-color 0.2s ease; border-bottom: 2px solid transparent; margin-right: 10px; margin-bottom: -1px; }
        .sub-tab-button.active { color: #ffae42; border-bottom-color: #ffae42; background-color: rgba(255, 174, 66, 0.05); }
        .sub-tab-button:hover:not(.active) { color: #ddd; background-color: rgba(255, 255, 255, 0.04); }
        .sub-tab-content { display: none; padding-top: 1rem; }
        .sub-tab-content.active { display: block; }

        /* --- Chart Styles --- */
        .chart-container { margin-bottom: 1.5rem; padding: 1rem; background-color: #2a2a2a; border-radius: 8px; border: 1px solid #444; }
        .chart-title { color: #ff9a21; font-size: 1.1rem; margin-bottom: 1rem; font-weight: 700; }
        /* Bar Chart (kept simple for global stat maybe) */
        .bar-chart-item { display: flex; align-items: center; margin-bottom: 0.75rem; font-size: 0.9rem; }
        .bar-label { min-width: 100px; text-align: right; margin-right: 10px; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .bar-chart-item.player-team .bar-label { color: #ffae42; font-weight: bold; } /* Used in Development Tab Car Stats */
        .bar-container { flex-grow: 1; background-color: #444; height: 20px; border-radius: 4px; overflow: hidden; position: relative; }
        .bar { height: 100%; background-color: #ff8700; border-radius: 4px 0 0 4px; transition: width 0.5s ease-in-out; white-space: nowrap; overflow: hidden; }
        /* Specific colors for bars if used for individual stats */
        .bar.engine { background-color: #d32f2f; }
        .bar.aero { background-color: #1976d2; }
        .bar.chassis { background-color: #ffb300; } /* Yellow for chassis */
        .bar.reliability { background-color: #388e3c; }
        .bar.global { background-color: #757575; } /* Grey for global */

        .bar-value { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); font-size: 0.8rem; color: #fff; font-weight: bold; text-shadow: 1px 1px 1px rgba(0,0,0,0.7); }
        .bar .bar-value-inside { padding-left: 5px; color: #fff; font-size: 0.8rem; line-height: 20px; font-weight: bold; }
        #standings-chart-container canvas { max-height: 400px; }
        #standings-chart-placeholder { text-align: center; color: #aaa; margin-top: 1rem; display: none; } /* Hide by default */
        /* NEW Car Dev Chart Styles */
        #car-dev-chart-container canvas { max-height: 350px; }
        #car-dev-chart-placeholder { text-align: center; color: #aaa; margin-top: 1rem; display: block; } /* Show initially */


        /* --- Notification Styles --- */
        #notifications-list {list-style: none; padding: 0; max-height: 400px; overflow-y: auto; background-color: #252525; border: 1px solid #444; border-radius: 6px; padding: 1rem;}
        #notifications-list li { padding: 0.6rem 0.8rem; border-bottom: 1px dotted #555; font-size: 0.9rem; color: #ccc; margin-bottom: 2px; } /* Added margin-bottom */
        #notifications-list li:last-child { border-bottom: none; }
        #notifications-list li .timestamp { font-size: 0.75rem; color: #888; margin-right: 10px; display: inline-block; }
        #notifications-list li .event-type { font-weight: bold; margin-right: 5px; }
        /* Colors defined via class on li */
        #notifications-list li.event-type-upgrade .event-type { color: #81c784; } /* Green for upgrades/money */
        #notifications-list li.event-type-transfer .event-type { color: #42a5f5; } /* Blue for transfers */
        #notifications-list li.event-type-stats .event-type { color: #ffb74d; }    /* Orange for stat changes */
        #notifications-list li.event-type-error .event-type { color: #ef5350; }   /* Red for DNF/Mistakes */
        #notifications-list li.event-type-investment .event-type { color: #AB47BC; } /* Purple for investment */
        #notifications-list li.placeholder { color: #888; font-style: italic; text-align: center; border: none; background-color: transparent; } /* Ensure placeholder has no border/bg */
        /* Apply color to the whole notification li based on type */
        #notifications-list li.event-type-upgrade { border-left: 3px solid #81c784; background-color: rgba(129, 199, 132, 0.05); }
        #notifications-list li.event-type-transfer { border-left: 3px solid #42a5f5; background-color: rgba(66, 165, 245, 0.05); }
        #notifications-list li.event-type-stats { border-left: 3px solid #ffb74d; background-color: rgba(255, 183, 77, 0.05); }
        #notifications-list li.event-type-error { border-left: 3px solid #ef5350; background-color: rgba(239, 83, 80, 0.05); }
        #notifications-list li.event-type-investment { border-left: 3px solid #AB47BC; background-color: rgba(171, 71, 188, 0.05); }


        /* Dev Tab Styles */
        #selected-car-display { margin-bottom: 2rem; padding: 1.5rem; border-radius: 10px; background-color: #333; box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5); border: 1px solid #555; }
        #selected-car-display h4 { margin-top: 0; color: #ff9a21; font-size: 1.2rem; margin-bottom: 1rem; font-weight: 700;}
        #selected-car-display ul { list-style: none; padding: 0; margin: 0; } /* Use UL for stats */
        #selected-car-display ul li { display: flex; justify-content: space-between; padding: 0.3rem 0; border-bottom: 1px dashed #555; font-size: 0.95rem; }
        #selected-car-display ul li:last-child { border-bottom: none; }
        #selected-car-display ul li span:first-child { color: #ccc; font-weight: bold; margin-right: 1rem; }
        #selected-car-display ul li span:last-child { color: #fff; font-weight: bold; }
        #selected-car-display ul li.global-stat { margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px solid #777; font-size: 1.05rem; }
        #selected-car-display ul li.global-stat span:first-child { color: #ffae42; }

        #car-upgrade-options-container { margin-bottom: 2.5rem; }
        #car-upgrade-options-container h3 { color: #ff9a21; margin-bottom: 1.2rem; font-size: 1.3rem; border-bottom: 1px solid #666; padding-bottom: 0.7rem; font-weight: 700;}
        #car-upgrade-options .card { background-color: #3a3a3a; }
        #car-upgrade-options .card ul { margin-bottom: 0.8rem; }
        #car-upgrade-options .card button { margin-top: 1.2rem; }
        /* REMOVED Next Season Investment Container Styles */

        #opponent-cars-list-container { margin-top: 2.5rem; border-top: 2px solid #ff8700; padding-top: 2rem; }
        #opponent-cars-list-container h3 { margin-bottom: 1.2rem; color: #ff9a21; text-shadow: none; font-size: 1.3rem; font-weight: 700;}
        #opponent-cars-list-container h3 small { font-size: 0.85rem; color: #bbb; font-weight: 400; margin-left: 12px; }
        #opponent-cars-list .card { background-color: #282828; opacity: 0.85; border-color: #383838; }
         /* Style for opponent car stat list */
         #opponent-cars-list .card ul li { font-size: 0.9rem; margin-bottom: 0.4rem; }
         #opponent-cars-list .card ul li.global-stat { font-weight: bold; color: #ffae42; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dotted #555; }

         /* Standings Tab Styles */
         #season-info { text-align: center; margin-bottom: 1rem; font-size: 1.2rem; color: #ccc; font-weight: 700;}
         /* NEW: Season History Dropdown */
         #standings-history-controls { margin-bottom: 1.5rem; text-align: center; }
         #standings-history-controls label { margin-right: 10px; font-weight: bold; color: #ccc;}
         #history-season-select {
             padding: 0.5rem 1rem;
             background-color: #333;
             color: #eee;
             border: 1px solid #555;
             border-radius: 4px;
             font-family: 'Roboto', sans-serif;
             font-size: 0.95rem;
             cursor: pointer;
         }
         #standings-chart-container { margin-bottom: 2rem; }
         #season-standings-list-container h3 { color: #ff9a21; margin-bottom: 1.2rem; font-size: 1.3rem; }
         #season-standings-list { list-style: none; padding: 0; background-color: #252525; border-radius: 8px; border: 1px solid #444; overflow: hidden; }
         #season-standings-list li { display: flex; align-items: center; padding: 0.8rem 1rem; border-bottom: 1px solid #444; font-size: 0.95rem; transition: background-color 0.2s ease; }
         #season-standings-list li:last-child { border-bottom: none; }
         #season-standings-list li:hover { background-color: #333; }
         .position-number { font-weight: bold; color: #ff8700; min-width: 3em; text-align: right; margin-right: 1rem; }
         #season-standings-list li span:nth-child(2) { color: #e0e0e0; margin-right: 1rem; flex-grow: 1; } /* Driver Name & Team */
         #season-standings-list li span:last-child { font-weight: bold; color: #fff; min-width: 90px; text-align: right; } /* Points */
         /* --- THIS IS THE KEY STYLE FOR HIGHLIGHTING --- */
         #season-standings-list li.player-driver {
             background-color: rgba(255, 135, 0, 0.1) !important; /* Use !important to ensure override if needed */
             border-left: 4px solid #ff8700;
             padding-left: calc(1rem - 4px);
         }
         #season-standings-list li.player-driver span:nth-child(2) {
             color: #ffae42; /* Highlight player name */
             font-weight: bold;
         }

         /* Calendar Tab Styles */
         #calendar-list-container h3 { color: #ff9a21; margin-bottom: 1.2rem; font-size: 1.3rem; }
         #calendar-list { list-style: none; padding: 0; background-color: #252525; border-radius: 8px; border: 1px solid #444; overflow: hidden;}
         #calendar-list li { padding: 1rem 1.2rem; border-bottom: 1px solid #444; font-size: 1rem; transition: background-color 0.2s ease;}
         #calendar-list li:last-child { border-bottom: none; }
         #calendar-list li:hover { background-color: #333; }
         #calendar-list li.completed { color: #888; }
         #calendar-list li.completed .race-details { text-decoration: line-through; opacity: 0.7; }
         #calendar-list li.next-race { font-weight: bold; color: #ff8700; background-color: rgba(255, 135, 0, 0.1); border-left: 4px solid #ff8700; padding-left: calc(1.2rem - 4px);}
         #calendar-list li ul { list-style: none; padding: 0.6rem 0 0 1.2rem; margin: 0; font-size: 0.85rem; color: #bbb; font-weight: normal; }
         #calendar-list li ul li { padding: 0.15rem 0; border: none; background-color: transparent; /* Reset sub-item style */}
         .race-name { font-weight: bold; display: block; margin-bottom: 0.4rem; font-size: 1.05rem; }

        /* Placeholder Styles */
        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 1rem; /* Reduced margin */
            margin-bottom: 1rem;
            padding: 0.5rem; /* Add some padding */
            font-style: italic;
            list-style: none !important; /* Override list styling */
            border: none !important; /* Override borders */
            background-color: transparent !important; /* Override background */
        }
         #qualifying-results-area ol li.placeholder-text, #starting-grid ol li.placeholder-text {
             padding: 1rem; /* More padding for these areas */
         }


        /* Responsive styles */
        @media (max-width: 768px) {
            body { align-items: flex-start; }
            #app { width: 100%; padding: 15px; border-radius: 0; margin-top: 70px; box-shadow: none; }
            #budget-display { font-size: 1rem; padding: 0.6rem 1.2rem; }
            #run-qualifying-button, #start-race-button, #accelerate-race-button, #next-gp-button, #next-season-button, #confirm-drivers-button, #clear-notifications-button { padding: 0.7rem 1.4rem; font-size: 0.9rem; max-width: 90%; display: block; margin-left: auto; margin-right: auto;}
            #race-controls, #driver-market-controls { margin-bottom: 1.5rem; }
            #initial-budget-selection, #ecurie-selection, #drivers-list, #cars-list,
            #car-upgrade-options, #season-standings-list, #calendar-list,
            #opponent-cars-list, #drivers-list-management, #driver-market-list
             { grid-template-columns: 1fr; gap: 1.2rem;}
            .card { padding: 1.2rem; }
            .card button { font-size: 0.85rem; padding: 0.7rem 1.2rem; }
            h1{ font-size: 1.8rem; } h2{ font-size: 1.3rem; } h3{ font-size: 1.15rem; } h4 { font-size: 1rem;}
            .tabs { margin-bottom: 1.5rem; }
            .tab-button { padding: 0.7rem 1rem; font-size: 0.9rem; flex-basis: 33%; }
            .sub-tabs { margin-bottom: 1rem;}
            .sub-tab-button { font-size: 0.85rem; padding: 0.5rem 1rem; margin-right: 5px;}
            #qualifying-results-area ol { font-size: 0.85rem;}
            #live-leaderboard ol { font-size: 0.9rem; }
            #live-leaderboard ol li .gap-display { font-size: 0.8em; min-width: 60px; } /* Adjust gap size */
            #race-results ol li { font-size: 0.95rem; }
            #race-results ol li::before { margin-right: 0.6rem; min-width: 1.8em; }
            #season-info { font-size: 1.1rem; }
             #standings-history-controls label { display: block; margin-bottom: 5px;} /* Stack label on mobile */
             #history-season-select { width: 80%; display: block; margin: 0 auto;}
            .position-number { min-width: 2.2em; margin-right: 0.8rem;}
            .message-box { width: 90%; font-size: 0.9rem; padding: 0.9rem 1.5rem; top: 75px; }
            #notifications-list li { font-size: 0.85rem;}
             #selected-car-display ul li { font-size: 0.9rem;}
        }
         @media (max-width: 480px) {
              h1 { font-size: 1.6rem; } h2 { font-size: 1.1rem; } h3 { font-size: 1.05rem; } h4 { font-size: 0.95rem;}
              .tab-button { flex-basis: 50%; font-size: 0.8rem; padding: 0.6rem 0.8rem;}
              .sub-tab-button { flex-basis: calc(50% - 5px); font-size: 0.8rem; padding: 0.5rem 0.8rem;}
              .card h3 { font-size: 1.05rem; } .card li { font-size: 0.85rem; }
              #budget-display { font-size: 0.9rem; padding: 0.5rem 1rem;}
              #run-qualifying-button, #start-race-button, #accelerate-race-button, #next-gp-button, #next-season-button, #confirm-drivers-button, #clear-notifications-button { font-size: 0.85rem; padding: 0.6rem 1rem;}
              #season-info { font-size: 1rem; }
              #season-standings-list li { font-size: 0.85rem; }
              .position-number { font-size: 0.85rem; min-width: 2em;}
              #season-standings-list li span:last-child { min-width: 70px; font-size: 0.85rem;}
              #calendar-list li { font-size: 0.9rem; }
              #live-leaderboard ol { font-size: 0.85rem; }
              #live-leaderboard ol li .gap-display { font-size: 0.75em; min-width: 55px; } /* Adjust gap size */
              #race-results ol li { font-size: 0.85rem;}
              #notifications-list li { font-size: 0.8rem;}
               #selected-car-display ul li { font-size: 0.85rem;}
         }

    </style>
</head>
<body>
    <!-- Budget Display -->
    <div id="budget-display">Budget: $0</div>

    <div id="app">
        <h1>F1 Team Manager</h1>

        <!-- Initial Setup Screens -->
        <div id="initial-budget-selection"></div>
        <div id="ecurie-selection" style="display: none;"></div>
        <div id="initial-driver-selection" style="display: none;">
             <h2 id="drivers-title">Select Your Two Drivers</h2>
             <div id="drivers-list"></div>
        </div>

        <!-- Main Management Screen -->
        <div id="team-management-screen" style="display: none;">
            <div class="tabs">
                <button class="tab-button active" data-tab="development">Car Dev</button>
                <button class="tab-button" data-tab="drivers">Drivers</button>
                <button class="tab-button" data-tab="standings">Standings</button>
                <button class="tab-button" data-tab="calendar">Calendar</button>
                 <button class="tab-button" data-tab="race">Race HQ</button>
                 <button class="tab-button" data-tab="notifications">Notifications</button>
            </div>

             <!-- Development Tab -->
            <div id="development-tab" class="tab-content active"> <!-- Default to active -->
                <h2>Car Development</h2>
                 <div id="selected-car-display">
                     <h4>Your Car (<span id="car-name-placeholder">Car Name</span> - <span id="car-year-placeholder">Year</span>)</h4>
                     <!-- Updated to display stats in a list -->
                     <ul id="car-stats-list">
                        <li class="placeholder-text">Car stats will appear here.</li>
                     </ul>
                 </div>
                 <!-- NEW Chart Section -->
                 <div id="car-dev-chart-container" class="chart-container" style="display: none;"> <!-- Hide initially -->
                    <h4 class="chart-title">Car Performance Progression (Overall Rating)</h4>
                    <canvas id="car-dev-line-chart-canvas"></canvas>
                    <p id="car-dev-chart-placeholder" class="placeholder-text">Complete the first race to see the chart.</p>
                 </div>
                 <!-- End NEW Chart Section -->
                 <div id="car-upgrade-options-container">
                     <h3>Upgrade Options (Current Season)</h3>
                     <div id="car-upgrade-options"></div>
                 </div>
                 <!-- REMOVED R&D Investment Section -->
                 <div id="opponent-cars-list-container">
                      <h3>Opponent Cars <small>(Upgrades from last race shown in <span class="stat-increase">green</span>)</small></h3>
                     <div id="opponent-cars-list"></div>
                 </div>
            </div>

             <!-- Drivers Tab -->
             <div id="drivers-tab" class="tab-content" style="display: none;">
                <h2>Your Drivers</h2>
                <p>Your selected drivers are highlighted in yellow below. AI drivers are assigned based on skill and team car performance. You can change drivers at the end of the season via the Driver Market.</p>
                <div id="drivers-list-management"></div>
            </div>

            <!-- Standings Tab -->
            <div id="standings-tab" class="tab-content" style="display: none;">
                <h2>Season Standings</h2>
                <p id="season-info">Season Info Placeholder</p>
                 <div id="standings-history-controls">
                     <label for="history-season-select">View Past Season:</label>
                     <select id="history-season-select">
                         <option value="current">Current Season</option>
                         <!-- Options for past seasons added dynamically -->
                     </select>
                 </div>
                 <div id="standings-chart-container" class="chart-container">
                    <h4 class="chart-title">Driver Points Progression (Top 10)</h4>
                    <canvas id="standings-line-chart-canvas" style="display: none;"></canvas> <!-- Hide canvas initially -->
                    <p id="standings-chart-placeholder" class="placeholder-text">Complete the first race to see the chart.</p> <!-- Placeholder text -->
                </div>
                <div id="season-standings-list-container">
                     <h3 id="standings-list-title">Driver Standings</h3>
                     <ul id="season-standings-list">
                         <li class="placeholder-text">Standings will appear after the first race.</li>
                     </ul>
                 </div>
            </div>

             <!-- Calendar Tab -->
             <div id="calendar-tab" class="tab-content" style="display: none;">
                <h2>Race Calendar</h2>
                 <p id="calendar-info">Calendar Info Placeholder</p>
                  <div id="calendar-list-container">
                     <h3>Schedule</h3>
                     <ul id="calendar-list">
                          <li class="placeholder-text">Calendar will be generated at season start.</li>
                     </ul>
                 </div>
             </div>

            <!-- Race Tab (REVISED STRUCTURE with Sub-Tabs) -->
            <div id="race-tab" class="tab-content" style="display: none;">
                 <h2>Race HQ</h2>
                  <div id="race-controls">
                     <button id="run-qualifying-button" style="display: none;">Run Qualifying</button>
                     <button id="start-race-button" style="display: none;">Start Race (Live)</button>
                     <button id="accelerate-race-button" style="display: none;">Accelerate Race</button>
                     <button id="next-gp-button" style="display: none;">Next Race Weekend</button>
                     <button id="next-season-button" style="display: none;">Start Next Season</button>
                 </div>
                 <div class="sub-tabs">
                     <button class="sub-tab-button active" data-subtab="qualifying">Quali/Grid</button>
                     <button class="sub-tab-button" data-subtab="live">Live Race</button>
                     <button class="sub-tab-button" data-subtab="final">Final Results</button>
                 </div>
                 <div id="race-qualifying-subtab-content" class="sub-tab-content active">
                     <div id="qualifying-results-area">
                         <h3 id="qualifying-title">Qualifying</h3>
                         <div id="q1-results" style="margin-bottom: 0.5rem;"><h4>Q1 Results:</h4><ol><li class="placeholder-text">Run qualifying to see results.</li></ol></div>
                         <div id="q2-results" style="margin-bottom: 0.5rem;"><h4>Q2 Results:</h4><ol><li class="placeholder-text"></li></ol></div>
                         <div id="q3-results" style="margin-bottom: 0.5rem;"><h4>Q3 Results:</h4><ol><li class="placeholder-text"></li></ol></div>
                         <div id="starting-grid" style="margin-top: 1rem;"><h4>Starting Grid:</h4><ol><li class="placeholder-text"></li></ol></div>
                     </div>
                 </div>
                 <div id="race-live-subtab-content" class="sub-tab-content">
                     <div id="live-race-area" style="display: none;"> <!-- Hide initially -->
                         <h3>Race Live</h3>
                         <p id="live-lap-counter">Lap: 0 / 0</p>
                         <div id="live-leaderboard">
                             <h4>Leaderboard:</h4>
                             <ol></ol>
                         </div>
                     </div>
                     <p id="live-race-placeholder" class="placeholder-text">Start the race to see live updates.</p>
                 </div>
                 <div id="race-final-subtab-content" class="sub-tab-content">
                     <div id="race-results" style="display: none;"> <!-- Hide initially -->
                         <h3 id="race-results-title">Race Results</h3>
                         <ol></ol>
                         <p id="race-message">Race statistics will appear here.</p>
                          <div id="prize-money-earned">
                               <h4>Prize Money Earned (Player):</h4>
                               <ul></ul>
                               <p>Total Earned: $0</p>
                          </div>
                     </div>
                      <p id="final-results-placeholder" class="placeholder-text">Complete the race to see final results.</p>
                 </div>
                 <div id="visual-simulation-placeholder" style="display:none;"></div> <!-- Keep hidden -->
            </div> <!-- End #race-tab -->

             <!-- Notifications Tab -->
             <div id="notifications-tab" class="tab-content" style="display: none;">
                <h2>Notifications</h2>
                <p>Recent game events and changes:</p>
                <ul id="notifications-list">
                    <li class="placeholder">No notifications yet.</li>
                </ul>
                <button id="clear-notifications-button" style="margin-top: 1rem;">Clear Log</button>
            </div>

        </div> <!-- End #team-management-screen -->

         <!-- Driver Market Screen -->
         <div id="driver-market-screen" style="display: none;">
             <h2 id="driver-market-title">Driver Market - End of Season <span id="market-season-year"></span></h2>
             <p>Select your two drivers for the upcoming season. Current drivers are highlighted <span style="color:#00BCD4; font-weight:bold;">blue</span>. Deselect a current driver to free up a slot. Newly selected drivers are highlighted <span style="color:#4CAF50; font-weight:bold;">green</span>. Stat changes vs base shown in brackets. Driver cost shown is indicative of value, not deducted from budget upon signing.</p>
             <div id="driver-market-list"></div>
             <div id="driver-market-controls">
                  <button id="confirm-drivers-button">Confirm Team for Next Season</button> <!-- Re-enabled initially -->
             </div>
         </div>

         <!-- Message Box -->
         <div id="message-box" class="message-box"></div>
    </div> <!-- End #app -->

    <script>
        // --- Constants ---
        // UPDATED EcuriesData (2024 Teams & Adjusted Costs)
        const EcuriesData = [
            { id: 1, name: 'Mercedes', cost: 195000000, defaultCarId: 1, defaultDriverIds: [1, 6] }, // Hamilton, Russell
            { id: 2, name: 'Red Bull Racing', cost: 200000000, defaultCarId: 2, defaultDriverIds: [2, 7] }, // Verstappen, Perez
            { id: 3, name: 'Ferrari', cost: 190000000, defaultCarId: 3, defaultDriverIds: [3, 5] }, // Leclerc, Sainz
            { id: 4, name: 'McLaren', cost: 175000000, defaultCarId: 4, defaultDriverIds: [4, 19] }, // Norris, Piastri
            { id: 5, name: 'Alpine', cost: 140000000, defaultCarId: 5, defaultDriverIds: [9, 10] }, // Gasly, Ocon
            { id: 6, name: 'Aston Martin', cost: 170000000, defaultCarId: 6, defaultDriverIds: [8, 14] }, // Alonso, Stroll
            { id: 7, name: 'Sauber', cost: 120000000, defaultCarId: 7, defaultDriverIds: [11, 15] }, // Bottas, Zhou (Formerly Alfa Romeo)
            { id: 8, name: 'Haas', cost: 110000000, defaultCarId: 8, defaultDriverIds: [16, 17] }, // Magnussen, Hulkenberg
            { id: 9, name: 'RB', cost: 130000000, defaultCarId: 9, defaultDriverIds: [13, 18] }, // Ricciardo, Tsunoda (Formerly AlphaTauri)
            { id: 10, name: 'Williams', cost: 115000000, defaultCarId: 10, defaultDriverIds: [12, 20] } // Albon, Sargeant
        ];
        // UPDATED CarsData (2024 Names & Relative Stats)
        const CarsData = [
            { id: 1, name: 'W15', engine: 94, aero: 93, chassis: 93, reliability: 93, cost: 0 }, // Mercedes
            { id: 2, name: 'RB20', engine: 97, aero: 96, chassis: 95, reliability: 96, cost: 0 }, // Red Bull
            { id: 3, name: 'SF-24', engine: 96, aero: 95, chassis: 94, reliability: 92, cost: 0 }, // Ferrari
            { id: 4, name: 'MCL38', engine: 93, aero: 94, chassis: 93, reliability: 94, cost: 0 }, // McLaren
            { id: 5, name: 'A524', engine: 90, aero: 88, chassis: 87, reliability: 89, cost: 0 }, // Alpine
            { id: 6, name: 'AMR24', engine: 93, aero: 92, chassis: 92, reliability: 93, cost: 0 }, // Aston Martin
            { id: 7, name: 'C44', engine: 88, aero: 87, chassis: 88, reliability: 90, cost: 0 }, // Sauber
            { id: 8, name: 'VF-24', engine: 87, aero: 86, chassis: 86, reliability: 88, cost: 0 }, // Haas
            { id: 9, name: 'VCARB 01', engine: 91, aero: 89, chassis: 88, reliability: 91, cost: 0 }, // RB
            { id: 10, name: 'FW46', engine: 88, aero: 88, chassis: 87, reliability: 90, cost: 0 }  // Williams
        ];
        // REVISED Upgrade Costs (Increased)
        const UpgradesData = [
             { id: 1, name: 'Engine Power Boost', cost: 45000000, effect: { stat: 'engine', value: 5 } }, // Was 35M
             { id: 2, name: 'Advanced Aero Suite', cost: 40000000, effect: { stat: 'aero', value: 5 } }, // Was 32M
             { id: 3, name: 'Reliability Overhaul', cost: 30000000, effect: { stat: 'reliability', value: 5 } }, // Was 20M
             { id: 4, name: 'Chassis Tuning', cost: 33000000, effect: { stat: 'chassis', value: 4 } }, // Was 28M
             { id: 9, name: 'Underfloor Aero', cost: 30000000, effect: { stat: 'aero', value: 4 } }, // Was 30M
             { id: 7, name: 'Gearbox Refinement', cost: 25000000, effect: { stat: 'reliability', value: 4 } }, // Was 15M
             { id: 5, name: 'Lightweight Components', cost: 40000000, effect: { stat: 'chassis', value: 3 } }, // Was 40M
             { id: 6, name: 'Front Wing Update', cost: 22000000, effect: { stat: 'aero', value: 3 } }, // Was 22M
             { id: 8, name: 'ECU Remap', cost: 25000000, effect: { stat: 'engine', value: 3 } }, // Was 25M
             { id: 10, name: 'Suspension Redesign', cost: 24000000, effect: { stat: 'chassis', value: 3 } }, // Was 24M
        ];
        // UPDATED DriversData (2024 F1 Lineup + F2/F3 Prospects, Adjusted Stats/Costs)
        const DriversData = [
            // --- F1 2024 Grid Drivers ---
            { id: 1, name: 'L. Hamilton', skill: 94, cost: 24000000, qualyPace: 95, racePace: 93, consistency: 94, overtaking: 97, defending: 94 },
            { id: 2, name: 'M. Verstappen', skill: 97, cost: 28000000, qualyPace: 98, racePace: 98, consistency: 95, overtaking: 97, defending: 96 },
            { id: 3, name: 'C. Leclerc', skill: 95, cost: 23000000, qualyPace: 97, racePace: 92, consistency: 89, overtaking: 93, defending: 90 },
            { id: 4, name: 'L. Norris', skill: 94, cost: 22000000, qualyPace: 93, racePace: 94, consistency: 95, overtaking: 91, defending: 92 },
            { id: 5, name: 'C. Sainz', skill: 92, cost: 20000000, qualyPace: 91, racePace: 93, consistency: 94, overtaking: 89, defending: 94 },
            { id: 6, name: 'G. Russell', skill: 93, cost: 21000000, qualyPace: 95, racePace: 91, consistency: 92, overtaking: 90, defending: 93 },
            { id: 7, name: 'S. Perez', skill: 88, cost: 16000000, qualyPace: 87, racePace: 90, consistency: 88, overtaking: 91, defending: 89 },
            { id: 8, name: 'F. Alonso', skill: 92, cost: 20000000, qualyPace: 90, racePace: 96, consistency: 98, overtaking: 96, defending: 98 },
            { id: 9, name: 'P. Gasly', skill: 87, cost: 14000000, qualyPace: 89, racePace: 86, consistency: 87, overtaking: 88, defending: 85 },
            { id: 10, name: 'E. Ocon', skill: 86, cost: 13000000, qualyPace: 87, racePace: 85, consistency: 88, overtaking: 85, defending: 88 },
            { id: 11, name: 'V. Bottas', skill: 87, cost: 13500000, qualyPace: 90, racePace: 86, consistency: 90, overtaking: 84, defending: 86 },
            { id: 12, name: 'A. Albon', skill: 88, cost: 15000000, qualyPace: 91, racePace: 87, consistency: 89, overtaking: 85, defending: 84 },
            { id: 13, name: 'D. Ricciardo', skill: 85, cost: 12000000, qualyPace: 86, racePace: 84, consistency: 85, overtaking: 89, defending: 82 },
            { id: 14, name: 'L. Stroll', skill: 81, cost: 9500000, qualyPace: 81, racePace: 80, consistency: 80, overtaking: 80, defending: 82 },
            { id: 15, name: 'Z. Guanyu', skill: 82, cost: 9500000, qualyPace: 84, racePace: 83, consistency: 86, overtaking: 80, defending: 81 },
            { id: 16, name: 'K. Magnussen', skill: 83, cost: 10000000, qualyPace: 85, racePace: 80, consistency: 82, overtaking: 86, defending: 87 },
            { id: 17, name: 'N. Hulkenberg', skill: 85, cost: 11500000, qualyPace: 88, racePace: 82, consistency: 90, overtaking: 82, defending: 85 },
            { id: 18, name: 'Y. Tsunoda', skill: 84, cost: 11000000, qualyPace: 87, racePace: 83, consistency: 81, overtaking: 85, defending: 80 },
            { id: 19, name: 'O. Piastri', skill: 91, cost: 18000000, qualyPace: 92, racePace: 90, consistency: 93, overtaking: 88, defending: 87 },
            { id: 20, name: 'L. Sargeant', skill: 78, cost: 6500000, qualyPace: 80, racePace: 77, consistency: 74, overtaking: 78, defending: 76 },
            // --- F2/F3 Prospects ---
            { id: 21, name: 'O. Bearman', skill: 83, cost: 8000000, qualyPace: 86, racePace: 84, consistency: 85, overtaking: 83, defending: 80 }, // Ferrari Reserve, Haas debut
            { id: 22, name: 'A. K. Antonelli', skill: 82, cost: 9000000, qualyPace: 85, racePace: 82, consistency: 84, overtaking: 81, defending: 79 }, // Mercedes Junior, high hype
            { id: 23, name: 'V. Martins', skill: 81, cost: 7000000, qualyPace: 84, racePace: 81, consistency: 80, overtaking: 82, defending: 78 }, // Alpine Junior, F2 Race Winner
            { id: 24, name: 'I. Hadjar', skill: 80, cost: 6500000, qualyPace: 82, racePace: 80, consistency: 83, overtaking: 80, defending: 77 }, // Red Bull Junior
            { id: 25, name: 'Z. Maloney', skill: 80, cost: 6000000, qualyPace: 81, racePace: 81, consistency: 85, overtaking: 79, defending: 78 }, // Sauber Academy
            { id: 26, name: 'T. Pourchaire', skill: 84, cost: 8500000, qualyPace: 87, racePace: 83, consistency: 86, overtaking: 81, defending: 82 }, // Sauber Reserve, F2 Champ '23
            { id: 27, name: 'L. Browning', skill: 79, cost: 5000000, qualyPace: 83, racePace: 79, consistency: 81, overtaking: 77, defending: 75 }, // Williams Junior, F3 Standout
            { id: 28, name: 'G. Minì', skill: 78, cost: 4500000, qualyPace: 81, racePace: 78, consistency: 82, overtaking: 76, defending: 74 } // Alpine Junior, F3 Contender
        ];
        const RacesData = [ { id: 1, name: 'Bahrain GP', length: 308.238, laps: 57, speedFocus: 85, handlingFocus: 85, reliabilityStress: 85 }, { id: 2, name: 'Saudi Arabia GP', length: 308.450, laps: 50, speedFocus: 95, handlingFocus: 80, reliabilityStress: 80 }, { id: 3, name: 'Australia GP', length: 307.574, laps: 58, speedFocus: 90, handlingFocus: 90, reliabilityStress: 80 }, { id: 4, name: 'Azerbaijan GP', length: 306.049, laps: 51, speedFocus: 100, handlingFocus: 75, reliabilityStress: 75 }, { id: 5, name: 'Miami GP', length: 308.326, laps: 57, speedFocus: 85, handlingFocus: 90, reliabilityStress: 80 }, { id: 6, name: 'Emilia Romagna GP', length: 309.049, laps: 63, speedFocus: 88, handlingFocus: 88, reliabilityStress: 82 }, { id: 7, name: 'Monaco GP', length: 260.286, laps: 78, speedFocus: 60, handlingFocus: 100, reliabilityStress: 70 }, { id: 8, name: 'Spain GP', length: 307.237, laps: 66, speedFocus: 85, handlingFocus: 90, reliabilityStress: 80 }, { id: 9, name: 'Canada GP', length: 305.270, laps: 70, speedFocus: 90, handlingFocus: 85, reliabilityStress: 80 }, { id: 10, name: 'Austria GP', length: 306.452, laps: 71, speedFocus: 90, handlingFocus: 85, reliabilityStress: 85 }, { id: 11, name: 'Great Britain GP', length: 306.198, laps: 52, speedFocus: 92, handlingFocus: 92, reliabilityStress: 78 }, { id: 12, name: 'Hungary GP', length: 306.630, laps: 70, speedFocus: 75, handlingFocus: 95, reliabilityStress: 80 }, { id: 13, name: 'Belgium GP', length: 308.052, laps: 44, speedFocus: 98, handlingFocus: 70, reliabilityStress: 80 }, { id: 14, name: 'Netherlands GP', length: 305.876, laps: 72, speedFocus: 70, handlingFocus: 98, reliabilityStress: 80 }, { id: 15, name: 'Italy GP', length: 306.720, laps: 53, speedFocus: 100, handlingFocus: 65, reliabilityStress: 80 }, { id: 16, name: 'Singapore GP', length: 306.320, laps: 62, speedFocus: 80, handlingFocus: 95, reliabilityStress: 85 }, { id: 17, name: 'Japan GP', length: 307.471, laps: 53, speedFocus: 92, handlingFocus: 90, reliabilityStress: 78 }, { id: 18, name: 'Qatar GP', length: 306.660, laps: 57, speedFocus: 95, handlingFocus: 85, reliabilityStress: 80 }, { id: 19, name: 'USA GP', length: 308.405, laps: 56, speedFocus: 88, handlingFocus: 90, reliabilityStress: 82 }, { id: 20, name: 'Mexico GP', length: 305.584, laps: 71, speedFocus: 90, handlingFocus: 85, reliabilityStress: 85 }, { id: 21, name: 'Brazil GP', length: 305.909, laps: 71, speedFocus: 88, handlingFocus: 88, reliabilityStress: 82 }, { id: 22, name: 'Las Vegas GP', length: 310.000, laps: 50, speedFocus: 95, handlingFocus: 80, reliabilityStress: 80 }, { id: 23, name: 'Abu Dhabi GP', length: 305.355, laps: 58, speedFocus: 85, handlingFocus: 85, reliabilityStress: 85 }, { id: 24, name: 'China GP', length: 305.066, laps: 56, speedFocus: 90, handlingFocus: 89, reliabilityStress: 81 }, ];
        const BudgetOptions = [ { amount: 160000000, name: 'Challenger ($160M)' }, { amount: 185000000, name: 'Midfield ($185M)' }, { amount: 220000000, name: 'Top Team ($220M)' }, ];
        // REVISED: End-of-Season Bonuses and R&D Potential
        const CONSTRUCTOR_BONUSES = [ 50000000, 40000000, 32000000, 25000000, 20000000, 16000000, 12000000, 9000000, 7000000, 5000000 ]; // Increased P1 to P10
        const CONSTRUCTOR_RD_POTENTIAL = [ // Min/Max stat change range per rank tier
            { rankMin: 1, rankMax: 1, min: 2, max: 4 },   // P1
            { rankMin: 2, rankMax: 3, min: 1, max: 4 },   // P2-P3
            { rankMin: 4, rankMax: 6, min: 0, max: 3 },   // P4-P6
            { rankMin: 7, rankMax: 8, min: -1, max: 2 },  // P7-P8
            { rankMin: 9, rankMax: 10, min: -2, max: 1 }  // P9-P10
        ];
        const INVESTMENT_COST = 25000000; // REVISED: Increased cost for stat focus
        const INVESTMENT_POTENTIAL_BOOST = { min: 1, max: 1 }; // REVISED: Modest boost (+1 to min/max range)
        const PointsSystem = [25, 18, 15, 12, 10, 8, 6, 4, 2, 1];
        const GLOBAL_STAT_WEIGHTS = { engine: 0.3, aero: 0.3, chassis: 0.25, reliability: 0.15 };

        // --- Simulation & Gameplay Constants ---
        const QUALI_BASE_TIME_MS = 95000; // Base Quali Time (e.g., 1:35.000)
        const QUALI_DRIVER_TIME_FACTOR = 50; // ms improvement per driver qualyPace point
        const QUALI_CAR_ENGINE_TIME_FACTOR = 40; // ms improvement per car engine point
        const QUALI_CAR_AERO_TIME_FACTOR = 40;   // ms improvement per car aero point
        const QUALI_CAR_CHASSIS_TIME_FACTOR = 50; // ms improvement per car chassis point
        const QUALI_RANDOM_MS_FACTOR = 250; // Random variation in ms (+/-)
        const RACE_UPDATE_INTERVAL_MS = 250;
        const LAPTIME_BASE_MS = 90000;
        const LAPTIME_DRIVER_PACE_FACTOR = 15; // ms per point
        const LAPTIME_CAR_ENGINE_FACTOR = 10;  // ms per point
        const LAPTIME_CAR_AERO_FACTOR = 8;    // ms per point
        const LAPTIME_CAR_CHASSIS_FACTOR = 6;  // ms per point
        const LAPTIME_CONSISTENCY_FACTOR = 10; // Scales random variation based on (100 - consistency)
        const OVERTAKE_GAP_THRESHOLD_MS = 1500;
        const OVERTAKE_LAPTIME_DIFF_THRESHOLD_MS = 100;
        const RACE_OVERTAKE_BASE_CHANCE = 0.5;
        const RACE_OVERTAKE_SKILL_FACTOR = 0.008;
        const RACE_DEFEND_SKILL_FACTOR = 0.008;
        const RACE_CAR_OVERTAKE_ENGINE_FACTOR = 0.003;
        const RACE_CAR_OVERTAKE_AERO_FACTOR = 0.002;
        const OVERTAKE_RANDOM_FACTOR = 0.15;
        const RACE_RELIABILITY_DNF_BASE_CHANCE = 0.001;
        const RELIABILITY_IMPACT_FACTOR = 0.0008; // How much reliability stat affects DNF chance (-ve means better)
        const TRACK_STRESS_FACTOR = 0.0003;     // How much track stress affects DNF chance (+ve means worse)
        const MAX_DNF_PER_RACE_PERCENT = 0.15;
        const MINOR_MISTAKE_CHANCE = 0.06;
        const MINOR_MISTAKE_BASE_TIME_MS = 150;
        const MINOR_MISTAKE_CONSISTENCY_SCALE = 5;
        const MAJOR_MISTAKE_CHANCE = 0.008;
        const MAJOR_MISTAKE_MIN_TIME_MS = 1000; // Reduced
        const MAJOR_MISTAKE_MAX_TIME_MS = 2500; // Reduced
        const BOOST_CHANCE = 0.025; // Normal "good sector" boost
        const BOOST_MIN_TIME_MS = 50;
        const BOOST_MAX_TIME_MS = 150;
        const CATCHUP_BOOST_CHANCE = 0.03; // Chance for extra gap reduction boost
        const CATCHUP_BOOST_FACTOR = 0.15; // % of gap reduced if boost triggers
        const MAX_STAT_VALUE_PLAYER = 120;
        const MAX_STAT_VALUE_AI = 115;
        const GLOBAL_STAT_CAP = 99; // Cap for car overall rating at start of season
        const PRIZE_MONEY_PER_POINT = 200000;
        const PRIZE_MONEY_PODIUM_BONUS = 2000000;
        const PRIZE_MONEY_TOP_10_BONUS = 1000000;
        const PRIZE_MONEY_P11_P20_BONUS = 500000;
        const PLAYER_BONUS_PER_POINT = 50000;
        const AI_BONUS_PER_POINT = 5000;
        const MAX_NOTIFICATIONS = 50;
        const BASE_STAT_CHANGE_MIN = -2; // Default fluctuation min
        const BASE_STAT_CHANGE_MAX = 2;  // Default fluctuation max
        const DRIVER_COST_SKILL_FACTOR = 250000; // Cost change per point of skill change vs base
        const DRIVER_MIN_COST = 1000000; // Minimum driver cost

        // --- Global State Variables ---
        let gameState = 'SETUP'; // SETUP, MANAGEMENT, DRIVER_MARKET, SEASON_END
        let teamName = '', selectedEcurieId = null, selectedDriverIds = [], selectedCar = null, budget = 0;
        let purchasedUpgrades = {}; // { upgradeId: true } - Cleared each season start
        let driverSeasonScores = {}; // { driverId: points }
        let currentSeasonYear = 2024, currentRaceIndex = 0;
        let currentDrivers = [], currentCars = [], currentEcuries = [];
        let aiTeamBudgets = {}; // { teamId: budget }
        let aiTeamUpgrades = {}; // { teamId: { upgradeId: true } } - Cleared each season start
        let lastAIRaceUpgrades = {}; // { carId: { stat: 'aero', change: 3 } } - Example
        let currentSeasonCalendar = [], totalRacesInSeason = 0;
        let qualifyingResults = { q1: [], q2: [], q3: [] }; // Stores { driver, car, time (ms) }
        let startingGrid = []; // Array of { driver, car } objects
        let raceLeaderboard = []; // Array of { driver, car, status, totalRaceTime, lastLapTime, lapsCompleted } objects
        let currentLap = 0, raceIntervalId = null, dnfCountThisRace = 0, maxDnfThisRace = 0;
        let raceCompletedForCurrentIndex = false;
        let marketSelectedDriverIds = []; // Driver IDs selected in the end-of-season market
        let notificationsLog = []; // Array of { message, type, timestamp, typeClass }
        let driverRaceHistory = {}; // { driverId: [race1_score, race2_score, ...] } - Stores CUMULATIVE scores
        let standingsChartInstance = null;
        let carDevChartInstance = null; // Chart instance for car development
        let playerChosenInvestmentStat = null; // REVISED: Stores player's chosen stat focus, or null
        let aiTeamChosenInvestmentStats = {}; // REVISED: { teamId: 'stat' | null }
        let seasonHistory = {}; // { 2024: [{driverId, driverName, teamId, teamName, points}, ...], 2025: [...] }
        let carPerformanceHistory = {}; // { teamId: [rating_start, rating_after_R1, ...] }
        let teamPreviousSeasonRank = {}; // Stores { teamId: rank } from previous season


        // --- Initialization & Setup ---

        function initGame() {
            gameState = 'SETUP'; teamName=''; selectedEcurieId=null; selectedDriverIds=[]; selectedCar=null; budget=0; purchasedUpgrades={}; driverSeasonScores={}; currentRaceIndex=0; currentSeasonYear=2024; aiTeamBudgets={}; aiTeamUpgrades={}; lastAIRaceUpgrades={}; currentSeasonCalendar=[]; qualifyingResults={q1:[],q2:[],q3:[]}; startingGrid=[]; raceLeaderboard=[]; if(raceIntervalId) clearInterval(raceIntervalId); raceIntervalId=null; dnfCountThisRace=0; raceCompletedForCurrentIndex = false; maxDnfThisRace = 0; marketSelectedDriverIds = []; notificationsLog = []; driverRaceHistory = {};
            playerChosenInvestmentStat = null; aiTeamChosenInvestmentStats = {}; teamPreviousSeasonRank = {}; // Reset R&D choices and ranks
            seasonHistory = {}; carPerformanceHistory = {};
            // --- Use UPDATED Data ---
            currentDrivers = JSON.parse(JSON.stringify(DriversData)).map(d=>({...d, teamId:null}));
            currentCars = JSON.parse(JSON.stringify(CarsData));
            currentEcuries = JSON.parse(JSON.stringify(EcuriesData)).map(e=>({...e, driverIds:[]}));
            // -------------------------
            document.getElementById('budget-display').textContent=`Budget: $0`; document.getElementById('team-management-screen').style.display='none'; document.getElementById('driver-market-screen').style.display='none'; document.getElementById('ecurie-selection').style.display='none'; document.getElementById('initial-driver-selection').style.display='none'; document.getElementById('initial-budget-selection').style.display='none';
            clearQualifyingUI(); document.getElementById('live-race-area').style.display='none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display='none'; document.getElementById('final-results-placeholder').style.display = 'block';
            updateRaceHQButtonState();
            if (standingsChartInstance) { standingsChartInstance.destroy(); standingsChartInstance = null; }
            if (carDevChartInstance) { carDevChartInstance.destroy(); carDevChartInstance = null; }
            document.getElementById('standings-line-chart-canvas').style.display = 'none'; document.getElementById('standings-chart-placeholder').style.display = 'block';
            document.getElementById('car-dev-line-chart-canvas').style.display = 'none'; document.getElementById('car-dev-chart-placeholder').style.display = 'block'; document.getElementById('car-dev-chart-container').style.display = 'none';
            document.getElementById('season-standings-list').innerHTML = '<li class="placeholder-text">Standings will appear after the first race.</li>'; document.getElementById('calendar-list').innerHTML = '<li class="placeholder-text">Calendar will be generated at season start.</li>'; document.getElementById('car-stats-list').innerHTML = '<li class="placeholder-text">Car stats will appear here.</li>';
            // Remove R&D investment UI if it exists
            const investmentContainer = document.getElementById('next-season-investment-container');
            if (investmentContainer) investmentContainer.style.display = 'none'; // Hide the whole section

            renderNotifications(); renderBudgetSelection(); setupTabs(); setupRaceSubTabs(); setupHistoryDropdown();
            const setupButtonListener = (id, handler) => { const button = document.getElementById(id); if (button && !button.getAttribute('data-listener')) { button.addEventListener('click', handler); button.setAttribute('data-listener', 'true'); } };
            setupButtonListener('run-qualifying-button', handleRunQualifyingSequence); setupButtonListener('start-race-button', startRaceSimulation); setupButtonListener('accelerate-race-button', handleAccelerateRace); setupButtonListener('next-gp-button', handleNextRaceWeekend); setupButtonListener('next-season-button', handleStartNextSeason); setupButtonListener('confirm-drivers-button', handleConfirmDriverSelection); setupButtonListener('clear-notifications-button', () => { notificationsLog = []; renderNotifications(); showMessage('Notifications cleared.', 'info'); });
        }

        function initializeGameAfterSetup() {
            gameState = 'MANAGEMENT';
            const playerTeam = getTeamById(selectedEcurieId); if (playerTeam) { playerTeam.driverIds = selectedDriverIds; }
            selectedDriverIds.forEach(id => { const driver = getDriverById(id); if (driver) { driver.teamId = selectedEcurieId; } });
            aiTeamBudgets = {}; aiTeamUpgrades = {}; teamPreviousSeasonRank = {}; // Initialize rank tracker
            currentEcuries.forEach((t, index) => {
                teamPreviousSeasonRank[t.id] = index + 1; // Initial rank based on default data order (approximate)
                if (t.id !== selectedEcurieId) {
                    // --- MODIFIED: Reduced starting AI budget ---
                    aiTeamBudgets[t.id] = randomizeBetween(5000000, 15000000); // Lowered range (was 15M-30M)
                    // -------------------------------------------
                    aiTeamUpgrades[t.id] = {};
                }
            });
            assignAIDriversRanked();
            resetSeasonState(true); // Reset scores, history, calendar etc. Also initializes carPerformanceHistory and clears upgrade lists.
            document.getElementById('initial-budget-selection').style.display='none'; document.getElementById('ecurie-selection').style.display='none'; document.getElementById('initial-driver-selection').style.display='none'; document.getElementById('driver-market-screen').style.display = 'none'; document.getElementById('team-management-screen').style.display='block';
            // Make sure R&D section is hidden initially
            const investmentContainer = document.getElementById('next-season-investment-container');
            if (investmentContainer) investmentContainer.style.display = 'none';
            updateRaceHQButtonState(); renderAllTabs(); activateTab('development'); activateRaceSubTab('qualifying');
            addNotification(`Welcome to ${teamName}! Season ${currentSeasonYear} begins. AI drivers assigned. Good luck!`, 'success');
        }

        function resetSeasonState(isNewSeasonStart = false) {
             lastAIRaceUpgrades = {}; qualifyingResults = { q1: [], q2: [], q3: [] }; startingGrid = []; raceLeaderboard = []; if(raceIntervalId) clearInterval(raceIntervalId); raceIntervalId = null; dnfCountThisRace = 0; maxDnfThisRace = 0; raceCompletedForCurrentIndex = false;
             if (isNewSeasonStart) {
                 currentRaceIndex = 0; driverSeasonScores = {}; driverRaceHistory = {}; generateSeasonCalendar();
                 // --- Ensure all current drivers (including prospects) are in score/history ---
                 currentDrivers.forEach(d => {
                     driverSeasonScores[d.id] = 0;
                     driverRaceHistory[d.id] = Array(totalRacesInSeason).fill(null);
                 });
                 // --------------------------------------------------------------------------
                 purchasedUpgrades = {};
                 aiTeamUpgrades = {};
                 currentEcuries.forEach(t => { if (t.id !== selectedEcurieId) aiTeamUpgrades[t.id] = {}; });
                 playerChosenInvestmentStat = null; // Reset player focus
                 aiTeamChosenInvestmentStats = {}; // Reset AI focus
                 // -------------------------------------------------
                 if (standingsChartInstance) { standingsChartInstance.destroy(); standingsChartInstance = null; }
                 if (carDevChartInstance) { carDevChartInstance.destroy(); carDevChartInstance = null; }

                 // Initialize Car Performance History for the new season
                 carPerformanceHistory = {};
                 currentEcuries.forEach(team => {
                     const car = getCarById(team.defaultCarId);
                     const initialRating = calculateCarGlobalStat(car);
                     // Store rating *before* race 1 (at index 0)
                     carPerformanceHistory[team.id] = [initialRating];
                 });
                 // Note: teamPreviousSeasonRank is NOT reset here, it carries over from the end of the last season
             }
             if (selectedEcurieId) { const playerTeamCarId = getTeamById(selectedEcurieId)?.defaultCarId; if(playerTeamCarId) selectedCar = getCarById(playerTeamCarId); else console.error("Could not find player car after season reset!"); }
             clearQualifyingUI(); document.getElementById('live-race-area').style.display='none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display='none'; document.getElementById('final-results-placeholder').style.display = 'block';
             document.getElementById('standings-line-chart-canvas').style.display = 'none'; document.getElementById('standings-chart-placeholder').style.display = 'block'; document.getElementById('standings-chart-placeholder').textContent = 'Complete the first race to see the chart.';
             // Reset car dev chart display
             const carDevChartContainer = document.getElementById('car-dev-chart-container');
             const carDevCanvas = document.getElementById('car-dev-line-chart-canvas');
             const carDevPlaceholder = document.getElementById('car-dev-chart-placeholder');
             if(carDevChartContainer) carDevChartContainer.style.display = 'none';
             if(carDevCanvas) carDevCanvas.style.display = 'none';
             if(carDevPlaceholder) { carDevPlaceholder.style.display = 'block'; carDevPlaceholder.textContent = 'Complete the first race to see the chart.';}

             const historySelect = document.getElementById('history-season-select'); if(historySelect) historySelect.value = 'current';
             // Ensure R&D investment section is hidden
             const investmentContainer = document.getElementById('next-season-investment-container');
             if (investmentContainer) investmentContainer.style.display = 'none';
        }

        // --- UI Rendering ---

        function renderBudgetSelection() { const el = document.getElementById('initial-budget-selection'); if (!el) return; el.innerHTML = '<h2>Select Your Starting Budget</h2>' + BudgetOptions.map(o => `<div class="card"><h3>${o.name}</h3><ul><li>Amount: $${formatNumber(o.amount)}</li></ul><button data-budget-amount="${o.amount}">Select Budget</button></div>`).join(''); el.querySelectorAll('button').forEach(b => b.addEventListener('click', () => handleBudgetSelection(parseInt(b.dataset.budgetAmount)))); el.style.display = 'grid'; }
        function renderEcurieSelection() { const el = document.getElementById('ecurie-selection'); if (!el) return; el.innerHTML = '<h2>Select Your Team</h2>' + currentEcuries.map(e => { const canAfford = budget >= e.cost; return `<div class="card ${!canAfford ? 'disabled' : ''}"><h3>${e.name}</h3><ul><li>Cost: $${formatNumber(e.cost)}</li></ul><button data-ecurie-id="${e.id}" ${!canAfford ? 'disabled' : ''}>${canAfford ? 'Select Team' : 'Insufficient Funds'}</button></div>`; }).join(''); el.querySelectorAll('button:not(:disabled)').forEach(b => b.addEventListener('click', () => handleEcurieSelection(parseInt(b.dataset.ecurieId)))); el.style.display = 'grid'; }
        function renderDriversList(containerId, isInitialSelection = false) {
            const el = document.getElementById(containerId); if (!el) return;
            const isTeamMgmtView = containerId === 'drivers-list-management';
            const isDriverMarket = containerId === 'driver-market-list'; // Check if it's the driver market

            if (isTeamMgmtView) {
                 // Sort all drivers, including prospects, by skill for this view
                 const allDriversSorted = [...currentDrivers].sort((a, b) => b.skill - a.skill);
                 const playerDrivers = allDriversSorted.filter(d => selectedDriverIds.includes(d.id));
                 const otherDrivers = allDriversSorted.filter(d => !selectedDriverIds.includes(d.id));
                 const playerDriversHtml = playerDrivers.map(d => { const team = getTeamById(d.teamId); const teamNameDisplay = team ? ` (Your Team)` : ''; let cardClasses = ['card', 'player-team']; return `<div class="${cardClasses.join(' ')}"><h3>${d.name}${teamNameDisplay}</h3><ul><li>Skill: ${d.skill}</li><li>Quali: ${d.qualyPace}</li><li>Race: ${d.racePace}</li><li>Cons: ${d.consistency}</li><li>Ovr: ${d.overtaking}</li><li>Def: ${d.defending}</li><li>Cost: $${formatNumber(d.cost)}</li></ul></div>`; }).join('');
                 const otherDriversHtml = otherDrivers.map(d => { const team = getTeamById(d.teamId); const teamNameDisplay = team ? ` (${team.name})` : ' (Free Agent)'; let cardClasses = ['card']; return `<div class="${cardClasses.join(' ')}"><h3>${d.name}${teamNameDisplay}</h3><ul><li>Skill: ${d.skill}</li><li>Quali: ${d.qualyPace}</li><li>Race: ${d.racePace}</li><li>Cons: ${d.consistency}</li><li>Ovr: ${d.overtaking}</li><li>Def: ${d.defending}</li><li>Cost: $${formatNumber(d.cost)}</li></ul></div>`; }).join('');
                 el.innerHTML = playerDriversHtml + otherDriversHtml;
            } else if (isInitialSelection || isDriverMarket) { // Combined logic for Initial and Market screens
                // --- Get ORIGINAL base data only for market comparison ---
                const originalDriversData = isDriverMarket ? JSON.parse(JSON.stringify(DriversData)) : null;
                const statsToCompare = ['qualyPace', 'racePace', 'consistency', 'overtaking', 'defending', 'skill'];
                // --- Use CURRENT drivers for display ---
                const driversToDisplay = currentDrivers.sort((a,b) => b.skill - a.skill);

                el.innerHTML = driversToDisplay.map(d => {
                    const isSelectedForNextSeason = isDriverMarket && marketSelectedDriverIds.includes(d.id);
                    const isPreviousSeasonPlayerDriver = isDriverMarket && selectedDriverIds.includes(d.id); // Original player driver for blue highlight
                    const isSelectedInitial = isInitialSelection && selectedDriverIds.includes(d.id);

                    let cardClasses = ['card'];
                    let buttonHtml = '';
                    const alreadySelected = isSelectedInitial || isSelectedForNextSeason;
                    const teamFull = (isInitialSelection ? selectedDriverIds.length : marketSelectedDriverIds.length) >= 2;
                    const canAfford = isInitialSelection ? (budget >= d.cost || alreadySelected) : true; // Can always "afford" in market
                    const isDisabled = (!alreadySelected && teamFull) || (isInitialSelection && !alreadySelected && !canAfford);
                    let buttonText = 'Select Driver';

                    if (alreadySelected) buttonText = 'Deselect';
                    else if (teamFull) buttonText = 'Team Full';
                    else if (isInitialSelection && !canAfford) buttonText = 'Cannot Afford';

                    buttonHtml = `<button data-driver-id="${d.id}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>`;

                    if (isDisabled && !alreadySelected) cardClasses.push('disabled');
                    if (isSelectedInitial || isSelectedForNextSeason) cardClasses.push('market-selected'); // Green border for currently selected
                    if (isPreviousSeasonPlayerDriver) cardClasses.push('market-current-player'); // Blue border for driver from last season

                    // Stat change display logic only for driver market
                    let statChangesHtml = {};
                    if (isDriverMarket && originalDriversData) {
                         // Find the BASE driver from the ORIGINAL data
                         const baseDriver = originalDriversData.find(bd => bd.id === d.id);
                         if (baseDriver) {
                             statChangesHtml = statsToCompare.map(stat => {
                                 // Compare CURRENT stat vs ORIGINAL stat
                                 const diff = d[stat] - baseDriver[stat];
                                 if (diff === 0) return { stat: stat, html: '' };
                                 const sign = diff > 0 ? '+' : '';
                                 const changeClass = diff > 0 ? 'positive' : 'negative';
                                 return { stat: stat, html: `<span class="stat-change ${changeClass}" title="vs Base">(${sign}${diff})</span>` };
                             }).reduce((acc, curr) => { acc[curr.stat] = curr.html; return acc; }, {});
                         }
                    }
                    const getChange = (statName) => statChangesHtml[statName] || '';
                    const costLabel = isDriverMarket ? 'Value' : 'Cost'; // Label change for market

                    return `<div class="${cardClasses.join(' ')}"><h3>${d.name}</h3><ul><li>${costLabel}: $${formatNumber(d.cost)}</li><li>Skill: ${d.skill} ${getChange('skill')}</li><li>Quali: ${d.qualyPace} ${getChange('qualyPace')}</li><li>Race: ${d.racePace} ${getChange('racePace')}</li><li>Cons: ${d.consistency} ${getChange('consistency')}</li><li>Ovr: ${d.overtaking} ${getChange('overtaking')}</li><li>Def: ${d.defending} ${getChange('defending')}</li></ul>${buttonHtml}</div>`;
                }).join('');

                const clickHandler = isInitialSelection ? handleDriverSelection : handleDriverMarketSelection;
                el.querySelectorAll('button:not(:disabled)').forEach(b => { b.addEventListener('click', () => clickHandler(parseInt(b.dataset.driverId))); });

                if(isDriverMarket) {
                    document.getElementById('confirm-drivers-button').disabled = marketSelectedDriverIds.length !== 2;
                }
            } else { /* Fallback for other potential list renderings, currently unused */ el.innerHTML = currentDrivers.sort((a,b) => b.skill - a.skill).map(d => { const team = getTeamById(d.teamId); const teamNameDisplay = team ? ` (${team.name})` : ' (Free Agent)'; return `<div class="card"><h3>${d.name}${teamNameDisplay}</h3><ul><li>Skill: ${d.skill}</li>...</ul></div>`; }).join(''); }
        }
        function renderCarsAndDevelopment() {
            const scd = document.getElementById('selected-car-display'); const ocl = document.getElementById('opponent-cars-list'); const carNameEl = document.getElementById('car-name-placeholder'); const carYearEl = document.getElementById('car-year-placeholder'); const carStatsList = document.getElementById('car-stats-list');
            if (scd && selectedCar && carStatsList) { if(carNameEl) carNameEl.textContent = selectedCar.name; if(carYearEl) carYearEl.textContent = currentSeasonYear; renderPlayerCarStats(selectedCar, carStatsList); }
            else if (scd) { if(carNameEl) carNameEl.textContent = 'N/A'; if(carYearEl) carYearEl.textContent = 'N/A'; if(carStatsList) carStatsList.innerHTML = '<li class="placeholder-text">No car selected.</li>'; }
            renderCarDevelopmentChart(); // Render NEW chart
            renderCarUpgradeOptions();
            // REMOVED renderNextSeasonInvestmentOptions() call
            if (ocl) renderOpponentCars(ocl);
        }
        function renderPlayerCarStats(car, listElement) { if (!listElement) return; const globalStat = calculateCarGlobalStat(car); const maxStat = MAX_STAT_VALUE_PLAYER; listElement.innerHTML = `<li><span>Engine:</span> <span>${car.engine} / ${maxStat}</span></li><li><span>Aerodynamics:</span> <span>${car.aero} / ${maxStat}</span></li><li><span>Chassis:</span> <span>${car.chassis} / ${maxStat}</span></li><li><span>Reliability:</span> <span>${car.reliability} / ${maxStat}</span></li><li class="global-stat"><span>Overall Rating:</span> <span>${globalStat}</span></li>`; }
        function renderCarUpgradeOptions() {
            const uo = document.getElementById('car-upgrade-options'); if (!uo) return; if (selectedCar === null) { uo.innerHTML = '<p class="placeholder-text">Select your team and drivers first.</p>'; return; }
            uo.innerHTML = UpgradesData.map(u => { const isPurchased = purchasedUpgrades[u.id]; const canAfford = budget >= u.cost; const statCap = (selectedCar && selectedCar[u.effect.stat] >= MAX_STAT_VALUE_PLAYER); const isDisabled = isPurchased || !canAfford || statCap; let buttonText = 'Purchase Upgrade'; if (isPurchased) { buttonText = 'Purchased'; } else if (statCap) { buttonText = 'Stat Maxed'; } else if (!canAfford) { buttonText = 'Insufficient Funds'; } const statNameDisplay = u.effect.stat.charAt(0).toUpperCase() + u.effect.stat.slice(1); return `<div class="card ${isDisabled ? 'disabled' : ''}"><h3>${u.name}</h3><ul><li>Cost: $${formatNumber(u.cost)}</li><li>Effect: +${u.effect.value} ${statNameDisplay}</li></ul><button data-upgrade-id="${u.id}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button></div>`; }).join('');
            uo.querySelectorAll('button:not(:disabled)').forEach(b => { b.addEventListener('click', () => handleCarUpgrade(parseInt(b.dataset.upgradeId))); });
        }
        // REMOVED renderNextSeasonInvestmentOptions function
        function renderOpponentCars(div) {
             div.innerHTML = currentEcuries.filter(e => e.id !== selectedEcurieId).sort((a, b) => calculateCarGlobalStat(getCarById(b.defaultCarId)) - calculateCarGlobalStat(getCarById(a.defaultCarId))).map(ecurie => { const oppCar = getCarById(ecurie.defaultCarId); if (!oppCar) return ''; const upgradeInfo = lastAIRaceUpgrades[oppCar.id]; const aiBudget = aiTeamBudgets[ecurie.id] || 0; const globalStat = calculateCarGlobalStat(oppCar); const statDisplay = (statName) => { let display = `${oppCar[statName]}`; if (upgradeInfo && upgradeInfo.stat === statName) { display += ` <span class="stat-increase">(+${upgradeInfo.change})</span>`; } return display; }; return `<div class="card disabled"><h3>${ecurie.name}'s ${oppCar.name}</h3><ul><li>Est. Budget: $${formatNumber(aiBudget)}</li><li>Engine: ${statDisplay('engine')}</li><li>Aero: ${statDisplay('aero')}</li><li>Chassis: ${statDisplay('chassis')}</li><li>Reliability: ${statDisplay('reliability')}</li><li class="global-stat">Overall: ${globalStat}</li></ul></div>`; }).join('');
        }
        function renderSeasonStandings(yearToShow = 'current') {
            const sl = document.getElementById('season-standings-list'); const si = document.getElementById('season-info'); const chartCanvas = document.getElementById('standings-line-chart-canvas'); const chartPlaceholder = document.getElementById('standings-chart-placeholder'); const listTitle = document.getElementById('standings-list-title'); const historySelect = document.getElementById('history-season-select');
            if (!sl || !si || !chartCanvas || !chartPlaceholder || !listTitle || !historySelect) return;
            let standingsData = []; let displayYear = currentSeasonYear; let isHistoryView = false;
            const existingOptions = Array.from(historySelect.options).map(opt => opt.value); const historyYears = Object.keys(seasonHistory).sort((a,b) => b-a); let optionsChanged = false;
            historyYears.forEach(year => { if (!existingOptions.includes(year)) { const option = document.createElement('option'); option.value = year; option.textContent = year; historySelect.appendChild(option); optionsChanged = true; } });
            if (optionsChanged && historySelect.value !== 'current') { historySelect.value = 'current'; }
            if (yearToShow === 'current' || !seasonHistory[yearToShow]) {
                standingsData = Object.entries(driverSeasonScores).map(([driverId, points]) => ({ driver: getDriverById(driverId), points: points || 0 })).filter(item => item.driver).sort((a, b) => b.points - a.points || a.driver.name.localeCompare(b.driver.name));
                displayYear = currentSeasonYear; listTitle.textContent = `Driver Standings (${displayYear})`; let seasonStatusText = `${currentSeasonYear} Season`;
                if (gameState === 'SEASON_END' || (gameState === 'DRIVER_MARKET' && currentRaceIndex === 0)) { seasonStatusText += ' - Final Standings'; } else if (currentRaceIndex === 0 && gameState !== 'DRIVER_MARKET') { seasonStatusText += ' - Pre-Season'; } else { seasonStatusText += ` - After Race ${currentRaceIndex} / ${totalRacesInSeason}`; } si.textContent = seasonStatusText;
                renderStandingsLineChart(standingsData, chartCanvas, chartPlaceholder);
                isHistoryView = false; // Flag for current view
            } else {
                standingsData = seasonHistory[yearToShow]; displayYear = yearToShow; isHistoryView = true; listTitle.textContent = `Driver Standings (${displayYear} Final)`; si.textContent = `${displayYear} Season - Final Standings (History)`;
                chartCanvas.style.display = 'none'; chartPlaceholder.style.display = 'block'; chartPlaceholder.textContent = 'Points progression chart is only available for the current season.'; if (standingsChartInstance) { standingsChartInstance.destroy(); standingsChartInstance = null; }
            }
            if (standingsData.length > 0) {
                sl.innerHTML = standingsData.map((item, index) => {
                    const position = index + 1;
                    const teamNameDisplay = isHistoryView ? ` (${item.teamName || 'Unknown Team'})` : ` (${getTeamById(item.driver?.teamId)?.name || 'Free Agent'})`; // Adjusted team name logic
                    const driverName = isHistoryView ? item.driverName : item.driver?.name;
                    // *** Player Highlighting Logic ***
                    const isPlayerDriver = isHistoryView
                        ? (item.teamId === selectedEcurieId) // Check team ID in history view
                        : selectedDriverIds.includes(item.driver?.id); // Check driver IDs in current view

                    return `<li class="${isPlayerDriver ? 'player-driver' : ''}">
                                <span class="position-number">${position}.</span>
                                <span>${driverName}${teamNameDisplay}</span>
                                <span>${item.points} Pts</span>
                            </li>`;
                }).join('');
            } else {
                sl.innerHTML = `<li class="placeholder-text">No standings data available for ${displayYear}.</li>`;
            }
        }
        function renderStandingsLineChart(sortedScores, canvasElement, placeholderElement) {
             if (!Chart) { console.error("Chart.js not loaded!"); placeholderElement.textContent = 'Error loading chart library.'; placeholderElement.style.display = 'block'; canvasElement.style.display = 'none'; return; }
             // Display chart only after race 1 is completed in the current season
             if (gameState === 'DRIVER_MARKET' || gameState === 'SEASON_END' || currentRaceIndex < 1 ) {
                placeholderElement.textContent = 'Complete the first race of the current season to see the chart.';
                placeholderElement.style.display = 'block';
                canvasElement.style.display = 'none';
                if (standingsChartInstance) {
                    standingsChartInstance.destroy(); standingsChartInstance = null;
                 }
                 return;
             }
             placeholderElement.style.display = 'none'; canvasElement.style.display = 'block';
             if (standingsChartInstance) { standingsChartInstance.destroy(); } const ctx = canvasElement.getContext('2d'); const raceCountForLabels = Math.max(1, currentRaceIndex); const labels = Array.from({ length: raceCountForLabels }, (_, i) => `R${i + 1}`);
             // Only include drivers who have scored points or are currently assigned to a team
             const relevantDrivers = sortedScores.filter(item => item.points > 0 || item.driver?.teamId !== null);
             const datasets = relevantDrivers.slice(0, 10).map((item, index) => { const driverId = item.driver.id; const history = driverRaceHistory[driverId] || []; const color = generateChartColors(index); const dataPoints = labels.map((_, raceIdx) => { return history[raceIdx] !== undefined && history[raceIdx] !== null ? history[raceIdx] : (raceIdx === 0 ? 0 : null); }); return { label: item.driver.name, data: dataPoints, borderColor: color, backgroundColor: color + '80', tension: 0.1, fill: false, pointRadius: 3, pointHoverRadius: 5, borderWidth: 2, }; });
             standingsChartInstance = new Chart(ctx, { type: 'line', data: { labels: labels, datasets: datasets }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: '#e0e0e0', boxWidth: 15, padding: 15 } }, tooltip: { mode: 'index', intersect: false, backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#ff8700', bodyColor: '#ffffff', }, title: { display: false } }, scales: { x: { title: { display: true, text: 'Race Number', color: '#ccc' }, ticks: { color: '#ccc' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { title: { display: true, text: 'Total Points', color: '#ccc' }, beginAtZero: true, ticks: { color: '#ccc' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } } } } });
         }
        function renderCarDevelopmentChart() {
            const container = document.getElementById('car-dev-chart-container');
            const canvasElement = document.getElementById('car-dev-line-chart-canvas');
            const placeholderElement = document.getElementById('car-dev-chart-placeholder');
            if (!container || !canvasElement || !placeholderElement || !Chart) return;

            // Only show chart after the first race is complete
            if (currentRaceIndex < 1 && gameState !== 'SEASON_END' && gameState !== 'DRIVER_MARKET') {
                container.style.display = 'none'; // Keep container hidden
                placeholderElement.style.display = 'block';
                canvasElement.style.display = 'none';
                if (carDevChartInstance) { carDevChartInstance.destroy(); carDevChartInstance = null; }
                return;
            }

            container.style.display = 'block'; // Show container
            placeholderElement.style.display = 'none';
            canvasElement.style.display = 'block';

            if (carDevChartInstance) { carDevChartInstance.destroy(); }

            const ctx = canvasElement.getContext('2d');
            // Labels: Start, R1, R2... up to the *current* race index (state AFTER race i)
            const labels = ["Start"].concat(Array.from({ length: currentRaceIndex }, (_, i) => `R${i + 1}`));

            const datasets = currentEcuries.map((team, index) => {
                const history = carPerformanceHistory[team.id] || [];
                const color = generateChartColors(index);
                const isPlayer = team.id === selectedEcurieId;
                // Ensure data length matches label length, using null for future/missing points
                // Data represents state AT THE END of that index (index 0 = start, index 1 = after R1, etc.)
                const dataPoints = labels.map((_, idx) => history[idx] !== undefined ? history[idx] : null);

                return {
                    label: team.name,
                    data: dataPoints,
                    borderColor: isPlayer ? '#ff8700' : color, // Highlight player
                    backgroundColor: (isPlayer ? '#ff8700' : color) + '80',
                    tension: 0.1,
                    fill: false,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: isPlayer ? 3 : 1.5, // Make player line thicker
                };
            }).sort((a, b) => { // Sort player to top, then by last known rating
                 if (a.label === teamName) return -1; // Player first
                 if (b.label === teamName) return 1;
                 // Find last valid data point for sorting
                 const lastA = a.data.slice().reverse().find(val => val !== null);
                 const lastB = b.data.slice().reverse().find(val => val !== null);
                 return (lastB || 0) - (lastA || 0); // Sort descending by last known rating
            });

            carDevChartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: '#e0e0e0', boxWidth: 12, padding: 10, font: { size: 10 } }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: '#ff8700',
                            bodyColor: '#ffffff',
                        },
                        title: { display: false }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Race Weekend', color: '#ccc' },
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'Overall Car Rating', color: '#ccc' },
                            beginAtZero: false, // Start near the actual values
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
        function renderCalendar() { const cl = document.getElementById('calendar-list'); const ci = document.getElementById('calendar-info'); if (!cl || !ci) return; ci.textContent = `${currentSeasonYear} Race Schedule: ${currentRaceIndex}/${totalRacesInSeason} completed.`; if (currentSeasonCalendar.length === 0) { cl.innerHTML = `<li class="placeholder-text">Calendar will be generated at season start.</li>`; return; } cl.innerHTML = currentSeasonCalendar.map((race, index) => { const isCompleted = index < currentRaceIndex; const isNextRace = index === currentRaceIndex && gameState !== 'SEASON_END' && gameState !== 'DRIVER_MARKET'; let liClasses = []; if (isCompleted) liClasses.push('completed'); if (isNextRace) liClasses.push('next-race'); return `<li class="${liClasses.join(' ')}"><span class="race-name">${index + 1}. ${race.name} (${race.laps} Laps)</span><ul class="race-details"><li>Track Type: ${getTrackType(race)}</li><li>Key Focus: Spd ${race.speedFocus} / Hnd ${race.handlingFocus} / Rel ${race.reliabilityStress}</li></ul></li>`; }).join(''); }
        function renderQualifyingResults(stage, results) {
             const listEl = document.querySelector(`#${stage}-results ol`); if (!listEl) return;
             const placeholder = listEl.querySelector('.placeholder-text'); if(placeholder) placeholder.remove();
             listEl.innerHTML = results.map((r, i) => {
                 const team = getTeamById(r.driver.teamId);
                 const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : '';
                 // Format the time (which is now in ms)
                 const timeStr = formatTimeMs(r.time);
                 const isPlayer = selectedDriverIds.includes(r.driver.id);
                 let position = i + 1;
                 // Changed to put time in a separate span for alignment
                 return `<li class="${isPlayer ? 'player-driver' : ''}"><span>${position}. ${r.driver.name}${teamAbbr}</span> <span class="time-display">${timeStr}</span></li>`;
             }).join('');
             if (stage === 'q1' || stage === 'q2') {
                 const cutoff = (stage === 'q1') ? 15 : 10;
                 listEl.querySelectorAll('li').forEach((li, i) => { if (i >= cutoff) li.style.opacity = '0.6'; });
             }
         }
        function renderStartingGrid() { const gridEl = document.querySelector('#starting-grid ol'); if (!gridEl) return; const placeholder = gridEl.querySelector('.placeholder-text'); if(placeholder) placeholder.remove(); gridEl.innerHTML = startingGrid.map((pos, i) => { const team = getTeamById(pos.driver.teamId); const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : ''; const isPlayer = selectedDriverIds.includes(pos.driver.id); return `<li class="${isPlayer ? 'player-driver' : ''}">${i + 1}. ${pos.driver.name}${teamAbbr}</li>`; }).join(''); }
        function renderLiveLeaderboard() { const lbEl = document.querySelector('#live-leaderboard ol'); const lcEl = document.getElementById('live-lap-counter'); const currentRace = currentSeasonCalendar[currentRaceIndex]; const totalLaps = currentRace ? currentRace.laps : 0; if (!lbEl || !lcEl) return; lcEl.textContent = `Lap: ${currentLap} / ${totalLaps}`; raceLeaderboard.sort((a, b) => { const statusOrder = { 'Racing': 1, 'Finished': 2, 'DNF': 3 }; if (statusOrder[a.status] !== statusOrder[b.status]) { return statusOrder[a.status] - statusOrder[b.status]; } if (a.lapsCompleted !== b.lapsCompleted) { return b.lapsCompleted - a.lapsCompleted; } return a.totalRaceTime - b.totalRaceTime; }); const leader = raceLeaderboard.find(e => e.status === 'Racing' || e.status === 'Finished'); lbEl.innerHTML = raceLeaderboard.map((entry, index) => { const team = getTeamById(entry.driver.teamId); const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : ''; const isPlayer = selectedDriverIds.includes(entry.driver.id); let statusText = entry.status === 'DNF' ? ' <span class="status-dnf">(DNF)</span>' : ''; let gapText = ''; if (entry.status === 'Racing' || entry.status === 'Finished') { if (entry === leader) { gapText = `Leader`; } else if (leader) { if (leader.lapsCompleted > entry.lapsCompleted) { const lapDiff = leader.lapsCompleted - entry.lapsCompleted; gapText = `+${lapDiff} Lap${lapDiff > 1 ? 's' : ''}`; } else { const timeDiffMs = entry.totalRaceTime - leader.totalRaceTime; gapText = `+${(timeDiffMs / 1000).toFixed(3)}s`; } } else { gapText = "-"; } } else if (entry.status === 'DNF') { gapText = `(DNF Lap ${entry.lapsCompleted})`; } return `<li class="${isPlayer ? 'player-driver' : ''}"><span>${index + 1}. ${entry.driver.name}${teamAbbr}${statusText}</span><span class="gap-display">${gapText}</span></li>`; }).join(''); }
        function renderFinalRaceResults(finalLeaderboard, raceName, playerMoneyEarned) { // PARAMETER CHANGED HERE
            const resEl = document.getElementById('race-results'); const listEl = resEl?.querySelector('ol'); const msgEl = resEl?.querySelector('#race-message'); const prizeLEl = resEl?.querySelector('#prize-money-earned ul'); const prizeTEl = resEl?.querySelector('#prize-money-earned p'); const placeholder = document.getElementById('final-results-placeholder'); if (!resEl || !listEl || !msgEl || !prizeLEl || !prizeTEl || !placeholder) return;
            placeholder.style.display = 'none'; resEl.style.display = 'block'; resEl.querySelector('h3').textContent = `Final Results: ${raceName} (${currentSeasonYear})`;
            finalLeaderboard.sort((a, b) => { const statusOrder = { 'Finished': 1, 'DNF': 2 }; if (statusOrder[a.status] !== statusOrder[b.status]) return statusOrder[a.status] - statusOrder[b.status]; if (a.lapsCompleted !== b.lapsCompleted) return b.lapsCompleted - a.lapsCompleted; if (a.status === 'Finished' && b.status === 'Finished') return a.totalRaceTime - b.totalRaceTime; return 0; });
            listEl.innerHTML = finalLeaderboard.map((entry, index) => { const position = index + 1; const isPlayerDriver = selectedDriverIds.includes(entry.driver.id); const team = getTeamById(entry.driver.teamId); const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : ''; let driverText = `${entry.driver.name}${teamAbbr}`; let pointsText = ''; let detailText = ''; if (entry.status === 'Finished') { if (index < PointsSystem.length) { pointsText = ` (+${PointsSystem[index]} pts)`; } } else if (entry.status === 'DNF') { driverText += ` <span class="status-dnf">(DNF)</span>`; detailText = ` (Lap ${entry.lapsCompleted})`; } return `<li class="${isPlayerDriver ? 'player-driver' : ''}">${driverText}${detailText}${pointsText}</li>`; }).join('');
            msgEl.textContent = `Race finished. Points and prize money awarded. Check Standings tab for updates.`; let playerPrizeHtml = '';
            finalLeaderboard.forEach((entry, index) => { if (entry.status === 'Finished' && selectedDriverIds.includes(entry.driver.id)) { const pos = index + 1; let breakdownItems = []; const pointsAwarded = (index < PointsSystem.length) ? PointsSystem[index] : 0; const moneyPoints = pointsAwarded * PRIZE_MONEY_PER_POINT; if (moneyPoints > 0) { breakdownItems.push(`$${formatNumber(moneyPoints)} (Pts)`); } const moneyPodium = (pos <= 3) ? PRIZE_MONEY_PODIUM_BONUS : 0; if (moneyPodium > 0) { breakdownItems.push(`$${formatNumber(moneyPodium)} (Podium)`); } const moneyTop10 = (pos <= 10) ? PRIZE_MONEY_TOP_10_BONUS : 0; if (moneyTop10 > 0 && moneyPodium === 0) { breakdownItems.push(`$${formatNumber(moneyTop10)} (Top 10)`); } const moneyP11_P20 = (pos > 10 && pos <= 20) ? PRIZE_MONEY_P11_P20_BONUS : 0; if (moneyP11_P20 > 0) { breakdownItems.push(`$${formatNumber(moneyP11_P20)} (P11-P20)`); } if (breakdownItems.length > 0) { playerPrizeHtml += `<li>${entry.driver.name} (${getOrdinalSuffix(pos)}): ${breakdownItems.join(' + ')}</li>`; } } });
            prizeLEl.innerHTML = playerPrizeHtml || '<li>No prize money earned this race.</li>';
            prizeTEl.textContent = `Total Earned: $${formatNumber(playerMoneyEarned)}`; // Use parameter here
        }
        function renderNotifications() { const listEl = document.getElementById('notifications-list'); if (!listEl) return; const placeholder = listEl.querySelector('.placeholder'); if (notificationsLog.length === 0) { listEl.innerHTML = '<li class="placeholder">No notifications yet.</li>'; return; } if (placeholder) placeholder.remove(); listEl.innerHTML = notificationsLog.map(note => { return `<li class="${note.typeClass || ''}"><span class="timestamp">[${note.timestamp}]</span><span class="event-type">${note.type.toUpperCase()}:</span>${note.message}</li>`; }).join(''); }
        function renderDriverMarket() {
            const marketListDiv = document.getElementById('driver-market-list'); if (!marketListDiv) return;
            renderDriversList('driver-market-list', false); // Reuse the generic list renderer
            document.getElementById('driver-market-title').innerHTML = `Driver Market - End of Season ${currentSeasonYear-1}`; // Show year completed
            document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; // Show budget before signing
         }
        function renderAllTabs() { renderCarsAndDevelopment(); renderDriversList('drivers-list-management', false); renderSeasonStandings(); renderCalendar(); renderNotifications(); }
        function updateRaceHQButtonState() { const qb = document.getElementById('run-qualifying-button'); const srb = document.getElementById('start-race-button'); const acb = document.getElementById('accelerate-race-button'); const ngb = document.getElementById('next-gp-button'); const nsb = document.getElementById('next-season-button'); const raceControls = document.getElementById('race-controls'); qb.style.display = 'none'; srb.style.display = 'none'; acb.style.display = 'none'; ngb.style.display = 'none'; nsb.style.display = 'none'; if (!raceControls) return; if (gameState === 'SEASON_END') { nsb.style.display = 'inline-block'; nsb.disabled = false; } else if (gameState === 'MANAGEMENT' && currentRaceIndex >= totalRacesInSeason) { gameState = 'SEASON_END'; updateRaceHQButtonState(); } else if (gameState === 'MANAGEMENT' && raceCompletedForCurrentIndex) { ngb.style.display = 'inline-block'; ngb.disabled = false; } else if (gameState === 'MANAGEMENT' && startingGrid.length > 0 && !raceCompletedForCurrentIndex) { srb.style.display = 'inline-block'; acb.style.display = 'inline-block'; const raceInProgress = raceIntervalId !== null; srb.disabled = raceInProgress; acb.disabled = raceInProgress; } else if (gameState === 'MANAGEMENT' && startingGrid.length === 0) { qb.style.display = 'inline-block'; qb.disabled = false; const raceName = currentSeasonCalendar[currentRaceIndex]?.name || 'Next Race'; qb.textContent = `Run Qualifying: ${raceName}`; } else { qb.style.display = 'none'; srb.style.display = 'none'; acb.style.display = 'none'; ngb.style.display = 'none'; nsb.style.display = 'none'; } }
        function clearQualifyingUI() { const stages = ['q1', 'q2', 'q3']; stages.forEach(stage => { const listEl = document.querySelector(`#${stage}-results ol`); if(listEl) listEl.innerHTML = `<li class="placeholder-text">${stage === 'q1' ? 'Run qualifying to see results.' : ''}</li>`; }); const gridEl = document.querySelector('#starting-grid ol'); if(gridEl) gridEl.innerHTML = `<li class="placeholder-text"></li>`; document.getElementById('qualifying-title').textContent = 'Qualifying'; }

        // --- UI Interaction Handlers ---

        function handleBudgetSelection(amount) { budget = amount; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; showMessage(`Budget set to $${formatNumber(amount)}`, 'success', 2000); document.getElementById('initial-budget-selection').style.display = 'none'; renderEcurieSelection(); document.getElementById('ecurie-selection').style.display = 'grid'; }
        function handleEcurieSelection(ecurieId) { const selectedEcurie = getTeamById(ecurieId); if (!selectedEcurie) { showMessage("Team not found.", 'error'); return; } if (budget < selectedEcurie.cost) { showMessage("Insufficient funds for this team.", 'error'); return; } selectedEcurieId = ecurieId; budget -= selectedEcurie.cost; teamName = selectedEcurie.name; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; selectedCar = getCarById(selectedEcurie.defaultCarId); if (!selectedCar) { console.error(`Initial car (ID: ${selectedEcurie.defaultCarId}) not found for ${teamName}`); } showMessage(`${selectedEcurie.name} selected! Cost: $${formatNumber(selectedEcurie.cost)}`, 'success'); document.getElementById('ecurie-selection').style.display = 'none'; document.getElementById('initial-driver-selection').style.display = 'block'; document.getElementById('drivers-title').textContent = `Select Two Drivers for ${teamName}`; renderDriversList('drivers-list', true); }
        function handleDriverSelection(driverId) { const driverToSelect = getDriverById(driverId); if (!driverToSelect) return; const isSelected = selectedDriverIds.includes(driverId); if (isSelected) { selectedDriverIds = selectedDriverIds.filter(id => id !== driverId); budget += driverToSelect.cost; showMessage(`${driverToSelect.name} deselected. Budget +$${formatNumber(driverToSelect.cost)}`, 'info', 2000); } else { if (selectedDriverIds.length >= 2) { showMessage("Team already full (Max 2 drivers). Deselect one first.", 'error'); return; } if (budget < driverToSelect.cost) { showMessage(`Insufficient funds for ${driverToSelect.name}. Need $${formatNumber(driverToSelect.cost)}`, 'error'); return; } selectedDriverIds.push(driverId); budget -= driverToSelect.cost; showMessage(`${driverToSelect.name} selected! Budget -$${formatNumber(driverToSelect.cost)}`, 'success', 2000); } document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; renderDriversList('drivers-list', true); if (selectedDriverIds.length === 2) { showMessage("Team complete! Initializing game management...", 'success', 2500); document.getElementById('drivers-list').querySelectorAll('button').forEach(b => b.disabled = true); setTimeout(initializeGameAfterSetup, 1500); } }
        function handleCarUpgrade(upgradeId) {
            const upgrade = UpgradesData.find(up => up.id === upgradeId); if (!upgrade || !selectedCar) return; if (purchasedUpgrades[upgrade.id]) { showMessage("Upgrade already purchased.", 'info'); return; } if (budget < upgrade.cost) { showMessage("Insufficient funds for this upgrade.", 'error'); return; } const stat = upgrade.effect.stat; if (selectedCar[stat] >= MAX_STAT_VALUE_PLAYER) { showMessage(`${stat.charAt(0).toUpperCase() + stat.slice(1)} is already maxed out.`, 'info'); return; } budget -= upgrade.cost; const currentValue = selectedCar[stat]; const newValue = clamp(currentValue + upgrade.effect.value, 50, MAX_STAT_VALUE_PLAYER); const actualChange = newValue - currentValue;
             if (actualChange > 0) { selectedCar[stat] = newValue; purchasedUpgrades[upgrade.id] = true; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; showMessage(`${upgrade.name} purchased! ${stat} +${actualChange}.`, 'success'); addNotification(`Player upgraded ${upgrade.name} (+${actualChange} ${stat})`, 'upgrade'); renderCarsAndDevelopment(); }
             else { budget += upgrade.cost; showMessage(`Upgrade ${upgrade.name} provided no benefit. Purchase cancelled.`, 'info'); document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; }
        }
        // REMOVED handleNextSeasonInvestment / R&D Package logic
        function handleDriverMarketSelection(driverId) {
            const driver = getDriverById(driverId); if (!driver) return;
            const isSelected = marketSelectedDriverIds.includes(driverId);

            if (isSelected) {
                marketSelectedDriverIds = marketSelectedDriverIds.filter(id => id !== driverId);
                showMessage(`${driver.name} deselected.`, 'info');
            } else {
                if (marketSelectedDriverIds.length >= 2) {
                    showMessage("Deselect a driver first (Max 2).", 'error');
                    return;
                }
                marketSelectedDriverIds.push(driverId);
                showMessage(`${driver.name} selected!`, 'success');
            }
            renderDriverMarket(); // Re-render market to reflect selection and update button states
        }
        function handleConfirmDriverSelection() {
            if (marketSelectedDriverIds.length !== 2) {
                showMessage("You must select exactly two drivers.", "error"); return;
            }
            const previousPlayerDrivers = [...selectedDriverIds];
            selectedDriverIds = [...marketSelectedDriverIds];

            // **NO LONGER DEDUCT DRIVER COST HERE**
            document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; // Budget remains unchanged by signing

            const playerTeam = getTeamById(selectedEcurieId);
            if (playerTeam) playerTeam.driverIds = selectedDriverIds;

            // Assign team ID to selected drivers
            selectedDriverIds.forEach(id => { const driver = getDriverById(id); if (driver) driver.teamId = selectedEcurieId; });

             // Reset team IDs for drivers *not* selected by player or AI (makes them free agents)
             currentDrivers.forEach(driver => {
                 if (!selectedDriverIds.includes(driver.id)) {
                      // Check if they are assigned to an AI team by the assignAIDriversRanked function later
                      // For now, tentatively set to null unless they were just dropped by the player
                      if (!previousPlayerDrivers.includes(driver.id)) {
                          driver.teamId = null;
                      }
                 }
             });

            assignAIDriversRanked(); // Re-assign AI drivers based on car/skill after player choice
            generateDriverChangeNotifications(previousPlayerDrivers);
            gameState = 'MANAGEMENT';
            document.getElementById('driver-market-screen').style.display = 'none';
            document.getElementById('team-management-screen').style.display = 'block';
            resetSeasonState(true); // Reset race state, clear old upgrades, set up new history arrays
            showMessage(`Team confirmed for the ${currentSeasonYear} season! Check Notifications for transfers.`, 'success', 4000);
            updateRaceHQButtonState();
            renderAllTabs();
            activateTab('development');
            activateRaceSubTab('qualifying');
        }
        function setupTabs() { document.querySelectorAll('.tab-button').forEach(button => { button.addEventListener('click', () => activateTab(button.dataset.tab)); }); }
        function activateTab(targetTab) { if (gameState === 'DRIVER_MARKET') { showMessage("Confirm your driver selection first.", "info"); return; } if (raceIntervalId && targetTab !== 'race') { showMessage("Cannot switch tabs during live race simulation. Finish or wait.", "info"); activateTab('race'); activateRaceSubTab('live'); return; } document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none'); const activeButton = document.querySelector(`.tab-button[data-tab="${targetTab}"]`); const activeContent = document.getElementById(`${targetTab}-tab`); if (activeButton) activeButton.classList.add('active'); if (activeContent) activeContent.style.display = 'block'; if (targetTab === 'development') renderCarsAndDevelopment(); if (targetTab === 'drivers') renderDriversList('drivers-list-management', false); if (targetTab === 'standings') renderSeasonStandings(); if (targetTab === 'calendar') renderCalendar(); if (targetTab === 'notifications') renderNotifications(); if (targetTab === 'race') { updateRaceHQButtonState(); const raceSubTabs = document.querySelectorAll('#race-tab .sub-tab-button'); const activeSubTab = document.querySelector('#race-tab .sub-tab-button.active'); if (!activeSubTab && raceSubTabs.length > 0) { activateRaceSubTab(raceSubTabs[0].dataset.subtab); } } }
        function setupRaceSubTabs() { document.querySelectorAll('#race-tab .sub-tab-button').forEach(button => { button.addEventListener('click', () => { if (raceIntervalId && button.dataset.subtab !== 'live') { showMessage("Cannot switch sub-tabs during live race simulation.", "info"); return; } activateRaceSubTab(button.dataset.subtab); }); }); }
        function activateRaceSubTab(targetSubTab) { document.querySelectorAll('#race-tab .sub-tab-button').forEach(btn => btn.classList.remove('active')); document.querySelectorAll('#race-tab .sub-tab-content').forEach(content => content.classList.remove('active')); const activeButton = document.querySelector(`#race-tab .sub-tab-button[data-subtab="${targetSubTab}"]`); const activeContent = document.getElementById(`race-${targetSubTab}-subtab-content`); if (activeButton) activeButton.classList.add('active'); if (activeContent) activeContent.classList.add('active'); const livePlaceholder = document.getElementById('live-race-placeholder'); const finalPlaceholder = document.getElementById('final-results-placeholder'); const liveAreaVisible = document.getElementById('live-race-area').style.display !== 'none'; const finalAreaVisible = document.getElementById('race-results').style.display !== 'none'; if (livePlaceholder) livePlaceholder.style.display = (targetSubTab === 'live' && !liveAreaVisible) ? 'block' : 'none'; if (finalPlaceholder) finalPlaceholder.style.display = (targetSubTab === 'final' && !finalAreaVisible) ? 'block' : 'none'; }
        function setupHistoryDropdown() { const historySelect = document.getElementById('history-season-select'); if (historySelect) { historySelect.addEventListener('change', (event) => { renderSeasonStandings(event.target.value); }); } }

        // --- Simulation Logic ---

        function calculateCarGlobalStat(car) { if (!car) return 0; const stats = ['engine', 'aero', 'chassis', 'reliability']; let weightedSum = 0; let totalWeight = 0; stats.forEach(stat => { const weight = GLOBAL_STAT_WEIGHTS[stat] || 0; weightedSum += (car[stat] || 0) * weight; totalWeight += weight; }); return totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0; }
        function calculateQualifyingPerformance(driver, car, track) {
            let timeMs = QUALI_BASE_TIME_MS;
            timeMs -= (driver.qualyPace - 80) * QUALI_DRIVER_TIME_FACTOR;
            timeMs -= (car.engine - 80) * QUALI_CAR_ENGINE_TIME_FACTOR * (track.speedFocus / 85);
            timeMs -= (car.aero - 80) * QUALI_CAR_AERO_TIME_FACTOR * ((track.speedFocus + track.handlingFocus) / 170);
            timeMs -= (car.chassis - 80) * QUALI_CAR_CHASSIS_TIME_FACTOR * (track.handlingFocus / 85);
            const randomVariation = (Math.random() * 2 - 1) * QUALI_RANDOM_MS_FACTOR;
            timeMs += randomVariation;
            return Math.max(60000, timeMs); // Min 1 minute
        }
        function calculateLapTime(driver, car, track, isCurrentlyLeader) { let baseTime = LAPTIME_BASE_MS; baseTime += (track.speedFocus - 85) * -4; baseTime += (track.handlingFocus - 85) * -3; let driverFactor = (driver.racePace - 85) * LAPTIME_DRIVER_PACE_FACTOR; let engineFactor = (car.engine - 85) * LAPTIME_CAR_ENGINE_FACTOR * (track.speedFocus / 85); let aeroFactor = (car.aero - 85) * LAPTIME_CAR_AERO_FACTOR * ((track.speedFocus + track.handlingFocus) / 170); let chassisFactor = (car.chassis - 85) * LAPTIME_CAR_CHASSIS_FACTOR * (track.handlingFocus / 85); let consistencyRange = (100 - driver.consistency) * LAPTIME_CONSISTENCY_FACTOR; let consistencyVariation = (Math.random() * 2 - 1) * consistencyRange; let lapTime = baseTime - driverFactor - engineFactor - aeroFactor - chassisFactor + consistencyVariation; let eventTimeAdjustment = 0; let eventHappened = false; const randomEventCheck = Math.random(); if (randomEventCheck < MAJOR_MISTAKE_CHANCE) { const penalty = MAJOR_MISTAKE_MIN_TIME_MS + Math.random() * (MAJOR_MISTAKE_MAX_TIME_MS - MAJOR_MISTAKE_MIN_TIME_MS); eventTimeAdjustment = penalty; eventHappened = true; const mistakeMsg = `Major Mistake: ${driver.name} lost significant time! (+${(penalty/1000).toFixed(2)}s)`; const leaderMsg = isCurrentlyLeader ? " (Race Leader!)" : ""; addNotification(mistakeMsg + leaderMsg, 'error'); } else if (!eventHappened && randomEventCheck < MAJOR_MISTAKE_CHANCE + MINOR_MISTAKE_CHANCE) { const penalty = MINOR_MISTAKE_BASE_TIME_MS + (100 - driver.consistency) * MINOR_MISTAKE_CONSISTENCY_SCALE * Math.random(); eventTimeAdjustment = penalty; eventHappened = true; } else if (!eventHappened && randomEventCheck > (1.0 - BOOST_CHANCE)) { const gain = BOOST_MIN_TIME_MS + Math.random() * (BOOST_MAX_TIME_MS - BOOST_MIN_TIME_MS); eventTimeAdjustment = -gain; eventHappened = true; } lapTime += eventTimeAdjustment; lapTime += (Math.random() - 0.5) * 30; return Math.max(10000, lapTime); }
        function checkReliability(driver, car, track) {
            if (dnfCountThisRace >= maxDnfThisRace) return false;
            let dnfChance = RACE_RELIABILITY_DNF_BASE_CHANCE;
            let baseTarget = 85; let reliabilityDelta = car.reliability - baseTarget;
            dnfChance -= reliabilityDelta * RELIABILITY_IMPACT_FACTOR; // Reliability impact
            dnfChance += (track.reliabilityStress / 100) * TRACK_STRESS_FACTOR; // Track stress impact
            dnfChance += (Math.random() - 0.5) * 0.0002; // Noise
            dnfChance = Math.max(0.0001, Math.min(0.03, dnfChance)); // Clamp 0.01% to 3%
            return Math.random() < dnfChance;
        }
        function attemptOvertake(atkEntry, defEntry, track, currentLap) { if (!atkEntry || !defEntry || atkEntry.status !== 'Racing' || defEntry.status !== 'Racing' || currentLap <= 1) return false; if (atkEntry.lapsCompleted !== defEntry.lapsCompleted) return false; const gapMs = defEntry.totalRaceTime - atkEntry.totalRaceTime; const lapTimeDiffMs = defEntry.lastLapTime - atkEntry.lastLapTime; if (gapMs > 0 && gapMs < OVERTAKE_GAP_THRESHOLD_MS && lapTimeDiffMs > OVERTAKE_LAPTIME_DIFF_THRESHOLD_MS) { const a = atkEntry.driver, cA = atkEntry.car; const d = defEntry.driver, cD = defEntry.car; let skillFactor = (a.overtaking - d.defending) * RACE_OVERTAKE_SKILL_FACTOR; let carFactor = ((cA.engine - cD.engine) * RACE_CAR_OVERTAKE_ENGINE_FACTOR + (cA.aero - cD.aero) * RACE_CAR_OVERTAKE_AERO_FACTOR) * (track.speedFocus / 85); let overtakeChance = RACE_OVERTAKE_BASE_CHANCE + skillFactor + carFactor; const randomFluctuation = (Math.random() * 2 - 1) * OVERTAKE_RANDOM_FACTOR * overtakeChance; overtakeChance += randomFluctuation; overtakeChance = Math.max(0.05, Math.min(0.95, overtakeChance)); return Math.random() < overtakeChance; } return false; }
        function applyStatChangesAndCap(car, team) {
            const rank = teamPreviousSeasonRank[team.id] || 10;
            const potentialTier = CONSTRUCTOR_RD_POTENTIAL.find(tier => rank >= tier.rankMin && rank <= tier.rankMax)
                                || CONSTRUCTOR_RD_POTENTIAL[CONSTRUCTOR_RD_POTENTIAL.length - 1];
            const investmentChoice = (team.id === selectedEcurieId) ? playerChosenInvestmentStat : aiTeamChosenInvestmentStats[team.id];
            const carStatKeys = ['engine', 'aero', 'chassis', 'reliability'];
            const statsBefore = { ...car };
            let changesLog = [];

            carStatKeys.forEach(stat => {
                let minChange = potentialTier.min;
                let maxChange = potentialTier.max;

                // Apply investment boost if this stat was chosen
                if (stat === investmentChoice) {
                    minChange += INVESTMENT_POTENTIAL_BOOST.min;
                    maxChange += INVESTMENT_POTENTIAL_BOOST.max;
                }

                const change = randomizeBetween(minChange, maxChange);
                const oldValue = car[stat];
                let maxCap = (team.id === selectedEcurieId) ? MAX_STAT_VALUE_PLAYER : MAX_STAT_VALUE_AI;
                car[stat] = clamp(oldValue + change, 50, maxCap); // Apply change cumulatively

                if (car[stat] !== oldValue) {
                    const sign = car[stat] > oldValue ? '+' : '';
                    changesLog.push(`${stat.charAt(0).toUpperCase() + stat.slice(1)} ${sign}${car[stat] - oldValue}`);
                }
            });

            // --- Apply Global Stat Cap ---
            let currentGlobal = calculateCarGlobalStat(car);
            let capped = false;
            if (currentGlobal > GLOBAL_STAT_CAP) { // Cap at 99 (so check > 99)
                capped = true;
                const scaleFactor = GLOBAL_STAT_CAP / currentGlobal;
                carStatKeys.forEach(stat => {
                    // Apply scaling, but ensure it doesn't drop below a floor (e.g., 50)
                    car[stat] = Math.max(50, Math.round(car[stat] * scaleFactor));
                });
                 // Recalculate global after capping individual stats
                 currentGlobal = calculateCarGlobalStat(car); // This should now be <= GLOBAL_STAT_CAP
                 changesLog.push(`Overall Rating Capped near ${GLOBAL_STAT_CAP}`);
             }
            // -----------------------------

            if (changesLog.length > 0) {
                const investmentText = investmentChoice ? `(Invested: ${investmentChoice.toUpperCase()})` : '(Standard Dev)';
                const cappedText = capped ? " [CAPPED]" : "";
                addNotification(`Car ${team.name}'s ${car.name} (Rank ${rank} Potential) ${investmentText}${cappedText} changes: ${changesLog.join(', ')}. Final Overall: ${currentGlobal}`, 'stats');
            }
            return currentGlobal; // Return final global stat after potential capping
        }
        function randomizeCarStats() { // Applies changes based on rank/investment and caps result
            addNotification("Applying end-of-season car development based on performance & investment...", 'stats');
            currentCars.forEach(car => {
                const team = currentEcuries.find(t => t.defaultCarId === car.id);
                if (!team) return;
                applyStatChangesAndCap(car, team); // Apply changes and potential cap
                // Update player's selectedCar reference if it's their car
                if (team.id === selectedEcurieId) {
                    selectedCar = car;
                }
            });
            if (selectedEcurieId && !selectedCar) { // Failsafe
                const playerTeamCarId = getTeamById(selectedEcurieId)?.defaultCarId;
                if(playerTeamCarId) selectedCar = getCarById(playerTeamCarId);
            }
            addNotification("Car stat development complete.", 'stats');
        }
        function randomizeDriverStats() {
            addNotification("Randomizing end-of-season driver stats and costs...", 'stats');
            const driverStatKeys = ['qualyPace', 'racePace', 'consistency', 'overtaking', 'defending', 'skill'];
            // --- Use the UPDATED DriversData as the base for comparison ---
            const originalDriversData = JSON.parse(JSON.stringify(DriversData));

            currentDrivers.forEach(driver => {
                const baseDriver = originalDriversData.find(d => d.id === driver.id);
                if (!baseDriver) {
                    // This might be a driver added mid-game or if data mismatch. Handle gracefully.
                    console.warn(`Base data not found for driver ID ${driver.id} (${driver.name}) during stat randomization. Using current data as base.`);
                    // baseDriver = { ...driver }; // Use current as a fallback base (less ideal)
                    // Or simply skip cost adjustment for this driver if base is missing
                     let changesLog = [];
                     let oldSkill = driver.skill;
                     driverStatKeys.forEach(stat => {
                         const change = randomizeBetween(-2, 2);
                         const oldValue = driver[stat];
                         driver[stat] = clamp(oldValue + change, 50, 100);
                         if (driver[stat] !== oldValue) {
                             let statName = stat.replace('Pace', ' Pace').replace(/([A-Z])/g, ' $1').trim();
                             statName = statName.charAt(0).toUpperCase() + statName.slice(1);
                              changesLog.push(`${statName} ${driver[stat] > oldValue ? '+' : ''}${driver[stat] - oldValue}`);
                         }
                     });
                     if (changesLog.length > 0) {
                         addNotification(`Driver ${driver.name}'s stats changed: ${changesLog.join(', ')} (Base cost unchanged)`, 'stats');
                     }
                     return; // Skip cost adjustment if no proper base
                }


                let changesLog = [];
                let oldSkill = driver.skill; // Store skill before changes this round

                driverStatKeys.forEach(stat => {
                    const change = randomizeBetween(-2, 2);
                    const oldValue = driver[stat];
                    driver[stat] = clamp(oldValue + change, 50, 100); // Apply change to *current* value, then clamp
                    if (driver[stat] !== oldValue) {
                         let statName = stat.replace('Pace', ' Pace').replace(/([A-Z])/g, ' $1').trim(); // Add space before caps
                         statName = statName.charAt(0).toUpperCase() + statName.slice(1); // Capitalize first letter
                         changesLog.push(`${statName} ${driver[stat] > oldValue ? '+' : ''}${driver[stat] - oldValue}`);
                    }
                });

                // Calculate Cost Change based on Skill change *relative to original base*
                const skillChangeVsBase = driver.skill - baseDriver.skill;
                const costAdjustment = skillChangeVsBase * DRIVER_COST_SKILL_FACTOR;
                const oldCost = driver.cost;
                // Apply adjustment to original base cost, then clamp
                driver.cost = clamp(baseDriver.cost + costAdjustment, DRIVER_MIN_COST, Infinity); // Apply min cost

                if (driver.cost !== oldCost) {
                    const costDiff = driver.cost - oldCost;
                    const costSign = costDiff > 0 ? '+' : '';
                    changesLog.push(`Value ${costSign}$${formatNumber(Math.abs(costDiff))}`); // Changed "Cost" to "Value"
                    // Notify player if their driver's cost changed significantly
                    if (selectedDriverIds.includes(driver.id) && Math.abs(costDiff) > 0) {
                        addNotification(`${driver.name}'s market value changed to $${formatNumber(driver.cost)} (${costSign}$${formatNumber(Math.abs(costDiff))}).`, 'transfer');
                    }
                }

                if (changesLog.length > 0) {
                    addNotification(`Driver ${driver.name}'s stats/value changed: ${changesLog.join(', ')}`, 'stats');
                }
            });
            addNotification("Driver stat and value randomization complete.", 'stats');
        }
        function runQualifyingStage(participants, numToAdvance, stageName) {
            const currentRace = currentSeasonCalendar[currentRaceIndex];
            let results = participants.map(p => ({
                driver: p.driver,
                car: p.car,
                time: calculateQualifyingPerformance(p.driver, p.car, currentRace) // Returns ms
            }));
            results.sort((a, b) => a.time - b.time); // Lower time is better
            qualifyingResults[stageName] = results.map(r => ({...r}));
            renderQualifyingResults(stageName, results); // Renders using the time (ms)
            return results.slice(0, numToAdvance);
        }
        function determineStartingGrid() { startingGrid = []; startingGrid = qualifyingResults.q3.map(r => ({ driver: r.driver, car: r.car })); const q2FinishersNotInQ3 = qualifyingResults.q2.filter(q2r => !startingGrid.some(sgr => sgr.driver.id === q2r.driver.id)); startingGrid = startingGrid.concat(q2FinishersNotInQ3.map(r => ({ driver: r.driver, car: r.car }))); const q1FinishersNotInQ2 = qualifyingResults.q1.filter(q1r => !startingGrid.some(sgr => sgr.driver.id === q1r.driver.id)); startingGrid = startingGrid.concat(q1FinishersNotInQ2.map(r => ({ driver: r.driver, car: r.car }))); }
        function runRaceLap() {
            const track = currentSeasonCalendar[currentRaceIndex];
            currentLap++;
            const currentLeaderEntry = raceLeaderboard.find(e => e.status === 'Racing' || e.status === 'Finished');

            // 1. Calculate individual lap times (including mistakes/boosts) and check DNFs
            raceLeaderboard.forEach((entry) => {
                if (entry.status === 'Racing') {
                    if (checkReliability(entry.driver, entry.car, track)) {
                        entry.status = 'DNF';
                        entry.lastLapTime = Infinity;
                        entry.lapsCompleted = currentLap - 1;
                        dnfCountThisRace++;
                        const leaderMsg = (entry === currentLeaderEntry) ? " (Race Leader!)" : "";
                        addNotification(`${entry.driver.name} DNF on lap ${entry.lapsCompleted + 1}${leaderMsg}`, 'error');
                    } else {
                        const isLeader = (entry === currentLeaderEntry);
                        const lapTime = calculateLapTime(entry.driver, entry.car, track, isLeader); // Calculates base + mistake + normal boost
                        entry.lastLapTime = lapTime;
                        entry.totalRaceTime += lapTime; // Apply the calculated lap time
                        entry.lapsCompleted = currentLap;
                    }
                } else {
                    if (entry.status === 'DNF') entry.lastLapTime = Infinity;
                }
            });

            // 2. Apply "Catch-Up Boost" based on current gaps *after* lap times are applied
            // Sort leaderboard temporarily to ensure we check against the *actual* car ahead
            const sortedForBoost = [...raceLeaderboard].sort((a, b) => { const statusOrder = { 'Racing': 1, 'Finished': 2, 'DNF': 3 }; if (statusOrder[a.status] !== statusOrder[b.status]) { return statusOrder[a.status] - statusOrder[b.status]; } if (a.lapsCompleted !== b.lapsCompleted) { return b.lapsCompleted - a.lapsCompleted; } return a.totalRaceTime - b.totalRaceTime; });

            for (let i = 1; i < sortedForBoost.length; i++) { // Start from 1 (second driver)
                const currentDriverEntry = sortedForBoost[i];
                const driverAheadEntry = sortedForBoost[i - 1];

                if (currentDriverEntry.status === 'Racing' && driverAheadEntry.status === 'Racing' && currentDriverEntry.lapsCompleted === driverAheadEntry.lapsCompleted) {
                    if (Math.random() < CATCHUP_BOOST_CHANCE) {
                        const gapMs = currentDriverEntry.totalRaceTime - driverAheadEntry.totalRaceTime; // Should be positive if behind
                        if (gapMs > 0) { // Ensure they are actually behind
                            const gainMs = gapMs * CATCHUP_BOOST_FACTOR;
                            // Apply the gain, ensuring not to overtake *just* from the boost
                            // Find the entry in the original `raceLeaderboard` to update it
                            const originalEntry = raceLeaderboard.find(e => e.driver.id === currentDriverEntry.driver.id);
                            if(originalEntry) {
                                originalEntry.totalRaceTime = Math.max(driverAheadEntry.totalRaceTime + 1, originalEntry.totalRaceTime - gainMs);
                            }
                        }
                    }
                }
            }

            // 3. Attempt Overtakes based on the potentially modified gaps
            // Sort again before overtake checks based on the *potentially updated* totalRaceTime
             raceLeaderboard.sort((a, b) => { const statusOrder = { 'Racing': 1, 'Finished': 2, 'DNF': 3 }; if (statusOrder[a.status] !== statusOrder[b.status]) { return statusOrder[a.status] - statusOrder[b.status]; } if (a.lapsCompleted !== b.lapsCompleted) { return b.lapsCompleted - a.lapsCompleted; } return a.totalRaceTime - b.totalRaceTime; });

            for (let i = raceLeaderboard.length - 2; i >= 0; i--) {
                const attackerEntry = raceLeaderboard[i + 1];
                const defenderEntry = raceLeaderboard[i];
                if (attemptOvertake(attackerEntry, defenderEntry, track, currentLap)) {
                    // Swap positions in the main raceLeaderboard array
                    [raceLeaderboard[i], raceLeaderboard[i + 1]] = [raceLeaderboard[i + 1], raceLeaderboard[i]];
                }
            }
        }
        function endRaceSimulationPostProcessing() {
            const raceIdx = currentRaceIndex; // Capture index of the race that just finished (0-based)
            const currentRace = currentSeasonCalendar[raceIdx];
            const raceName = currentRace?.name || "Unknown Race";
            showMessage(`Race Finished: ${raceName}! Calculating results...`, 'success', 3000);
            raceLeaderboard.forEach(e => { if (e.status === 'Racing') e.status = 'Finished'; });
            const finalSortedBoard = [...raceLeaderboard];
            finalSortedBoard.sort((a, b) => { const statusOrder = { 'Finished': 1, 'DNF': 2 }; if (statusOrder[a.status] !== statusOrder[b.status]) return statusOrder[a.status] - statusOrder[b.status]; if (a.lapsCompleted !== b.lapsCompleted) return b.lapsCompleted - a.lapsCompleted; if (a.status === 'Finished' && b.status === 'Finished') return a.totalRaceTime - b.totalRaceTime; return 0; });
            let playerMoneyEarned = 0; // Define player money here
            finalSortedBoard.forEach((entry, finalPositionIndex) => {
                const driverId = entry.driver.id;
                const teamId = entry.driver.teamId;
                let pointsAwarded = 0;
                let moneyPoints = 0;
                let moneyPodium = 0;
                let moneyTop10 = 0;
                let moneyP11_P20 = 0;
                const position = finalPositionIndex + 1;
                if (entry.status === 'Finished') {
                    if (finalPositionIndex < PointsSystem.length) {
                        pointsAwarded = PointsSystem[finalPositionIndex];
                        driverSeasonScores[driverId] = (driverSeasonScores[driverId] || 0) + pointsAwarded;
                        moneyPoints = pointsAwarded * PRIZE_MONEY_PER_POINT;
                    }
                    if (position <= 3) { moneyPodium = PRIZE_MONEY_PODIUM_BONUS; }
                    if (position <= 10) { moneyTop10 = PRIZE_MONEY_TOP_10_BONUS; } else if (position <= 20) { moneyP11_P20 = PRIZE_MONEY_P11_P20_BONUS; }
                }
                if (!driverRaceHistory[driverId]) { driverRaceHistory[driverId] = Array(totalRacesInSeason).fill(null); }
                driverRaceHistory[driverId][raceIdx] = driverSeasonScores[driverId] || 0;
                const totalMoneyForDriver = moneyPoints + moneyPodium + moneyTop10 + moneyP11_P20; // Calculate per driver
                if (totalMoneyForDriver > 0) {
                    if (teamId === selectedEcurieId) {
                        playerMoneyEarned += totalMoneyForDriver; // Add to player's total
                    } else if (aiTeamBudgets.hasOwnProperty(teamId)) {
                        aiTeamBudgets[teamId] = (aiTeamBudgets[teamId] || 0) + totalMoneyForDriver; // Add to AI budget
                    }
                }
             });
            Object.keys(driverSeasonScores).forEach(driverIdStr => { const driverId = parseInt(driverIdStr); if (!driverRaceHistory[driverId]) { driverRaceHistory[driverId] = Array(totalRacesInSeason).fill(null); } for (let i = 0; i <= raceIdx; i++) { if (driverRaceHistory[driverId][i] === null || driverRaceHistory[driverId][i] === undefined) { driverRaceHistory[driverId][i] = (i > 0 ? (driverRaceHistory[driverId][i - 1] || 0) : 0); } } });
            budget += playerMoneyEarned; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`;
            if (playerMoneyEarned > 0) { addNotification(`Player earned $${formatNumber(playerMoneyEarned)} prize money this race.`, 'upgrade'); }
            runAIUpgradePhase(); generateAIUpgradeNotifications();

            // Record Car Performance History AFTER upgrades
            currentEcuries.forEach(team => {
                 const teamHistory = carPerformanceHistory[team.id];
                 if (!teamHistory) {
                     console.error(`Missing history init for team ${team.id}`);
                     carPerformanceHistory[team.id] = [calculateCarGlobalStat(getCarById(team.defaultCarId))]; // Attempt recovery
                     return; // Skip recording for this race if init failed
                 }
                 const car = getCarById(team.defaultCarId);
                 const currentRating = calculateCarGlobalStat(car);
                 // Store the rating *after* the completed race. Index `raceIdx + 1` corresponds to the state AFTER this race.
                 // Ensure array is long enough, pad with previous value if necessary
                 while (teamHistory.length <= raceIdx + 1) {
                     const lastRating = teamHistory.length > 0 ? teamHistory[teamHistory.length - 1] : null;
                     teamHistory.push(lastRating);
                 }
                 teamHistory[raceIdx + 1] = currentRating;
             });

            raceCompletedForCurrentIndex = true;
            // --- CORRECTED LINE ---
            renderFinalRaceResults(finalSortedBoard, raceName, playerMoneyEarned);
            // ---------------------
            renderAllTabs(); // Render all tabs AFTER results and history are processed
            updateRaceHQButtonState();
            document.getElementById('live-race-area').style.display = 'none';
            document.getElementById('live-race-placeholder').style.display = 'block';
            activateRaceSubTab('final');
        }
        function runAIUpgradePhase() { lastAIRaceUpgrades = {}; currentEcuries.forEach(team => { if (team.id === selectedEcurieId || !aiTeamBudgets.hasOwnProperty(team.id)) return; const teamId = team.id; const currentAIBudget = aiTeamBudgets[teamId]; const currentAIUpgrades = aiTeamUpgrades[teamId] || {}; const aiCar = getCarById(team.defaultCarId); if (!aiCar || currentAIBudget <= 0) return; const affordableUpgrades = UpgradesData.filter(u => !currentAIUpgrades[u.id] && u.cost <= currentAIBudget ).sort((a, b) => b.cost - a.cost); if (affordableUpgrades.length > 0) { const upgradeToBuy = affordableUpgrades[0]; const stat = upgradeToBuy.effect.stat; if (aiCar[stat] < MAX_STAT_VALUE_AI) { aiTeamBudgets[teamId] -= upgradeToBuy.cost; currentAIUpgrades[upgradeToBuy.id] = true; aiTeamUpgrades[teamId] = currentAIUpgrades; const currentValue = aiCar[stat]; const newValue = clamp(currentValue + upgradeToBuy.effect.value, 50, MAX_STAT_VALUE_AI); const actualChange = newValue - currentValue; if (actualChange > 0) { aiCar[stat] = newValue; lastAIRaceUpgrades[aiCar.id] = { stat: stat, change: actualChange }; } else { aiTeamBudgets[teamId] += upgradeToBuy.cost; delete currentAIUpgrades[upgradeToBuy.id]; aiTeamUpgrades[teamId] = currentAIUpgrades; } } } }); }
        function generateAIUpgradeNotifications() { Object.entries(lastAIRaceUpgrades).forEach(([carIdStr, upgradeInfo]) => { const carId = parseInt(carIdStr); const car = currentCars.find(c => c.id === carId); const team = currentEcuries.find(t => t.defaultCarId === car?.id); if (team && car && upgradeInfo.change > 0) { addNotification(`${team.name}'s ${car.name} improved ${upgradeInfo.stat} (+${upgradeInfo.change})`, 'upgrade'); } }); }
        function runAIInvestmentPhase() { // AI decides whether to invest the flat fee and on which stat
            aiTeamChosenInvestmentStats = {}; // Reset previous choices
            currentEcuries.forEach(team => {
                if (team.id === selectedEcurieId || !aiTeamBudgets.hasOwnProperty(team.id)) return;

                const teamId = team.id;
                const currentBudget = aiTeamBudgets[teamId] || 0;
                const aiCar = getCarById(team.defaultCarId);
                let chosenStat = null;

                if (!aiCar) return;

                // AI Logic: Invest if they can afford it, targeting their lowest stat.
                if (currentBudget >= INVESTMENT_COST) {
                    const stats = ['engine', 'aero', 'chassis', 'reliability'];
                    let sortedStats = stats.map(s => ({ name: s, value: aiCar[s] }))
                                          .sort((a,b) => a.value - b.value);
                    chosenStat = sortedStats[0].name; // Target the lowest stat

                    aiTeamBudgets[teamId] -= INVESTMENT_COST;
                    aiTeamChosenInvestmentStats[teamId] = chosenStat;
                    addNotification(`${team.name} focused R&D on ${chosenStat.toUpperCase()} for next season.`, 'investment');
                } else {
                    aiTeamChosenInvestmentStats[teamId] = null; // Cannot afford investment
                 }
            });
        }
        function assignAIDriversRanked() {
            // Reset AI team assignments and driver team IDs (except player's)
            currentEcuries.forEach(team => { if (team.id !== selectedEcurieId) { team.driverIds = []; } });
            currentDrivers.forEach(driver => { if (!selectedDriverIds.includes(driver.id)) { driver.teamId = null; } });

            const aiTeams = currentEcuries.filter(t => t.id !== selectedEcurieId);
            // Sort teams by car performance
            const rankedTeams = aiTeams.map(team => {
                const car = getCarById(team.defaultCarId);
                const score = calculateCarGlobalStat(car);
                return { team, score };
            }).sort((a, b) => b.score - a.score); // Best car first

            // Get drivers available for AI teams (not player's selected drivers)
            let availableDrivers = currentDrivers.filter(d => !selectedDriverIds.includes(d.id))
                                              .sort((a, b) => b.skill - a.skill); // Best skill first

            // Assign best available drivers to best available teams
            rankedTeams.forEach(({ team }) => {
                if (availableDrivers.length >= 2) {
                    // Assign top two available drivers to this team
                    const driver1 = availableDrivers.shift();
                    const driver2 = availableDrivers.shift();
                    driver1.teamId = team.id;
                    driver2.teamId = team.id;
                    team.driverIds.push(driver1.id, driver2.id);
                } else if (availableDrivers.length === 1) {
                    // Assign the last driver if only one left
                    const driver1 = availableDrivers.shift();
                    driver1.teamId = team.id;
                    team.driverIds.push(driver1.id);
                    console.warn(`AI Driver Assignment Warning: Only one driver left for team ${team.name}.`);
                } else {
                    console.error(`AI Driver Assignment Error: Not enough drivers for team ${team.name}.`);
                    // Assign placeholders or handle error as needed
                }
            });

            // Ensure all drivers have a team ID (or are free agents if none left, which shouldn't happen with 10 teams/20+ drivers)
             currentDrivers.forEach(d => {
                 if(d.teamId === null && !selectedDriverIds.includes(d.id)) {
                     console.log(`${d.name} is a Free Agent.`); // Drivers not picked by player or AI
                 }
             });

             // Final check
             currentEcuries.forEach(team => {
                 if (team.driverIds.length !== 2) {
                     console.error(`ASSIGNMENT CHECK ERROR: Team ${team.name} has ${team.driverIds.length} drivers! IDs: ${team.driverIds.join(', ')}`);
                 }
             });
         }
        function generateDriverChangeNotifications(oldPlayerDrivers) { const droppedDrivers = oldPlayerDrivers.filter(id => !selectedDriverIds.includes(id)); const newDrivers = selectedDriverIds.filter(id => !oldPlayerDrivers.includes(id)); if (droppedDrivers.length === 0 && newDrivers.length === 0) { addNotification(`You kept the same driver lineup for ${currentSeasonYear}.`, 'transfer'); } else { droppedDrivers.forEach(id => { const driver = getDriverById(id); if(driver) addNotification(`You released ${driver.name}.`, 'transfer'); }); newDrivers.forEach(id => { const driver = getDriverById(id); if(driver) addNotification(`You signed ${driver.name} for ${currentSeasonYear}!`, 'transfer'); }); } addNotification(`--- AI Team Driver Updates for ${currentSeasonYear} ---`, 'info'); currentEcuries.forEach(team => { if (team.id !== selectedEcurieId) { const driverNames = team.driverIds.map(id => getDriverById(id)?.name || 'Unknown').join(' & '); addNotification(`${team.name}: ${driverNames}`, 'transfer'); } }); }

        // --- Game Flow Control ---

        function handleRunQualifyingSequence() { const currentRace = currentSeasonCalendar[currentRaceIndex]; if (!currentRace) { showMessage("Error: Race data not found.", "error"); return; } if (raceCompletedForCurrentIndex) { showMessage("Qualifying for this race already completed.", "info"); return; } showMessage(`Running Qualifying for ${currentRace.name}...`, 'info', 3000); document.getElementById('run-qualifying-button').disabled = true; clearQualifyingUI(); const participants = currentDrivers.filter(d => d.teamId !== null).map(drv => ({ driver: drv, car: getCarById(getTeamById(drv.teamId)?.defaultCarId) })).filter(p => p.car); if (participants.length < 2) { showMessage("Not enough participants with assigned cars.", "error"); document.getElementById('run-qualifying-button').disabled = false; return; } document.getElementById('qualifying-title').textContent = `Qualifying: ${currentRace.name}`; activateRaceSubTab('qualifying'); setTimeout(() => { const q1Advanced = runQualifyingStage(participants, 15, 'q1'); showMessage('Q1 Complete. Running Q2...', 'info', 1500); setTimeout(() => { const q2Advanced = runQualifyingStage(q1Advanced, 10, 'q2'); showMessage('Q2 Complete. Running Q3...', 'info', 1500); setTimeout(() => { runQualifyingStage(q2Advanced, 10, 'q3'); showMessage('Qualifying Complete! Starting Grid determined.', 'success', 2000); determineStartingGrid(); renderStartingGrid(); raceCompletedForCurrentIndex = false; updateRaceHQButtonState(); }, 1000); }, 1000); }, 500); }
        function startRaceSimulation() { if (startingGrid.length === 0) { showMessage("Run qualifying first.", "error"); return; } if (raceIntervalId) { showMessage("Race already in progress.", "info"); return; } const currentRace = currentSeasonCalendar[currentRaceIndex]; if (!currentRace) { showMessage("Error: Current race data not found.", "error"); return; } maxDnfThisRace = Math.floor(startingGrid.length * MAX_DNF_PER_RACE_PERCENT * (0.8 + Math.random() * 0.4)); showMessage(`Starting Race: ${currentRace.name}! (${currentRace.laps} Laps)`, 'info', 3000); document.getElementById('start-race-button').disabled = true; document.getElementById('accelerate-race-button').disabled = true; document.getElementById('live-race-area').style.display = 'block'; document.getElementById('live-race-placeholder').style.display = 'none'; document.getElementById('race-results').style.display = 'none'; document.getElementById('final-results-placeholder').style.display = 'block'; currentLap = 0; dnfCountThisRace = 0; raceLeaderboard = startingGrid.map(p => ({ driver: p.driver, car: p.car, status: 'Racing', totalRaceTime: 0, lastLapTime: 0, lapsCompleted: 0 })); renderLiveLeaderboard(); activateRaceSubTab('live'); raceIntervalId = setInterval(() => { const racingCars = raceLeaderboard.filter(p => p.status === 'Racing'); if (currentLap >= currentRace.laps || racingCars.length === 0) { endRaceSimulation(); return; } runRaceLap(); renderLiveLeaderboard(); }, RACE_UPDATE_INTERVAL_MS); }
        function handleAccelerateRace() { if (startingGrid.length === 0) { showMessage("Run qualifying first.", "error"); return; } if (raceIntervalId) { showMessage("Cannot accelerate while live race is running.", "info"); return; } const currentRace = currentSeasonCalendar[currentRaceIndex]; if (!currentRace) { showMessage("Error: Current race data not found.", "error"); return; } if (raceCompletedForCurrentIndex) { showMessage("Race already completed.", "info"); activateRaceSubTab('final'); return; } showMessage(`Accelerating Race: ${currentRace.name}... (This may take a moment)`, 'info', 2500); document.getElementById('start-race-button').disabled = true; document.getElementById('accelerate-race-button').disabled = true; document.getElementById('live-race-area').style.display = 'none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display = 'none'; document.getElementById('final-results-placeholder').style.display = 'block'; activateRaceSubTab('final'); setTimeout(() => { maxDnfThisRace = Math.floor(startingGrid.length * MAX_DNF_PER_RACE_PERCENT * (0.8 + Math.random() * 0.4)); dnfCountThisRace = 0; currentLap = 0; raceLeaderboard = startingGrid.map(p => ({ driver: p.driver, car: p.car, status: 'Racing', totalRaceTime: 0, lastLapTime: 0, lapsCompleted: 0 })); for (let lap = 1; lap <= currentRace.laps; lap++) { const racingCars = raceLeaderboard.filter(p => p.status === 'Racing'); if (racingCars.length === 0) { break; } runRaceLap(); } currentLap = raceLeaderboard.reduce((max, p) => Math.max(max, p.lapsCompleted), 0); endRaceSimulationPostProcessing(); }, 100); }
        function endRaceSimulation() { if (raceIntervalId) { clearInterval(raceIntervalId); raceIntervalId = null; } endRaceSimulationPostProcessing(); updateRaceHQButtonState(); }
        function handleNextRaceWeekend() { if (currentRaceIndex >= totalRacesInSeason - 1) { gameState = 'SEASON_END'; showMessage(`Final race complete! Season ${currentSeasonYear} concluded. Proceed to Next Season.`, 'success'); updateRaceHQButtonState(); return; } currentRaceIndex++; const nextRace = currentSeasonCalendar[currentRaceIndex]; showMessage(`Advancing to next race weekend: ${nextRace.name}`, 'info'); startingGrid = []; qualifyingResults = { q1: [], q2: [], q3: [] }; raceLeaderboard = []; if(raceIntervalId) clearInterval(raceIntervalId); raceIntervalId = null; dnfCountThisRace = 0; maxDnfThisRace = 0; raceCompletedForCurrentIndex = false; clearQualifyingUI(); document.getElementById('live-race-area').style.display = 'none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display = 'none'; document.getElementById('final-results-placeholder').style.display = 'block'; updateRaceHQButtonState(); renderCalendar(); activateRaceSubTab('qualifying'); renderOpponentCars(document.getElementById('opponent-cars-list')); }
        function handleStartNextSeason() {
            if (raceIntervalId) clearInterval(raceIntervalId); raceIntervalId = null;
            gameState = 'SEASON_END';

            // 1. Calculate final constructor standings & Store Ranks
            let constructorScores = {};
            currentEcuries.forEach(team => constructorScores[team.id] = 0);
            // Include ALL drivers (even prospects if they somehow scored) when calculating team points
            Object.entries(driverSeasonScores).forEach(([driverId, points]) => {
                const driver = getDriverById(driverId);
                if (driver && driver.teamId && constructorScores.hasOwnProperty(driver.teamId)) {
                    constructorScores[driver.teamId] += (points || 0); // Ensure points is a number
                }
            });
            const sortedTeams = Object.entries(constructorScores)
                .map(([teamId, points]) => ({ teamId: parseInt(teamId), points }))
                .sort((a, b) => b.points - a.points);

            // Store previous season's rank for R&D potential calculation
            teamPreviousSeasonRank = {};
            sortedTeams.forEach((teamData, index) => {
                 teamPreviousSeasonRank[teamData.teamId] = index + 1; // Store 1st, 2nd, 3rd etc.
             });

            // 2. Save driver standings history
            const finalDriverStandings = Object.entries(driverSeasonScores).map(([driverId, points]) => { const driver = getDriverById(driverId); const team = driver ? getTeamById(driver.teamId) : null; return { driverId: parseInt(driverId), driverName: driver ? driver.name : 'Unknown Driver', teamId: team ? team.id : null, teamName: team ? team.name : 'Free Agent', points: points || 0 }; }).sort((a, b) => b.points - a.points || a.driverName.localeCompare(b.driverName)); // Changed Unknown Team to Free Agent default
            seasonHistory[currentSeasonYear] = finalDriverStandings;

            // 3. Award end-of-season bonuses (Driver points + Constructor Rank)
            let playerPointsThisSeason = selectedDriverIds.reduce((sum, id) => sum + (driverSeasonScores[id] || 0), 0);
            const playerBonus = playerPointsThisSeason * PLAYER_BONUS_PER_POINT;
            let constructorBonus = 0;
            const playerTeamRank = teamPreviousSeasonRank[selectedEcurieId] || (CONSTRUCTOR_BONUSES.length + 1); // Find player rank
            if (playerTeamRank <= CONSTRUCTOR_BONUSES.length) {
                 constructorBonus = CONSTRUCTOR_BONUSES[playerTeamRank - 1]; // Use rank (1-based) to get bonus
            }
            const totalPlayerBonus = playerBonus + constructorBonus;
            budget += totalPlayerBonus;
            addNotification(`End of Season ${currentSeasonYear}. Driver Pts Bonus: $${formatNumber(playerBonus)}. Constructor Bonus (P${playerTeamRank}): $${formatNumber(constructorBonus)}. New Budget: $${formatNumber(budget)}`, 'upgrade');

            // Award AI bonuses (Points + Constructor)
            sortedTeams.forEach((teamData, index) => {
                 if (teamData.teamId !== selectedEcurieId) {
                     const team = getTeamById(teamData.teamId);
                     const rank = teamPreviousSeasonRank[teamData.teamId];
                     if (team && rank) {
                         let teamPoints = team.driverIds.reduce((sum, driverId) => sum + (driverSeasonScores[driverId] || 0), 0);
                         const aiPointsBonus = teamPoints * AI_BONUS_PER_POINT;
                         const aiConstructorBonus = (rank <= CONSTRUCTOR_BONUSES.length) ? CONSTRUCTOR_BONUSES[rank - 1] : 0;
                         const currentAIBudget = aiTeamBudgets[teamData.teamId] || 0;
                         aiTeamBudgets[teamData.teamId] = currentAIBudget + aiPointsBonus + aiConstructorBonus;
                     }
                 }
             });

             // 4. AI makes R&D Stat Focus Investment Choice (if affordable)
             // runAIInvestmentPhase(); // REMOVED - No investment phase anymore

            // 5. Randomize Stats (Car first, using rank potential, then Driver cost/stats)
            randomizeCarStats();
            randomizeDriverStats(); // This now also handles cost adjustments

            // 6. Transition to Driver Market
            gameState = 'DRIVER_MARKET'; currentSeasonYear++;
            document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; // Update display after bonuses
            showMessage(`End of Season ${currentSeasonYear - 1}. Bonuses awarded, performance potential applied, stats & costs randomized. Entering Driver Market for ${currentSeasonYear}...`, 'info', 5000);
            document.getElementById('team-management-screen').style.display = 'none';
            document.getElementById('driver-market-screen').style.display = 'block';
            marketSelectedDriverIds = [...selectedDriverIds]; // Pre-select current drivers
            renderDriverMarket();
            updateRaceHQButtonState();
            addNotification(`Entering Driver Market for ${currentSeasonYear} season. Select your team!`, 'transfer');
        }


        // --- Helper Functions ---

        function showMessage(message, type = 'info', duration = 3000) { const mb = document.getElementById('message-box'); if (!mb) return; if (mb.timeoutId) clearTimeout(mb.timeoutId); mb.textContent = message; mb.className = `message-box ${type} show`; mb.timeoutId = setTimeout(() => { mb.classList.remove('show'); mb.timeoutId = null; }, duration); }
        function formatNumber(n) { return n.toLocaleString('en-US'); }
        function formatTimeMs(ms) { // Formats milliseconds to M:SS.mmm
            if (ms === Infinity || typeof ms !== 'number' || isNaN(ms)) {
                return "N/A"; // Handle DNF or invalid times
            }
            const totalSeconds = ms / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const milliseconds = Math.floor(ms % 1000);
            return `${minutes}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }
        function getTeamById(id) { return currentEcuries.find(t => t.id === id); }
        function getDriverById(id) { const drvId = typeof id === 'string' ? parseInt(id) : id; return currentDrivers.find(d => d.id === drvId); }
        function getCarById(id) { return currentCars.find(c => c.id === id); }
        function getBaseCarDataById(id) { const baseCar = CarsData.find(c => c.id === id); return baseCar ? JSON.parse(JSON.stringify(baseCar)) : null; }
        function shuffleArray(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } }
        function getOrdinalSuffix(n) { const s = ["th", "st", "nd", "rd"], v = n % 100; return n + (s[(v - 20) % 10] || s[v] || s[0]); }
        function generateSeasonCalendar() { currentSeasonCalendar = JSON.parse(JSON.stringify(RacesData)); shuffleArray(currentSeasonCalendar); totalRacesInSeason = currentSeasonCalendar.length; }
        function clamp(value, min, max) { return Math.max(min, Math.min(value, max)); }
        function randomizeBetween(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function addNotification(message, type = 'info') { const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); let notificationTypeClass = ''; if (type === 'upgrade') notificationTypeClass = 'event-type-upgrade'; else if (type === 'transfer') notificationTypeClass = 'event-type-transfer'; else if (type === 'stats') notificationTypeClass = 'event-type-stats'; else if (type === 'error') notificationTypeClass = 'event-type-error'; else if (type === 'investment') notificationTypeClass = 'event-type-investment'; notificationsLog.unshift({ message, type, timestamp, typeClass: notificationTypeClass }); if (notificationsLog.length > MAX_NOTIFICATIONS) { notificationsLog.pop(); } const notificationsTab = document.getElementById('notifications-tab'); if (notificationsTab && notificationsTab.style.display === 'block') { renderNotifications(); } }
        function getTrackType(r) { if (r.speedFocus >= 95 && r.handlingFocus <= 80) return "High Speed"; if (r.handlingFocus >= 95 && r.speedFocus <= 80) return "High Handling"; if (r.speedFocus >= 90 && r.handlingFocus >= 90) return "Balanced Fast"; if (r.speedFocus <= 75 && r.handlingFocus <= 75) return "Balanced Slow"; if (r.speedFocus > r.handlingFocus + 10) return "Speed Focused"; if (r.handlingFocus > r.speedFocus + 10) return "Handling Focused"; return "Mixed"; }
        function generateChartColors(index) { const colors = [ '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#E7E9ED', '#83AFA7', '#EF5350', '#AB47BC', '#42A5F5', '#66BB6A', '#FFA726', '#78909C', '#EC407A', '#5C6BC0', '#26A69A', '#FFCA28', '#8D6E63', '#BDBDBD' ]; return colors[index % colors.length]; }

        // --- Start Game ---
        window.onload = initGame;

    </script>

</body>
</html>