<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Team Manager</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Basic styling for the body */
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Styling for the main application container */
        #app {
            width: 95%;
            max-width: 1200px;
            padding: 25px;
            border-radius: 12px;
            background-color: rgba(20, 20, 20, 0.85);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.6);
            margin-top: 80px;
            margin-bottom: 30px;
            box-sizing: border-box;
            position: relative;
             border: 1px solid #333;
        }

        /* Styling for the main title */
        h1 {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            margin-bottom: 1.5rem;
            color: #ff8700;
            text-shadow: 0 0 6px rgba(255, 135, 0, 0.7);
            font-size: 2rem;
        }

        /* Styling for section titles */
        h2 {
            margin-top: 2.5rem;
            margin-bottom: 1.2rem;
            color: #ff8700;
            font-size: 1.5rem;
            border-bottom: 2px solid #ff8700;
            padding-bottom: 0.6rem;
            font-weight: 700;
            text-shadow: none;
        }
        h3 {
             margin-top: 1rem;
            margin-bottom: 0.8rem;
            color: #ff9a21;
            font-size: 1.25rem;
             font-weight: 700;
             text-shadow: none;
        }
        h4{
             margin-top: 0;
            margin-bottom: 0.6rem;
            color: #cccccc;
            font-size: 1.05rem;
             font-weight: 700;
             border-bottom: 1px dotted #555;
             padding-bottom: 0.4rem;
        }

        /* Styling for the fixed budget display */
        #budget-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(10, 10, 10, 0.9);
            color: #fff;
            padding: 0.8rem 1.6rem;
            border-radius: 6px;
            z-index: 100;
            font-size: 1.15rem;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            border: 1px solid #ff8700;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
        }

        /* Styling for the Race HQ & Driver Market Buttons */
        #run-qualifying-button, #start-race-button, #accelerate-race-button, #next-gp-button, #next-season-button, #confirm-drivers-button, #clear-notifications-button {
            padding: 0.8rem 1.6rem;
            border-radius: 6px;
            background-color: #e57300;
            color: #ffffff;
            border: none;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            transition: background-color 0.2s ease, opacity 0.2s ease, transform 0.1s ease;
            margin: 0 0.5rem 1rem 0.5rem;
            max-width: 280px;
            display: inline-block;
            vertical-align: middle;
            border-bottom: 2px solid #a05200;
        }
         #race-controls, #driver-market-controls {
             text-align: center;
             margin-bottom: 2rem;
         }

         #run-qualifying-button:hover:not(:disabled),
         #start-race-button:hover:not(:disabled),
         #accelerate-race-button:hover:not(:disabled),
         #next-gp-button:hover:not(:disabled),
         #next-season-button:hover:not(:disabled),
         #confirm-drivers-button:hover:not(:disabled),
         #clear-notifications-button:hover:not(:disabled) {
            background-color: #ff8700;
            transform: translateY(-1px);
        }
         #run-qualifying-button:active:not(:disabled),
         #start-race-button:active:not(:disabled),
         #accelerate-race-button:active:not(:disabled),
         #next-gp-button:active:not(:disabled),
         #next-season-button:active:not(:disabled),
         #confirm-drivers-button:active:not(:disabled),
         #clear-notifications-button:active:not(:disabled) {
             transform: translateY(1px);
             border-bottom-width: 1px;
         }

         #run-qualifying-button:disabled,
         #start-race-button:disabled,
         #accelerate-race-button:disabled,
         #next-gp-button:disabled,
         #next-season-button:disabled,
         #confirm-drivers-button:disabled,
         #clear-notifications-button:disabled {
            background-color: #777;
            cursor: not-allowed;
            opacity: 0.6;
             border-bottom-color: #555;
        }
         #start-race-button { background-color: #0d47a1; border-bottom-color: #05306e; display: none; }
         #start-race-button:hover:not(:disabled) { background-color: #1565c0; }
         #accelerate-race-button { background-color: #FFB300; color: #111; border-bottom-color: #cc8f00; display: none; }
         #accelerate-race-button:hover:not(:disabled) { background-color: #FFCA28; }
         #next-gp-button { background-color: #6a1b9a; border-bottom-color: #4a148c; display: none; }
         #next-gp-button:hover:not(:disabled) { background-color: #8e24aa; }
         #next-season-button { background-color: #2e7d32; border-bottom-color: #1b5e20; display: none; }
         #next-season-button:hover:not(:disabled) { background-color: #388e3c; }
         #confirm-drivers-button { background-color: #2e7d32; border-bottom-color: #1b5e20; }
         #confirm-drivers-button:hover:not(:disabled) { background-color: #388e3c; }
         #clear-notifications-button { background-color: #c62828; border-bottom-color: #8e0000; max-width: 200px; display: block; margin-left: auto; margin-right: auto;}
         #clear-notifications-button:hover:not(:disabled) { background-color: #d32f2f; }


        /* Styling for the grid containers */
        #initial-budget-selection, #ecurie-selection, #drivers-list, #cars-list,
        #car-upgrade-options, #opponent-cars-list, #drivers-list-management,
        #driver-market-list, #next-season-investment-options /* Updated */ {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2.5rem;
        }
        #season-standings-list, #calendar-list {
            grid-template-columns: 1fr;
            display: grid;
            gap: 0.6rem;
        }

        /* Styling for individual cards */
        .card {
            background-color: #2c2c2c;
            padding: 1.8rem;
            border-radius: 10px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            border: 1px solid #404040;
        }
        .card:not(.disabled):hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(255, 135, 0, 0.2);
            border-color: #ff8700;
        }
        .card h3 {
            margin-top: 0; margin-bottom: 1.2rem; color: #fff; font-size: 1.15rem;
            border-bottom: 1px solid #666; padding-bottom: 0.6rem; font-weight: 700;
        }
        .card ul { list-style: none; padding: 0; margin-bottom: 1.2rem; flex-grow: 1; }
        .card li { margin-bottom: 0.6rem; color: #d0d0d0; font-size: 0.95rem; }
         /* Driver Market Card Styles */
         .card.market-selected { border: 2px solid #4CAF50; box-shadow: 0 0 10px rgba(76, 175, 80, 0.5); }
         .card.market-current-player { border: 2px solid #00BCD4; }
         .card.disabled:not(.market-selected):not(.market-current-player) { opacity: 0.6; cursor: not-allowed; border-color: #555; } /* Ensure non-selected/current disabled cards are styled */
         /* Investment Card Style (Now Stat Focus) */
         .card.investment-selected { border: 2px solid #673AB7; box-shadow: 0 0 10px rgba(103, 58, 183, 0.5); }
         .card.investment-option { background-color: #353535; } /* Slightly different background */

        .card li.selected-driver { color: #ff8700; font-weight: bold; } /* Highlight driver name in management list */
        /* Player team card highlight in driver management tab */
        #drivers-list-management .card.player-team { border: 2px solid #ffae42; background-color: rgba(255, 174, 66, 0.05); }

        .stat-increase { color: #81c784; font-size: 0.8em; margin-left: 5px; font-weight: bold; }
        /* Stat change indicators in Driver Market */
        .stat-change { font-size: 0.8em; margin-left: 5px; font-weight: bold;}
        .stat-change.positive { color: #81c784; }
        .stat-change.negative { color: #ef5350; }
        .card button {
             padding: 0.8rem 1.6rem; border-radius: 6px; background-color: #ff8700; color: #ffffff; border: none; cursor: pointer; font-size: 0.9rem; transition: background-color 0.2s ease, transform 0.1s ease; width: 100%; box-sizing: border-box; margin-top: auto; font-family: 'Roboto', sans-serif; font-weight: 700; border-bottom: 2px solid #a05200;
         }
        .card button:hover:not(:disabled) { background-color: #ffa033; transform: translateY(-1px); }
        .card button:active:not(:disabled) { transform: translateY(1px); border-bottom-width: 1px; }
        .card button:disabled { background-color: #777; cursor: not-allowed; color: #bbb; border-bottom-color: #555;}
         /* Investment (Stat Focus) button style override */
         .card.investment-option button { background-color: #673AB7; border-bottom-color: #4527A0; }
         .card.investment-option button:hover:not(:disabled) { background-color: #7E57C2; }
         .card.investment-option button:disabled { background-color: #777; } /* Keep disabled style consistent */


        /* Race HQ Specific Styles */
         #qualifying-results-area { background-color: #252525; padding: 1.2rem; border-radius: 8px; border: 1px solid #444; margin-bottom: 2rem; }
         #qualifying-results-area h3 { margin-top: 0; color: #ff9a21; }
         #qualifying-results-area h4 { color: #ccc; font-size: 1rem; margin-bottom: 0.5rem; border-bottom: 1px dotted #666; padding-bottom: 0.4rem; font-weight: 700;}
         #qualifying-results-area ol { list-style: none; padding: 0; margin: 0; font-size: 0.9rem; }
         #qualifying-results-area ol li { padding: 0.4rem 0.2rem; border-bottom: 1px dotted #555; }
         #qualifying-results-area ol li:last-child { border-bottom: none; }
         #qualifying-results-area ol li.player-driver { color: #ffae42; font-weight: bold; background-color: rgba(255, 135, 0, 0.05); border-radius: 3px; padding-left: 5px; }
         #qualifying-results-area .time-display { font-family: monospace; color: #eee; } /* Style for time */

         #live-race-area { border: 1px dashed #ff8700; padding: 1.5rem; background-color: rgba(10,10,10,0.3); border-radius: 8px; margin-bottom: 2rem; }
         #live-race-area h3 { margin-top: 0; color: #ff9a21; }
         #live-lap-counter { font-size: 1.2rem; text-align: center; margin-bottom: 1.2rem; color: #eee; font-weight: 700; }
         #live-leaderboard h4 { color: #ccc; font-size: 1rem; margin-bottom: 0.5rem; font-weight: 700; }
         #live-leaderboard ol { list-style: none; padding: 0; margin: 0; font-size: 0.95rem; }
         #live-leaderboard ol li { padding: 0.45rem 0.3rem; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s ease; } /* Added align-items */
         #live-leaderboard ol li:last-child { border-bottom: none; }
         #live-leaderboard ol li:nth-child(odd) { background-color: rgba(255, 255, 255, 0.02); }
         #live-leaderboard ol li.player-driver { color: #ffae42; font-weight: bold; background-color: rgba(255, 135, 0, 0.1); border-left: 3px solid #ff8700; padding-left: 8px;}
         #live-leaderboard ol li .status-dnf { color: #ef5350; font-weight: bold; margin-left: 8px; }
         /* Style for Gap Display */
         #live-leaderboard ol li .gap-display {
             font-size: 0.85em;
             color: #aaa;
             min-width: 80px; /* Adjust as needed */
             text-align: right;
             font-family: monospace; /* Good for aligning numbers */
             margin-left: 10px; /* Space between name and gap */
         }
         #live-leaderboard ol li.player-driver .gap-display {
             color: #ffae42; /* Make player gap stand out */
         }
         /* End Gap Display Style */
        #race-results { margin-top: 0; padding: 1.8rem; border-radius: 10px; background-color: #252525; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); border: 1px solid #444; }
        #race-results h3 { margin-top: 0; margin-bottom: 1.2rem; color: #ff9a21; font-size: 1.3rem; }
        #race-results ol { padding-left: 0; margin-bottom: 1.2rem; list-style: none; counter-reset: race-position; }
        #race-results ol li { margin-bottom: 0.6rem; color: #d0d0d0; font-size: 1rem; display: flex; align-items: center; padding: 0.5rem 0; border-bottom: 1px dotted #555; }
        #race-results ol li:last-child { border-bottom: none; }
        #race-results ol li::before { content: counter(race-position) ". "; counter-increment: race-position; font-weight: bold; color: #ff8700; margin-right: 1rem; min-width: 2.2em; text-align: right; }
        #race-results ol li.player-driver { background-color: rgba(255, 135, 0, 0.1); padding-left: 0.8rem; border-radius: 4px; font-weight: bold; color: #ffae42;}
        #race-results ol li .status-dnf { color: #ef5350; font-weight: bold; margin-left: 8px; }
        #race-results p#race-message { font-size: 0.95rem; color: #bbb; margin-top: 1.2rem; margin-bottom: 1.8rem; }
        #prize-money-earned { margin-top: 1.8rem; padding-top: 1.2rem; border-top: 1px solid #555; }
        #prize-money-earned h4 { color: #ff9a21; margin-bottom: 1rem; font-size: 1.1rem; }
        #prize-money-earned ul { list-style: none; padding: 0; margin: 0 0 0.8rem 0; }
        #prize-money-earned li { margin-bottom: 0.4rem; font-size: 0.95rem; color: #d0d0d0; }
        #prize-money-earned p { font-weight: bold; color: #fff; margin-top: 1rem; font-size: 1.05rem; }
        #visual-simulation-placeholder { display: none; } /* Keep hidden for now */

        /* General Styles */
        .disabled{ opacity: 0.6; cursor: not-allowed; border-color: #555; }
        .message-box { position: fixed; top: 80px; left: 50%; transform: translateX(-50%) translateY(-20px); background-color: rgba(10, 10, 10, 0.95); color: #fff; padding: 1rem 2rem; border-radius: 6px; z-index: 101; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; opacity: 0; pointer-events: none; box-shadow: 0 3px 7px rgba(0,0,0,0.6); border: 1px solid #ff8700; text-align: center; font-size: 0.95rem; font-family: 'Roboto', sans-serif; }
        .message-box.show { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: all; }
        .message-box.error { background-color: rgba(198, 40, 40, 0.95); border-color: #ef5350; }
        .message-box.success { background-color: rgba(46, 125, 50, 0.95); border-color: #66bb6a; }
        .message-box.info { background-color: rgba(13, 71, 161, 0.95); border-color: #42a5f5; }

        /* --- Main Tab Styles --- */
        .tabs { display: flex; margin-bottom: 2rem; border-bottom: 2px solid #ff8700; flex-wrap: wrap; }
        .tab-button { padding: 0.8rem 1.6rem; border: none; background-color: transparent; color: #ccc; cursor: pointer; font-family: 'Roboto', sans-serif; font-weight: 700; font-size: 1rem; transition: color 0.2s ease, border-bottom 0.2s ease, background-color 0.2s ease; border-bottom: 3px solid transparent; margin-bottom: -2px; text-align: center; flex-grow: 1; }
        .tab-button.active { color: #ff8700; border-bottom-color: #ff8700; background-color: rgba(255, 135, 0, 0.08); }
        .tab-button:hover:not(.active) { color: #fff; background-color: rgba(255, 255, 255, 0.05); }
        .tab-content { display: none; padding-top: 1.5rem; border-top: 1px solid #444; margin-top: -1px; }
        .tab-content.active { display: block; } /* Added for potential future use */

        /* --- Sub-Tab Styles --- */
        .sub-tabs { display: flex; margin-bottom: 1.5rem; border-bottom: 1px solid #555; flex-wrap: wrap; }
        .sub-tab-button { padding: 0.6rem 1.2rem; border: none; background-color: transparent; color: #aaa; cursor: pointer; font-family: 'Roboto', sans-serif; font-size: 0.9rem; font-weight: 700; transition: color 0.2s ease, border-bottom 0.2s ease, background-color 0.2s ease; border-bottom: 2px solid transparent; margin-right: 10px; margin-bottom: -1px; }
        .sub-tab-button.active { color: #ffae42; border-bottom-color: #ffae42; background-color: rgba(255, 174, 66, 0.05); }
        .sub-tab-button:hover:not(.active) { color: #ddd; background-color: rgba(255, 255, 255, 0.04); }
        .sub-tab-content { display: none; padding-top: 1rem; }
        .sub-tab-content.active { display: block; }

        /* --- Chart Styles --- */
        .chart-container { margin-bottom: 1.5rem; padding: 1rem; background-color: #2a2a2a; border-radius: 8px; border: 1px solid #444; }
        .chart-title { color: #ff9a21; font-size: 1.1rem; margin-bottom: 1rem; font-weight: 700; }
        /* Bar Chart (kept simple for global stat maybe) */
        .bar-chart-item { display: flex; align-items: center; margin-bottom: 0.75rem; font-size: 0.9rem; }
        .bar-label { min-width: 100px; text-align: right; margin-right: 10px; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .bar-chart-item.player-team .bar-label { color: #ffae42; font-weight: bold; } /* Used in Development Tab Car Stats */
        .bar-container { flex-grow: 1; background-color: #444; height: 20px; border-radius: 4px; overflow: hidden; position: relative; }
        .bar { height: 100%; background-color: #ff8700; border-radius: 4px 0 0 4px; transition: width 0.5s ease-in-out; white-space: nowrap; overflow: hidden; }
        /* Specific colors for bars if used for individual stats */
        .bar.engine { background-color: #d32f2f; }
        .bar.aero { background-color: #1976d2; }
        .bar.chassis { background-color: #ffb300; } /* Yellow for chassis */
        .bar.reliability { background-color: #388e3c; }
        .bar.global { background-color: #757575; } /* Grey for global */

        .bar-value { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); font-size: 0.8rem; color: #fff; font-weight: bold; text-shadow: 1px 1px 1px rgba(0,0,0,0.7); }
        .bar .bar-value-inside { padding-left: 5px; color: #fff; font-size: 0.8rem; line-height: 20px; font-weight: bold; }
        #standings-chart-container canvas { max-height: 400px; }
        #standings-chart-placeholder { text-align: center; color: #aaa; margin-top: 1rem; display: none; } /* Hide by default */
        /* NEW Car Dev Chart Styles */
        #car-dev-chart-container canvas { max-height: 350px; }
        #car-dev-chart-placeholder { text-align: center; color: #aaa; margin-top: 1rem; display: block; } /* Show initially */


        /* --- Notification Styles --- */
        #notifications-list {list-style: none; padding: 0; max-height: 400px; overflow-y: auto; background-color: #252525; border: 1px solid #444; border-radius: 6px; padding: 1rem;}
        #notifications-list li { padding: 0.6rem 0.8rem; border-bottom: 1px dotted #555; font-size: 0.9rem; color: #ccc; margin-bottom: 2px; } /* Added margin-bottom */
        #notifications-list li:last-child { border-bottom: none; }
        #notifications-list li .timestamp { font-size: 0.75rem; color: #888; margin-right: 10px; display: inline-block; }
        #notifications-list li .event-type { font-weight: bold; margin-right: 5px; }
        /* Colors defined via class on li */
        #notifications-list li.event-type-upgrade .event-type { color: #81c784; } /* Green for upgrades/money */
        #notifications-list li.event-type-transfer .event-type { color: #42a5f5; } /* Blue for transfers */
        #notifications-list li.event-type-stats .event-type { color: #ffb74d; }    /* Orange for stat changes */
        #notifications-list li.event-type-error .event-type { color: #ef5350; }   /* Red for DNF/Mistakes */
        #notifications-list li.event-type-investment .event-type { color: #AB47BC; } /* Purple for investment */
        #notifications-list li.placeholder { color: #888; font-style: italic; text-align: center; border: none; background-color: transparent; } /* Ensure placeholder has no border/bg */
        /* Apply color to the whole notification li based on type */
        #notifications-list li.event-type-upgrade { border-left: 3px solid #81c784; background-color: rgba(129, 199, 132, 0.05); }
        #notifications-list li.event-type-transfer { border-left: 3px solid #42a5f5; background-color: rgba(66, 165, 245, 0.05); }
        #notifications-list li.event-type-stats { border-left: 3px solid #ffb74d; background-color: rgba(255, 183, 77, 0.05); }
        #notifications-list li.event-type-error { border-left: 3px solid #ef5350; background-color: rgba(239, 83, 80, 0.05); }
        #notifications-list li.event-type-investment { border-left: 3px solid #AB47BC; background-color: rgba(171, 71, 188, 0.05); }


        /* Dev Tab Styles */
        #selected-car-display { margin-bottom: 2rem; padding: 1.5rem; border-radius: 10px; background-color: #333; box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5); border: 1px solid #555; }
        #selected-car-display h4 { margin-top: 0; color: #ff9a21; font-size: 1.2rem; margin-bottom: 1rem; font-weight: 700;}
        #selected-car-display ul { list-style: none; padding: 0; margin: 0; } /* Use UL for stats */
        #selected-car-display ul li { display: flex; justify-content: space-between; padding: 0.3rem 0; border-bottom: 1px dashed #555; font-size: 0.95rem; }
        #selected-car-display ul li:last-child { border-bottom: none; }
        #selected-car-display ul li span:first-child { color: #ccc; font-weight: bold; margin-right: 1rem; }
        #selected-car-display ul li span:last-child { color: #fff; font-weight: bold; }
        #selected-car-display ul li.global-stat { margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px solid #777; font-size: 1.05rem; }
        #selected-car-display ul li.global-stat span:first-child { color: #ffae42; }

        #car-upgrade-options-container { margin-bottom: 2.5rem; }
        #car-upgrade-options-container h3 { color: #ff9a21; margin-bottom: 1.2rem; font-size: 1.3rem; border-bottom: 1px solid #666; padding-bottom: 0.7rem; font-weight: 700;}
        #car-upgrade-options .card { background-color: #3a3a3a; }
        #car-upgrade-options .card ul { margin-bottom: 0.8rem; }
        #car-upgrade-options .card button { margin-top: 1.2rem; }
        /* Next Season Investment Section */
        #next-season-investment-container { margin-top: 2.5rem; border-top: 2px solid #673AB7; padding-top: 2rem; }
        #next-season-investment-container h3 { color: #9575CD; margin-bottom: 1.2rem; font-size: 1.3rem; } /* Purple title */
        #next-season-investment-container h3 small { font-size: 0.85rem; color: #bbb; font-weight: 400; margin-left: 12px; }

        #opponent-cars-list-container { margin-top: 2.5rem; border-top: 2px solid #ff8700; padding-top: 2rem; }
        #opponent-cars-list-container h3 { margin-bottom: 1.2rem; color: #ff9a21; text-shadow: none; font-size: 1.3rem; font-weight: 700;}
        #opponent-cars-list-container h3 small { font-size: 0.85rem; color: #bbb; font-weight: 400; margin-left: 12px; }
        #opponent-cars-list .card { background-color: #282828; opacity: 0.85; border-color: #383838; }
         /* Style for opponent car stat list */
         #opponent-cars-list .card ul li { font-size: 0.9rem; margin-bottom: 0.4rem; }
         #opponent-cars-list .card ul li.global-stat { font-weight: bold; color: #ffae42; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dotted #555; }

         /* Standings Tab Styles */
         #season-info { text-align: center; margin-bottom: 1rem; font-size: 1.2rem; color: #ccc; font-weight: 700;}
         /* NEW: Season History Dropdown */
         #standings-history-controls { margin-bottom: 1.5rem; text-align: center; }
         #standings-history-controls label { margin-right: 10px; font-weight: bold; color: #ccc;}
         #history-season-select {
             padding: 0.5rem 1rem;
             background-color: #333;
             color: #eee;
             border: 1px solid #555;
             border-radius: 4px;
             font-family: 'Roboto', sans-serif;
             font-size: 0.95rem;
             cursor: pointer;
         }
         #standings-chart-container { margin-bottom: 2rem; }
         #season-standings-list-container h3 { color: #ff9a21; margin-bottom: 1.2rem; font-size: 1.3rem; }
         #season-standings-list { list-style: none; padding: 0; background-color: #252525; border-radius: 8px; border: 1px solid #444; overflow: hidden; }
         #season-standings-list li { display: flex; align-items: center; padding: 0.8rem 1rem; border-bottom: 1px solid #444; font-size: 0.95rem; transition: background-color 0.2s ease; }
         #season-standings-list li:last-child { border-bottom: none; }
         #season-standings-list li:hover { background-color: #333; }
         .position-number { font-weight: bold; color: #ff8700; min-width: 3em; text-align: right; margin-right: 1rem; }
         #season-standings-list li span:nth-child(2) { color: #e0e0e0; margin-right: 1rem; flex-grow: 1; } /* Driver Name & Team */
         #season-standings-list li span:last-child { font-weight: bold; color: #fff; min-width: 90px; text-align: right; } /* Points */
         /* --- THIS IS THE KEY STYLE FOR HIGHLIGHTING --- */
         #season-standings-list li.player-driver {
             background-color: rgba(255, 135, 0, 0.1) !important; /* Use !important to ensure override if needed */
             border-left: 4px solid #ff8700;
             padding-left: calc(1rem - 4px);
         }
         #season-standings-list li.player-driver span:nth-child(2) {
             color: #ffae42; /* Highlight player name */
             font-weight: bold;
         }

         /* Calendar Tab Styles */
         #calendar-list-container h3 { color: #ff9a21; margin-bottom: 1.2rem; font-size: 1.3rem; }
         #calendar-list { list-style: none; padding: 0; background-color: #252525; border-radius: 8px; border: 1px solid #444; overflow: hidden;}
         #calendar-list li { padding: 1rem 1.2rem; border-bottom: 1px solid #444; font-size: 1rem; transition: background-color 0.2s ease;}
         #calendar-list li:last-child { border-bottom: none; }
         #calendar-list li:hover { background-color: #333; }
         #calendar-list li.completed { color: #888; }
         #calendar-list li.completed .race-details { text-decoration: line-through; opacity: 0.7; }
         #calendar-list li.next-race { font-weight: bold; color: #ff8700; background-color: rgba(255, 135, 0, 0.1); border-left: 4px solid #ff8700; padding-left: calc(1.2rem - 4px);}
         #calendar-list li ul { list-style: none; padding: 0.6rem 0 0 1.2rem; margin: 0; font-size: 0.85rem; color: #bbb; font-weight: normal; }
         #calendar-list li ul li { padding: 0.15rem 0; border: none; background-color: transparent; /* Reset sub-item style */}
         .race-name { font-weight: bold; display: block; margin-bottom: 0.4rem; font-size: 1.05rem; }

        /* Placeholder Styles */
        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 1rem; /* Reduced margin */
            margin-bottom: 1rem;
            padding: 0.5rem; /* Add some padding */
            font-style: italic;
            list-style: none !important; /* Override list styling */
            border: none !important; /* Override borders */
            background-color: transparent !important; /* Override background */
        }
         #qualifying-results-area ol li.placeholder-text, #starting-grid ol li.placeholder-text {
             padding: 1rem; /* More padding for these areas */
         }


        /* Responsive styles */
        @media (max-width: 768px) {
            body { align-items: flex-start; }
            #app { width: 100%; padding: 15px; border-radius: 0; margin-top: 70px; box-shadow: none; }
            #budget-display { font-size: 1rem; padding: 0.6rem 1.2rem; }
            #run-qualifying-button, #start-race-button, #accelerate-race-button, #next-gp-button, #next-season-button, #confirm-drivers-button, #clear-notifications-button { padding: 0.7rem 1.4rem; font-size: 0.9rem; max-width: 90%; display: block; margin-left: auto; margin-right: auto;}
            #race-controls, #driver-market-controls { margin-bottom: 1.5rem; }
            #initial-budget-selection, #ecurie-selection, #drivers-list, #cars-list,
            #car-upgrade-options, #season-standings-list, #calendar-list,
            #opponent-cars-list, #drivers-list-management, #driver-market-list,
            #next-season-investment-options /* Added */ { grid-template-columns: 1fr; gap: 1.2rem;}
            .card { padding: 1.2rem; }
            .card button { font-size: 0.85rem; padding: 0.7rem 1.2rem; }
            h1{ font-size: 1.8rem; } h2{ font-size: 1.3rem; } h3{ font-size: 1.15rem; } h4 { font-size: 1rem;}
            .tabs { margin-bottom: 1.5rem; }
            .tab-button { padding: 0.7rem 1rem; font-size: 0.9rem; flex-basis: 33%; }
            .sub-tabs { margin-bottom: 1rem;}
            .sub-tab-button { font-size: 0.85rem; padding: 0.5rem 1rem; margin-right: 5px;}
            #qualifying-results-area ol { font-size: 0.85rem;}
            #live-leaderboard ol { font-size: 0.9rem; }
            #live-leaderboard ol li .gap-display { font-size: 0.8em; min-width: 60px; } /* Adjust gap size */
            #race-results ol li { font-size: 0.95rem; }
            #race-results ol li::before { margin-right: 0.6rem; min-width: 1.8em; }
            #season-info { font-size: 1.1rem; }
             #standings-history-controls label { display: block; margin-bottom: 5px;} /* Stack label on mobile */
             #history-season-select { width: 80%; display: block; margin: 0 auto;}
            .position-number { min-width: 2.2em; margin-right: 0.8rem;}
            .message-box { width: 90%; font-size: 0.9rem; padding: 0.9rem 1.5rem; top: 75px; }
            #notifications-list li { font-size: 0.85rem;}
             #selected-car-display ul li { font-size: 0.9rem;}
        }
         @media (max-width: 480px) {
              h1 { font-size: 1.6rem; } h2 { font-size: 1.1rem; } h3 { font-size: 1.05rem; } h4 { font-size: 0.95rem;}
              .tab-button { flex-basis: 50%; font-size: 0.8rem; padding: 0.6rem 0.8rem;}
              .sub-tab-button { flex-basis: calc(50% - 5px); font-size: 0.8rem; padding: 0.5rem 0.8rem;}
              .card h3 { font-size: 1.05rem; } .card li { font-size: 0.85rem; }
              #budget-display { font-size: 0.9rem; padding: 0.5rem 1rem;}
              #run-qualifying-button, #start-race-button, #accelerate-race-button, #next-gp-button, #next-season-button, #confirm-drivers-button, #clear-notifications-button { font-size: 0.85rem; padding: 0.6rem 1rem;}
              #season-info { font-size: 1rem; }
              #season-standings-list li { font-size: 0.85rem; }
              .position-number { font-size: 0.85rem; min-width: 2em;}
              #season-standings-list li span:last-child { min-width: 70px; font-size: 0.85rem;}
              #calendar-list li { font-size: 0.9rem; }
              #live-leaderboard ol { font-size: 0.85rem; }
              #live-leaderboard ol li .gap-display { font-size: 0.75em; min-width: 55px; } /* Adjust gap size */
              #race-results ol li { font-size: 0.85rem;}
              #notifications-list li { font-size: 0.8rem;}
               #selected-car-display ul li { font-size: 0.85rem;}
         }

    </style>
</head>
<body>
    <!-- Budget Display -->
    <div id="budget-display">Budget: $0</div>

    <div id="app">
        <h1>F1 Team Manager</h1>

        <!-- Initial Setup Screens -->
        <div id="initial-budget-selection"></div>
        <div id="ecurie-selection" style="display: none;"></div>
        <div id="initial-driver-selection" style="display: none;">
             <h2 id="drivers-title">Select Your Two Drivers</h2>
             <div id="drivers-list"></div>
        </div>

        <!-- Main Management Screen -->
        <div id="team-management-screen" style="display: none;">
            <div class="tabs">
                <button class="tab-button active" data-tab="development">Car Dev</button>
                <button class="tab-button" data-tab="drivers">Drivers</button>
                <button class="tab-button" data-tab="standings">Standings</button>
                <button class="tab-button" data-tab="calendar">Calendar</button>
                 <button class="tab-button" data-tab="race">Race HQ</button>
                 <button class="tab-button" data-tab="notifications">Notifications</button>
            </div>

             <!-- Development Tab -->
            <div id="development-tab" class="tab-content active"> <!-- Default to active -->
                <h2>Car Development</h2>
                 <div id="selected-car-display">
                     <h4>Your Car (<span id="car-name-placeholder">Car Name</span> - <span id="car-year-placeholder">Year</span>)</h4>
                     <!-- Updated to display stats in a list -->
                     <ul id="car-stats-list">
                        <li class="placeholder-text">Car stats will appear here.</li>
                     </ul>
                 </div>
                 <!-- NEW Chart Section -->
                 <div id="car-dev-chart-container" class="chart-container" style="display: none;"> <!-- Hide initially -->
                    <h4 class="chart-title">Car Performance Progression (Overall Rating)</h4>
                    <canvas id="car-dev-line-chart-canvas"></canvas>
                    <p id="car-dev-chart-placeholder" class="placeholder-text">Complete the first race to see the chart.</p>
                 </div>
                 <!-- End NEW Chart Section -->
                 <div id="car-upgrade-options-container">
                     <h3>Upgrade Options (Current Season)</h3>
                     <div id="car-upgrade-options"></div>
                 </div>
                 <!-- MODIFIED: Next Season Investment Section -->
                 <div id="next-season-investment-container">
                      <h3>Next Season R&D Focus <small>(Boosts potential gains for the chosen stat)</small></h3>
                     <div id="next-season-investment-options"></div>
                 </div>
                 <!-- End Next Season Investment Section -->
                 <div id="opponent-cars-list-container">
                      <h3>Opponent Cars <small>(Upgrades from last race shown in <span class="stat-increase">green</span>)</small></h3>
                     <div id="opponent-cars-list"></div>
                 </div>
            </div>

             <!-- Drivers Tab -->
             <div id="drivers-tab" class="tab-content" style="display: none;">
                <h2>Your Drivers</h2>
                <p>Your selected drivers are highlighted in yellow below. AI drivers are assigned based on skill and team car performance. You can change drivers at the end of the season via the Driver Market.</p>
                <div id="drivers-list-management"></div>
            </div>

            <!-- Standings Tab -->
            <div id="standings-tab" class="tab-content" style="display: none;">
                <h2>Season Standings</h2>
                <p id="season-info">Season Info Placeholder</p>
                 <div id="standings-history-controls">
                     <label for="history-season-select">View Past Season:</label>
                     <select id="history-season-select">
                         <option value="current">Current Season</option>
                         <!-- Options for past seasons added dynamically -->
                     </select>
                 </div>
                 <div id="standings-chart-container" class="chart-container">
                    <h4 class="chart-title">Driver Points Progression (Top 10)</h4>
                    <canvas id="standings-line-chart-canvas" style="display: none;"></canvas> <!-- Hide canvas initially -->
                    <p id="standings-chart-placeholder" class="placeholder-text">Complete the first race to see the chart.</p> <!-- Placeholder text -->
                </div>
                <div id="season-standings-list-container">
                     <h3 id="standings-list-title">Driver Standings</h3>
                     <ul id="season-standings-list">
                         <li class="placeholder-text">Standings will appear after the first race.</li>
                     </ul>
                 </div>
            </div>

             <!-- Calendar Tab -->
             <div id="calendar-tab" class="tab-content" style="display: none;">
                <h2>Race Calendar</h2>
                 <p id="calendar-info">Calendar Info Placeholder</p>
                  <div id="calendar-list-container">
                     <h3>Schedule</h3>
                     <ul id="calendar-list">
                          <li class="placeholder-text">Calendar will be generated at season start.</li>
                     </ul>
                 </div>
             </div>

            <!-- Race Tab (REVISED STRUCTURE with Sub-Tabs) -->
            <div id="race-tab" class="tab-content" style="display: none;">
                 <h2>Race HQ</h2>
                  <div id="race-controls">
                     <button id="run-qualifying-button" style="display: none;">Run Qualifying</button>
                     <button id="start-race-button" style="display: none;">Start Race (Live)</button>
                     <button id="accelerate-race-button" style="display: none;">Accelerate Race</button>
                     <button id="next-gp-button" style="display: none;">Next Race Weekend</button>
                     <button id="next-season-button" style="display: none;">Start Next Season</button>
                 </div>
                 <div class="sub-tabs">
                     <button class="sub-tab-button active" data-subtab="qualifying">Quali/Grid</button>
                     <button class="sub-tab-button" data-subtab="live">Live Race</button>
                     <button class="sub-tab-button" data-subtab="final">Final Results</button>
                 </div>
                 <div id="race-qualifying-subtab-content" class="sub-tab-content active">
                     <div id="qualifying-results-area">
                         <h3 id="qualifying-title">Qualifying</h3>
                         <div id="q1-results" style="margin-bottom: 0.5rem;"><h4>Q1 Results:</h4><ol><li class="placeholder-text">Run qualifying to see results.</li></ol></div>
                         <div id="q2-results" style="margin-bottom: 0.5rem;"><h4>Q2 Results:</h4><ol><li class="placeholder-text"></li></ol></div>
                         <div id="q3-results" style="margin-bottom: 0.5rem;"><h4>Q3 Results:</h4><ol><li class="placeholder-text"></li></ol></div>
                         <div id="starting-grid" style="margin-top: 1rem;"><h4>Starting Grid:</h4><ol><li class="placeholder-text"></li></ol></div>
                     </div>
                 </div>
                 <div id="race-live-subtab-content" class="sub-tab-content">
                     <div id="live-race-area" style="display: none;"> <!-- Hide initially -->
                         <h3>Race Live</h3>
                         <p id="live-lap-counter">Lap: 0 / 0</p>
                         <div id="live-leaderboard">
                             <h4>Leaderboard:</h4>
                             <ol></ol>
                         </div>
                     </div>
                     <p id="live-race-placeholder" class="placeholder-text">Start the race to see live updates.</p>
                 </div>
                 <div id="race-final-subtab-content" class="sub-tab-content">
                     <div id="race-results" style="display: none;"> <!-- Hide initially -->
                         <h3 id="race-results-title">Race Results</h3>
                         <ol></ol>
                         <p id="race-message">Race statistics will appear here.</p>
                          <div id="prize-money-earned">
                               <h4>Prize Money Earned (Player):</h4>
                               <ul></ul>
                               <p>Total Earned: $0</p>
                          </div>
                     </div>
                      <p id="final-results-placeholder" class="placeholder-text">Complete the race to see final results.</p>
                 </div>
                 <div id="visual-simulation-placeholder" style="display:none;"></div> <!-- Keep hidden -->
            </div> <!-- End #race-tab -->

             <!-- Notifications Tab -->
             <div id="notifications-tab" class="tab-content" style="display: none;">
                <h2>Notifications</h2>
                <p>Recent game events and changes:</p>
                <ul id="notifications-list">
                    <li class="placeholder">No notifications yet.</li>
                </ul>
                <button id="clear-notifications-button" style="margin-top: 1rem;">Clear Log</button>
            </div>

        </div> <!-- End #team-management-screen -->

         <!-- Driver Market Screen -->
         <div id="driver-market-screen" style="display: none;">
             <h2 id="driver-market-title">Driver Market - End of Season <span id="market-season-year"></span></h2>
             <p>Select your two drivers for the upcoming season. Current drivers are highlighted <span style="color:#00BCD4; font-weight:bold;">blue</span>. Deselect a current driver to free up a slot and budget. Newly selected drivers are highlighted <span style="color:#4CAF50; font-weight:bold;">green</span>. Stat changes vs base shown in brackets.</p>
             <div id="driver-market-list"></div>
             <div id="driver-market-controls">
                  <button id="confirm-drivers-button" disabled>Confirm Team for Next Season</button>
             </div>
         </div>

         <!-- Message Box -->
         <div id="message-box" class="message-box"></div>
    </div> <!-- End #app -->

    <script>
        // --- Constants ---
        const EcuriesData = [ { id: 1, name: 'Mercedes', cost: 200000000, defaultCarId: 1, defaultDriverIds: [1, 6] }, { id: 2, name: 'Red Bull', cost: 180000000, defaultCarId: 2, defaultDriverIds: [2, 7] }, { id: 3, name: 'Ferrari', cost: 170000000, defaultCarId: 3, defaultDriverIds: [3, 5] }, { id: 4, name: 'McLaren', cost: 150000000, defaultCarId: 4, defaultDriverIds: [4, 19] }, { id: 5, name: 'Alpine', cost: 140000000, defaultCarId: 5, defaultDriverIds: [9, 10] }, { id: 6, name: 'Aston Martin', cost: 160000000, defaultCarId: 6, defaultDriverIds: [8, 14] }, { id: 7, name: 'Alfa Romeo', cost: 120000000, defaultCarId: 7, defaultDriverIds: [11, 15] }, { id: 8, name: 'Haas', cost: 110000000, defaultCarId: 8, defaultDriverIds: [16, 17] }, { id: 9, name: 'AlphaTauri', cost: 130000000, defaultCarId: 9, defaultDriverIds: [18, 13] }, { id: 10, name: 'Williams', cost: 100000000, defaultCarId: 10, defaultDriverIds: [12, 20] }, ];
        const CarsData = [ { id: 1, name: 'W14', engine: 94, aero: 95, chassis: 93, reliability: 92, cost: 0 }, { id: 2, name: 'RB19', engine: 96, aero: 93, chassis: 94, reliability: 94, cost: 0 }, { id: 3, name: 'SF23', engine: 95, aero: 94, chassis: 92, reliability: 90, cost: 0 }, { id: 4, name: 'MCL60', engine: 92, aero: 93, chassis: 91, reliability: 93, cost: 0 }, { id: 5, name: 'A523', engine: 91, aero: 91, chassis: 90, reliability: 91, cost: 0 }, { id: 6, name: 'AMR23', engine: 93, aero: 92, chassis: 92, reliability: 92, cost: 0 }, { id: 7, name: 'C43', engine: 89, aero: 89, chassis: 88, reliability: 90, cost: 0 }, { id: 8, name: 'VF-23', engine: 88, aero: 87, chassis: 87, reliability: 88, cost: 0 }, { id: 9, name: 'AT04', engine: 90, aero: 88, chassis: 87, reliability: 89, cost: 0 }, { id: 10, name: 'FW45', engine: 87, aero: 86, chassis: 86, reliability: 87, cost: 0 }, ];
        const UpgradesData = [ { id: 1, name: 'Engine Power Boost', cost: 35000000, effect: { stat: 'engine', value: 5 } }, { id: 2, name: 'Advanced Aero Suite', cost: 32000000, effect: { stat: 'aero', value: 5 } }, { id: 3, name: 'Reliability Overhaul', cost: 20000000, effect: { stat: 'reliability', value: 5 } }, { id: 4, name: 'Chassis Tuning', cost: 28000000, effect: { stat: 'chassis', value: 4 } }, { id: 5, name: 'Lightweight Components', cost: 40000000, effect: { stat: 'chassis', value: 3 } }, { id: 6, name: 'Front Wing Update', cost: 22000000, effect: { stat: 'aero', value: 3 } }, { id: 7, name: 'Gearbox Refinement', cost: 15000000, effect: { stat: 'reliability', value: 4 } }, { id: 8, name: 'ECU Remap', cost: 25000000, effect: { stat: 'engine', value: 3 } }, { id: 9, name: 'Underfloor Aero', cost: 30000000, effect: { stat: 'aero', value: 4 } }, { id: 10, name: 'Suspension Redesign', cost: 24000000, effect: { stat: 'chassis', value: 3 } }, ];
        const DriversData = [ { id: 1, name: 'L. Hamilton', skill: 95, cost: 25000000, qualyPace: 96, racePace: 94, consistency: 95, overtaking: 98, defending: 95 }, { id: 2, name: 'M. Verstappen', skill: 96, cost: 26000000, qualyPace: 98, racePace: 97, consistency: 92, overtaking: 97, defending: 96 }, { id: 3, name: 'C. Leclerc', skill: 94, cost: 22000000, qualyPace: 97, racePace: 91, consistency: 88, overtaking: 92, defending: 89 }, { id: 4, name: 'L. Norris', skill: 93, cost: 20000000, qualyPace: 92, racePace: 93, consistency: 94, overtaking: 90, defending: 91 }, { id: 5, name: 'C. Sainz', skill: 91, cost: 18000000, qualyPace: 90, racePace: 92, consistency: 93, overtaking: 88, defending: 94 }, { id: 6, name: 'G. Russell', skill: 92, cost: 19000000, qualyPace: 94, racePace: 90, consistency: 91, overtaking: 89, defending: 93 }, { id: 7, name: 'S. Perez', skill: 89, cost: 17000000, qualyPace: 88, racePace: 90, consistency: 89, overtaking: 91, defending: 90 }, { id: 8, name: 'F. Alonso', skill: 90, cost: 18000000, qualyPace: 89, racePace: 95, consistency: 98, overtaking: 96, defending: 98 }, { id: 9, name: 'P. Gasly', skill: 87, cost: 14000000, qualyPace: 89, racePace: 86, consistency: 87, overtaking: 88, defending: 85 }, { id: 10, name: 'E. Ocon', skill: 86, cost: 13000000, qualyPace: 87, racePace: 85, consistency: 88, overtaking: 85, defending: 88 }, { id: 11, name: 'V. Bottas', skill: 88, cost: 15000000, qualyPace: 91, racePace: 87, consistency: 90, overtaking: 84, defending: 86 }, { id: 12, name: 'A. Albon', skill: 85, cost: 12000000, qualyPace: 88, racePace: 84, consistency: 86, overtaking: 82, defending: 83 }, { id: 13, name: 'D. Ricciardo', skill: 84, cost: 11000000, qualyPace: 86, racePace: 83, consistency: 85, overtaking: 89, defending: 80 }, { id: 14, name: 'L. Stroll', skill: 82, cost: 10000000, qualyPace: 82, racePace: 81, consistency: 80, overtaking: 80, defending: 82 }, { id: 15, name: 'Z. Guanyu', skill: 81, cost: 9000000, qualyPace: 83, racePace: 82, consistency: 84, overtaking: 79, defending: 81 }, { id: 16, name: 'K. Magnussen', skill: 83, cost: 10500000, qualyPace: 85, racePace: 80, consistency: 82, overtaking: 86, defending: 87 }, { id: 17, name: 'N. Hulkenberg', skill: 84, cost: 11000000, qualyPace: 87, racePace: 81, consistency: 89, overtaking: 81, defending: 84 }, { id: 18, name: 'Y. Tsunoda', skill: 80, cost: 8500000, qualyPace: 84, racePace: 79, consistency: 78, overtaking: 83, defending: 79 }, { id: 19, name: 'O. Piastri', skill: 86, cost: 12000000, qualyPace: 90, racePace: 88, consistency: 92, overtaking: 87, defending: 85 }, { id: 20, name: 'L. Sargeant', skill: 79, cost: 7000000, qualyPace: 80, racePace: 78, consistency: 75, overtaking: 78, defending: 77 }, ];
        const RacesData = [ { id: 1, name: 'Bahrain GP', length: 308.238, laps: 57, speedFocus: 85, handlingFocus: 85, reliabilityStress: 85 }, { id: 2, name: 'Saudi Arabia GP', length: 308.450, laps: 50, speedFocus: 95, handlingFocus: 80, reliabilityStress: 80 }, { id: 3, name: 'Australia GP', length: 307.574, laps: 58, speedFocus: 90, handlingFocus: 90, reliabilityStress: 80 }, { id: 4, name: 'Azerbaijan GP', length: 306.049, laps: 51, speedFocus: 100, handlingFocus: 75, reliabilityStress: 75 }, { id: 5, name: 'Miami GP', length: 308.326, laps: 57, speedFocus: 85, handlingFocus: 90, reliabilityStress: 80 }, { id: 6, name: 'Emilia Romagna GP', length: 309.049, laps: 63, speedFocus: 88, handlingFocus: 88, reliabilityStress: 82 }, { id: 7, name: 'Monaco GP', length: 260.286, laps: 78, speedFocus: 60, handlingFocus: 100, reliabilityStress: 70 }, { id: 8, name: 'Spain GP', length: 307.237, laps: 66, speedFocus: 85, handlingFocus: 90, reliabilityStress: 80 }, { id: 9, name: 'Canada GP', length: 305.270, laps: 70, speedFocus: 90, handlingFocus: 85, reliabilityStress: 80 }, { id: 10, name: 'Austria GP', length: 306.452, laps: 71, speedFocus: 90, handlingFocus: 85, reliabilityStress: 85 }, { id: 11, name: 'Great Britain GP', length: 306.198, laps: 52, speedFocus: 92, handlingFocus: 92, reliabilityStress: 78 }, { id: 12, name: 'Hungary GP', length: 306.630, laps: 70, speedFocus: 75, handlingFocus: 95, reliabilityStress: 80 }, { id: 13, name: 'Belgium GP', length: 308.052, laps: 44, speedFocus: 98, handlingFocus: 70, reliabilityStress: 80 }, { id: 14, name: 'Netherlands GP', length: 305.876, laps: 72, speedFocus: 70, handlingFocus: 98, reliabilityStress: 80 }, { id: 15, name: 'Italy GP', length: 306.720, laps: 53, speedFocus: 100, handlingFocus: 65, reliabilityStress: 80 }, { id: 16, name: 'Singapore GP', length: 306.320, laps: 62, speedFocus: 80, handlingFocus: 95, reliabilityStress: 85 }, { id: 17, name: 'Japan GP', length: 307.471, laps: 53, speedFocus: 92, handlingFocus: 90, reliabilityStress: 78 }, { id: 18, name: 'Qatar GP', length: 306.660, laps: 57, speedFocus: 95, handlingFocus: 85, reliabilityStress: 80 }, { id: 19, name: 'USA GP', length: 308.405, laps: 56, speedFocus: 88, handlingFocus: 90, reliabilityStress: 82 }, { id: 20, name: 'Mexico GP', length: 305.584, laps: 71, speedFocus: 90, handlingFocus: 85, reliabilityStress: 85 }, { id: 21, name: 'Brazil GP', length: 305.909, laps: 71, speedFocus: 88, handlingFocus: 88, reliabilityStress: 82 }, { id: 22, name: 'Las Vegas GP', length: 310.000, laps: 50, speedFocus: 95, handlingFocus: 80, reliabilityStress: 80 }, { id: 23, name: 'Abu Dhabi GP', length: 305.355, laps: 58, speedFocus: 85, handlingFocus: 85, reliabilityStress: 85 }, { id: 24, name: 'China GP', length: 305.066, laps: 56, speedFocus: 90, handlingFocus: 89, reliabilityStress: 81 }, ];
        const BudgetOptions = [ { amount: 150000000, name: 'Challenger ($150M)' }, { amount: 175000000, name: 'Midfield ($175M)' }, { amount: 200000000, name: 'Top Team ($200M)' }, ];
        const NextSeasonInvestmentOptions = [ { id: 1, name: 'Engine Focus R&D', cost: 20000000, targetStat: 'engine', description: "Increases chance of positive ENGINE gains next season." }, { id: 2, name: 'Aerodynamics Focus R&D', cost: 20000000, targetStat: 'aero', description: "Increases chance of positive AERO gains next season." }, { id: 3, name: 'Chassis Focus R&D', cost: 20000000, targetStat: 'chassis', description: "Increases chance of positive CHASSIS gains next season." }, { id: 4, name: 'Reliability Focus R&D', cost: 20000000, targetStat: 'reliability', description: "Increases chance of positive RELIABILITY gains next season." }, ];
        const PointsSystem = [25, 18, 15, 12, 10, 8, 6, 4, 2, 1];
        const GLOBAL_STAT_WEIGHTS = { engine: 0.3, aero: 0.3, chassis: 0.25, reliability: 0.15 };

        // --- Simulation & Gameplay Constants ---
        const QUALI_BASE_TIME_MS = 95000; // Base Quali Time (e.g., 1:35.000)
        const QUALI_DRIVER_TIME_FACTOR = 50; // ms improvement per driver qualyPace point
        const QUALI_CAR_ENGINE_TIME_FACTOR = 40; // ms improvement per car engine point
        const QUALI_CAR_AERO_TIME_FACTOR = 40;   // ms improvement per car aero point
        const QUALI_CAR_CHASSIS_TIME_FACTOR = 50; // ms improvement per car chassis point
        const QUALI_RANDOM_MS_FACTOR = 250; // Random variation in ms (+/-)
        const RACE_UPDATE_INTERVAL_MS = 250;
        const LAPTIME_BASE_MS = 90000;
        const LAPTIME_DRIVER_PACE_FACTOR = 15; // ms per point
        const LAPTIME_CAR_ENGINE_FACTOR = 10;  // ms per point
        const LAPTIME_CAR_AERO_FACTOR = 8;    // ms per point
        const LAPTIME_CAR_CHASSIS_FACTOR = 6;  // ms per point
        const LAPTIME_CONSISTENCY_FACTOR = 10; // Scales random variation based on (100 - consistency)
        const OVERTAKE_GAP_THRESHOLD_MS = 1500;
        const OVERTAKE_LAPTIME_DIFF_THRESHOLD_MS = 100;
        const RACE_OVERTAKE_BASE_CHANCE = 0.5;
        const RACE_OVERTAKE_SKILL_FACTOR = 0.008;
        const RACE_DEFEND_SKILL_FACTOR = 0.008;
        const RACE_CAR_OVERTAKE_ENGINE_FACTOR = 0.003;
        const RACE_CAR_OVERTAKE_AERO_FACTOR = 0.002;
        const OVERTAKE_RANDOM_FACTOR = 0.15;
        const RACE_RELIABILITY_DNF_BASE_CHANCE = 0.001;
        const RACE_RELIABILITY_STAT_FACTOR = 0.0005;
        const RACE_RELIABILITY_TRACK_FACTOR = 0.0002;
        const MAX_DNF_PER_RACE_PERCENT = 0.15;
        const MINOR_MISTAKE_CHANCE = 0.06;
        const MINOR_MISTAKE_BASE_TIME_MS = 150;
        const MINOR_MISTAKE_CONSISTENCY_SCALE = 5;
        const MAJOR_MISTAKE_CHANCE = 0.008;
        const MAJOR_MISTAKE_MIN_TIME_MS = 1500;
        const MAJOR_MISTAKE_MAX_TIME_MS = 4000;
        const BOOST_CHANCE = 0.025;
        const BOOST_MIN_TIME_MS = 50;
        const BOOST_MAX_TIME_MS = 150;
        const MAX_STAT_VALUE_PLAYER = 120;
        const MAX_STAT_VALUE_AI = 115;
        const PRIZE_MONEY_PER_POINT = 200000;
        const PRIZE_MONEY_PODIUM_BONUS = 2000000;
        const PRIZE_MONEY_TOP_10_BONUS = 1000000;
        const PRIZE_MONEY_P11_P20_BONUS = 500000;
        const PLAYER_BONUS_PER_POINT = 50000;
        const AI_BONUS_PER_POINT = 5000;
        const MAX_NOTIFICATIONS = 50;
        const BASE_STAT_CHANGE_MIN = -2;
        const BASE_STAT_CHANGE_MAX = 2;
        const INVESTED_STAT_CHANGE_MIN = 0;
        const INVESTED_STAT_CHANGE_MAX = 5;
        const DRIVER_COST_SKILL_FACTOR = 250000; // Cost change per point of skill change
        const DRIVER_MIN_COST = 1000000; // Minimum driver cost

        // --- Global State Variables ---
        let gameState = 'SETUP'; // SETUP, MANAGEMENT, DRIVER_MARKET, SEASON_END
        let teamName = '', selectedEcurieId = null, selectedDriverIds = [], selectedCar = null, budget = 0;
        let purchasedUpgrades = {}; // { upgradeId: true }
        let driverSeasonScores = {}; // { driverId: points }
        let currentSeasonYear = 2024, currentRaceIndex = 0;
        let currentDrivers = [], currentCars = [], currentEcuries = [];
        let aiTeamBudgets = {}; // { teamId: budget }
        let aiTeamUpgrades = {}; // { teamId: { upgradeId: true } }
        let lastAIRaceUpgrades = {}; // { carId: { stat: 'aero', change: 3 } } - Example
        let currentSeasonCalendar = [], totalRacesInSeason = 0;
        let qualifyingResults = { q1: [], q2: [], q3: [] }; // Stores { driver, car, time (ms) }
        let startingGrid = []; // Array of { driver, car } objects
        let raceLeaderboard = []; // Array of { driver, car, status, totalRaceTime, lastLapTime, lapsCompleted } objects
        let currentLap = 0, raceIntervalId = null, dnfCountThisRace = 0, maxDnfThisRace = 0;
        let raceCompletedForCurrentIndex = false;
        let marketSelectedDriverIds = []; // Driver IDs selected in the end-of-season market
        let notificationsLog = []; // Array of { message, type, timestamp, typeClass }
        let driverRaceHistory = {}; // { driverId: [race1_score, race2_score, ...] } - Stores CUMULATIVE scores
        let standingsChartInstance = null;
        let carDevChartInstance = null; // Chart instance for car development
        let playerInvestedStat = null; // 'engine', 'aero', 'chassis', 'reliability', or null
        let aiTeamInvestedStats = {}; // { teamId: 'aero' }
        let seasonHistory = {}; // { 2024: [{driverId, driverName, teamId, teamName, points}, ...], 2025: [...] }
        let carPerformanceHistory = {}; // { teamId: [rating_start, rating_after_R1, ...] }


        // --- Initialization & Setup ---

        function initGame() {
            gameState = 'SETUP'; teamName=''; selectedEcurieId=null; selectedDriverIds=[]; selectedCar=null; budget=0; purchasedUpgrades={}; driverSeasonScores={}; currentRaceIndex=0; currentSeasonYear=2024; aiTeamBudgets={}; aiTeamUpgrades={}; lastAIRaceUpgrades={}; currentSeasonCalendar=[]; qualifyingResults={q1:[],q2:[],q3:[]}; startingGrid=[]; raceLeaderboard=[]; if(raceIntervalId) clearInterval(raceIntervalId); raceIntervalId=null; dnfCountThisRace=0; raceCompletedForCurrentIndex = false; maxDnfThisRace = 0; marketSelectedDriverIds = []; notificationsLog = []; driverRaceHistory = {};
            playerInvestedStat = null; aiTeamInvestedStats = {}; seasonHistory = {}; carPerformanceHistory = {};
            currentDrivers = JSON.parse(JSON.stringify(DriversData)).map(d=>({...d, teamId:null}));
            currentCars = JSON.parse(JSON.stringify(CarsData));
            currentEcuries = JSON.parse(JSON.stringify(EcuriesData)).map(e=>({...e, driverIds:[]}));
            document.getElementById('budget-display').textContent=`Budget: $0`; document.getElementById('team-management-screen').style.display='none'; document.getElementById('driver-market-screen').style.display='none'; document.getElementById('ecurie-selection').style.display='none'; document.getElementById('initial-driver-selection').style.display='none'; document.getElementById('initial-budget-selection').style.display='none';
            clearQualifyingUI(); document.getElementById('live-race-area').style.display='none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display='none'; document.getElementById('final-results-placeholder').style.display = 'block';
            updateRaceHQButtonState();
            if (standingsChartInstance) { standingsChartInstance.destroy(); standingsChartInstance = null; }
            if (carDevChartInstance) { carDevChartInstance.destroy(); carDevChartInstance = null; }
            document.getElementById('standings-line-chart-canvas').style.display = 'none'; document.getElementById('standings-chart-placeholder').style.display = 'block';
            document.getElementById('car-dev-line-chart-canvas').style.display = 'none'; document.getElementById('car-dev-chart-placeholder').style.display = 'block'; document.getElementById('car-dev-chart-container').style.display = 'none';
            document.getElementById('season-standings-list').innerHTML = '<li class="placeholder-text">Standings will appear after the first race.</li>'; document.getElementById('calendar-list').innerHTML = '<li class="placeholder-text">Calendar will be generated at season start.</li>'; document.getElementById('car-stats-list').innerHTML = '<li class="placeholder-text">Car stats will appear here.</li>';
            renderNotifications(); renderBudgetSelection(); setupTabs(); setupRaceSubTabs(); setupHistoryDropdown();
            const setupButtonListener = (id, handler) => { const button = document.getElementById(id); if (button && !button.getAttribute('data-listener')) { button.addEventListener('click', handler); button.setAttribute('data-listener', 'true'); } };
            setupButtonListener('run-qualifying-button', handleRunQualifyingSequence); setupButtonListener('start-race-button', startRaceSimulation); setupButtonListener('accelerate-race-button', handleAccelerateRace); setupButtonListener('next-gp-button', handleNextRaceWeekend); setupButtonListener('next-season-button', handleStartNextSeason); setupButtonListener('confirm-drivers-button', handleConfirmDriverSelection); setupButtonListener('clear-notifications-button', () => { notificationsLog = []; renderNotifications(); showMessage('Notifications cleared.', 'info'); });
        }

        function initializeGameAfterSetup() {
            gameState = 'MANAGEMENT';
            const playerTeam = getTeamById(selectedEcurieId); if (playerTeam) { playerTeam.driverIds = selectedDriverIds; }
            selectedDriverIds.forEach(id => { const driver = getDriverById(id); if (driver) { driver.teamId = selectedEcurieId; } });
            aiTeamBudgets = {}; aiTeamUpgrades = {};
            currentEcuries.forEach(t => { if (t.id !== selectedEcurieId) { aiTeamBudgets[t.id] = randomizeBetween(15000000, 30000000); aiTeamUpgrades[t.id] = {}; } });
            assignAIDriversRanked();
            resetSeasonState(true); // Reset scores, upgrades, investments, calendar etc. Also initializes carPerformanceHistory[teamId] = [initialRating]
            document.getElementById('initial-budget-selection').style.display='none'; document.getElementById('ecurie-selection').style.display='none'; document.getElementById('initial-driver-selection').style.display='none'; document.getElementById('driver-market-screen').style.display = 'none'; document.getElementById('team-management-screen').style.display='block';
            updateRaceHQButtonState(); renderAllTabs(); activateTab('development'); activateRaceSubTab('qualifying');
            addNotification(`Welcome to ${teamName}! Season ${currentSeasonYear} begins. AI drivers assigned. Good luck!`, 'success');
        }

        function resetSeasonState(isNewSeasonStart = false) {
             lastAIRaceUpgrades = {}; qualifyingResults = { q1: [], q2: [], q3: [] }; startingGrid = []; raceLeaderboard = []; if(raceIntervalId) clearInterval(raceIntervalId); raceIntervalId = null; dnfCountThisRace = 0; maxDnfThisRace = 0; raceCompletedForCurrentIndex = false;
             if (isNewSeasonStart) {
                 currentRaceIndex = 0; driverSeasonScores = {}; driverRaceHistory = {}; generateSeasonCalendar();
                 currentDrivers.forEach(d => { driverSeasonScores[d.id] = 0; driverRaceHistory[d.id] = Array(totalRacesInSeason).fill(null); });
                 purchasedUpgrades = {}; aiTeamUpgrades = {};
                 playerInvestedStat = null; aiTeamInvestedStats = {};
                 if (standingsChartInstance) { standingsChartInstance.destroy(); standingsChartInstance = null; }
                 if (carDevChartInstance) { carDevChartInstance.destroy(); carDevChartInstance = null; }

                 // Initialize Car Performance History for the new season
                 carPerformanceHistory = {};
                 currentEcuries.forEach(team => {
                     const car = getCarById(team.defaultCarId);
                     const initialRating = calculateCarGlobalStat(car);
                     // Store rating *before* race 1 (at index 0)
                     carPerformanceHistory[team.id] = [initialRating];
                 });
             }
             if (selectedEcurieId) { const playerTeamCarId = getTeamById(selectedEcurieId)?.defaultCarId; if(playerTeamCarId) selectedCar = getCarById(playerTeamCarId); else console.error("Could not find player car after season reset!"); }
             clearQualifyingUI(); document.getElementById('live-race-area').style.display='none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display='none'; document.getElementById('final-results-placeholder').style.display = 'block';
             document.getElementById('standings-line-chart-canvas').style.display = 'none'; document.getElementById('standings-chart-placeholder').style.display = 'block'; document.getElementById('standings-chart-placeholder').textContent = 'Complete the first race to see the chart.';
             // Reset car dev chart display
             const carDevChartContainer = document.getElementById('car-dev-chart-container');
             const carDevCanvas = document.getElementById('car-dev-line-chart-canvas');
             const carDevPlaceholder = document.getElementById('car-dev-chart-placeholder');
             if(carDevChartContainer) carDevChartContainer.style.display = 'none';
             if(carDevCanvas) carDevCanvas.style.display = 'none';
             if(carDevPlaceholder) { carDevPlaceholder.style.display = 'block'; carDevPlaceholder.textContent = 'Complete the first race to see the chart.';}

             const historySelect = document.getElementById('history-season-select'); if(historySelect) historySelect.value = 'current';
        }

        // --- UI Rendering ---

        function renderBudgetSelection() { const el = document.getElementById('initial-budget-selection'); if (!el) return; el.innerHTML = '<h2>Select Your Starting Budget</h2>' + BudgetOptions.map(o => `<div class="card"><h3>${o.name}</h3><ul><li>Amount: $${formatNumber(o.amount)}</li></ul><button data-budget-amount="${o.amount}">Select Budget</button></div>`).join(''); el.querySelectorAll('button').forEach(b => b.addEventListener('click', () => handleBudgetSelection(parseInt(b.dataset.budgetAmount)))); el.style.display = 'grid'; }
        function renderEcurieSelection() { const el = document.getElementById('ecurie-selection'); if (!el) return; el.innerHTML = '<h2>Select Your Team</h2>' + currentEcuries.map(e => { const canAfford = budget >= e.cost; return `<div class="card ${!canAfford ? 'disabled' : ''}"><h3>${e.name}</h3><ul><li>Cost: $${formatNumber(e.cost)}</li></ul><button data-ecurie-id="${e.id}" ${!canAfford ? 'disabled' : ''}>${canAfford ? 'Select Team' : 'Insufficient Funds'}</button></div>`; }).join(''); el.querySelectorAll('button:not(:disabled)').forEach(b => b.addEventListener('click', () => handleEcurieSelection(parseInt(b.dataset.ecurieId)))); el.style.display = 'grid'; }
        function renderDriversList(containerId, isInitialSelection = false) {
            const el = document.getElementById(containerId); if (!el) return;
            const isTeamMgmtView = containerId === 'drivers-list-management'; let playerDriversHtml = ''; let otherDriversHtml = '';
            if (isTeamMgmtView) {
                const allDriversSorted = [...currentDrivers].sort((a, b) => b.skill - a.skill);
                const playerDrivers = allDriversSorted.filter(d => selectedDriverIds.includes(d.id));
                const otherDrivers = allDriversSorted.filter(d => !selectedDriverIds.includes(d.id));
                playerDriversHtml = playerDrivers.map(d => { const team = getTeamById(d.teamId); const teamNameDisplay = team ? ` (Your Team)` : ''; let cardClasses = ['card', 'player-team']; return `<div class="${cardClasses.join(' ')}"><h3>${d.name}${teamNameDisplay}</h3><ul><li>Skill: ${d.skill}</li><li>Quali: ${d.qualyPace}</li><li>Race: ${d.racePace}</li><li>Cons: ${d.consistency}</li><li>Ovr: ${d.overtaking}</li><li>Def: ${d.defending}</li><li>Cost: $${formatNumber(d.cost)}</li></ul></div>`; }).join('');
                 otherDriversHtml = otherDrivers.map(d => { const team = getTeamById(d.teamId); const teamNameDisplay = team ? ` (${team.name})` : ' (Free Agent)'; let cardClasses = ['card']; return `<div class="${cardClasses.join(' ')}"><h3>${d.name}${teamNameDisplay}</h3><ul><li>Skill: ${d.skill}</li><li>Quali: ${d.qualyPace}</li><li>Race: ${d.racePace}</li><li>Cons: ${d.consistency}</li><li>Ovr: ${d.overtaking}</li><li>Def: ${d.defending}</li><li>Cost: $${formatNumber(d.cost)}</li></ul></div>`; }).join('');
                 el.innerHTML = playerDriversHtml + otherDriversHtml;
            } else if (isInitialSelection) {
                 const driversToDisplay = currentDrivers.sort((a,b) => b.skill - a.skill);
                 el.innerHTML = driversToDisplay.map(d => { const isSelectedPlayerDriver = selectedDriverIds.includes(d.id); let cardClasses = ['card']; let buttonHtml = ''; const alreadySelected = selectedDriverIds.includes(d.id); const teamFull = selectedDriverIds.length >= 2; const canAfford = budget >= d.cost || alreadySelected; const isDisabled = (!alreadySelected && teamFull) || (!alreadySelected && !canAfford); let buttonText = 'Select Driver'; if (alreadySelected) buttonText = 'Deselect'; else if (teamFull) buttonText = 'Team Full'; else if (!canAfford) buttonText = 'Cannot Afford'; buttonHtml = `<button data-driver-id="${d.id}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>`; if (isDisabled && !alreadySelected) cardClasses.push('disabled'); if (isSelectedPlayerDriver) cardClasses.push('player-team'); return `<div class="${cardClasses.join(' ')}"><h3>${d.name}</h3><ul><li>Skill: ${d.skill}</li><li>Quali: ${d.qualyPace}</li><li>Race: ${d.racePace}</li><li>Cons: ${d.consistency}</li><li>Ovr: ${d.overtaking}</li><li>Def: ${d.defending}</li><li>Cost: $${formatNumber(d.cost)}</li></ul>${buttonHtml}</div>`; }).join('');
                el.querySelectorAll('button:not(:disabled)').forEach(b => { b.addEventListener('click', () => handleDriverSelection(parseInt(b.dataset.driverId))); });
            } else { /* Fallback for other potential list renderings, currently unused */ el.innerHTML = currentDrivers.sort((a,b) => b.skill - a.skill).map(d => { const team = getTeamById(d.teamId); const teamNameDisplay = team ? ` (${team.name})` : ' (Free Agent)'; return `<div class="card"><h3>${d.name}${teamNameDisplay}</h3><ul><li>Skill: ${d.skill}</li>...</ul></div>`; }).join(''); }
        }
        function renderCarsAndDevelopment() {
            const scd = document.getElementById('selected-car-display'); const ocl = document.getElementById('opponent-cars-list'); const carNameEl = document.getElementById('car-name-placeholder'); const carYearEl = document.getElementById('car-year-placeholder'); const carStatsList = document.getElementById('car-stats-list');
            if (scd && selectedCar && carStatsList) { if(carNameEl) carNameEl.textContent = selectedCar.name; if(carYearEl) carYearEl.textContent = currentSeasonYear; renderPlayerCarStats(selectedCar, carStatsList); }
            else if (scd) { if(carNameEl) carNameEl.textContent = 'N/A'; if(carYearEl) carYearEl.textContent = 'N/A'; if(carStatsList) carStatsList.innerHTML = '<li class="placeholder-text">No car selected.</li>'; }
            renderCarDevelopmentChart(); // Render NEW chart
            renderCarUpgradeOptions(); renderNextSeasonInvestmentOptions();
            if (ocl) renderOpponentCars(ocl);
        }
        function renderPlayerCarStats(car, listElement) { if (!listElement) return; const globalStat = calculateCarGlobalStat(car); const maxStat = MAX_STAT_VALUE_PLAYER; listElement.innerHTML = `<li><span>Engine:</span> <span>${car.engine} / ${maxStat}</span></li><li><span>Aerodynamics:</span> <span>${car.aero} / ${maxStat}</span></li><li><span>Chassis:</span> <span>${car.chassis} / ${maxStat}</span></li><li><span>Reliability:</span> <span>${car.reliability} / ${maxStat}</span></li><li class="global-stat"><span>Overall Rating:</span> <span>${globalStat}</span></li>`; }
        function renderCarUpgradeOptions() {
            const uo = document.getElementById('car-upgrade-options'); if (!uo) return; if (selectedCar === null) { uo.innerHTML = '<p class="placeholder-text">Select your team and drivers first.</p>'; return; }
            uo.innerHTML = UpgradesData.map(u => { const isPurchased = purchasedUpgrades[u.id]; const canAfford = budget >= u.cost; const statCap = (selectedCar && selectedCar[u.effect.stat] >= MAX_STAT_VALUE_PLAYER); const isDisabled = isPurchased || !canAfford || statCap; let buttonText = 'Purchase Upgrade'; if (isPurchased) { buttonText = 'Purchased'; } else if (statCap) { buttonText = 'Stat Maxed'; } else if (!canAfford) { buttonText = 'Insufficient Funds'; } const statNameDisplay = u.effect.stat.charAt(0).toUpperCase() + u.effect.stat.slice(1); return `<div class="card ${isDisabled ? 'disabled' : ''}"><h3>${u.name}</h3><ul><li>Cost: $${formatNumber(u.cost)}</li><li>Effect: +${u.effect.value} ${statNameDisplay}</li></ul><button data-upgrade-id="${u.id}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button></div>`; }).join('');
            uo.querySelectorAll('button:not(:disabled)').forEach(b => { b.addEventListener('click', () => handleCarUpgrade(parseInt(b.dataset.upgradeId))); });
        }
        function renderNextSeasonInvestmentOptions() {
            const container = document.getElementById('next-season-investment-options'); if (!container) return;
            container.innerHTML = NextSeasonInvestmentOptions.map(opt => { const isSelected = playerInvestedStat === opt.targetStat; const canAfford = budget >= opt.cost; const investmentLocked = playerInvestedStat !== null && !isSelected; const isDisabled = isSelected || !canAfford || investmentLocked; let buttonText = 'Select Focus'; if (isSelected) { buttonText = 'Focus Selected'; } else if (investmentLocked) { buttonText = 'Focus Chosen'; } else if (!canAfford) { buttonText = 'Insufficient Funds'; } return `<div class="card investment-option ${isSelected ? 'investment-selected' : ''} ${isDisabled && !isSelected ? 'disabled' : ''}"><h3>${opt.name}</h3><ul><li>Cost: $${formatNumber(opt.cost)}</li><li>Effect: ${opt.description}</li></ul><button data-investment-stat="${opt.targetStat}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button></div>`; }).join('');
            container.querySelectorAll('button:not(:disabled)').forEach(button => { button.addEventListener('click', () => handleNextSeasonInvestment(button.dataset.investmentStat)); });
        }
        function renderOpponentCars(div) {
             div.innerHTML = currentEcuries.filter(e => e.id !== selectedEcurieId).sort((a, b) => calculateCarGlobalStat(getCarById(b.defaultCarId)) - calculateCarGlobalStat(getCarById(a.defaultCarId))).map(ecurie => { const oppCar = getCarById(ecurie.defaultCarId); if (!oppCar) return ''; const upgradeInfo = lastAIRaceUpgrades[oppCar.id]; const aiBudget = aiTeamBudgets[ecurie.id] || 0; const globalStat = calculateCarGlobalStat(oppCar); const statDisplay = (statName) => { let display = `${oppCar[statName]}`; if (upgradeInfo && upgradeInfo.stat === statName) { display += ` <span class="stat-increase">(+${upgradeInfo.change})</span>`; } return display; }; return `<div class="card disabled"><h3>${ecurie.name}'s ${oppCar.name}</h3><ul><li>Est. Budget: $${formatNumber(aiBudget)}</li><li>Engine: ${statDisplay('engine')}</li><li>Aero: ${statDisplay('aero')}</li><li>Chassis: ${statDisplay('chassis')}</li><li>Reliability: ${statDisplay('reliability')}</li><li class="global-stat">Overall: ${globalStat}</li></ul></div>`; }).join('');
        }
        function renderSeasonStandings(yearToShow = 'current') {
            const sl = document.getElementById('season-standings-list'); const si = document.getElementById('season-info'); const chartCanvas = document.getElementById('standings-line-chart-canvas'); const chartPlaceholder = document.getElementById('standings-chart-placeholder'); const listTitle = document.getElementById('standings-list-title'); const historySelect = document.getElementById('history-season-select');
            if (!sl || !si || !chartCanvas || !chartPlaceholder || !listTitle || !historySelect) return;
            let standingsData = []; let displayYear = currentSeasonYear; let isHistoryView = false;
            const existingOptions = Array.from(historySelect.options).map(opt => opt.value); const historyYears = Object.keys(seasonHistory).sort((a,b) => b-a); let optionsChanged = false;
            historyYears.forEach(year => { if (!existingOptions.includes(year)) { const option = document.createElement('option'); option.value = year; option.textContent = year; historySelect.appendChild(option); optionsChanged = true; } });
            if (optionsChanged && historySelect.value !== 'current') { historySelect.value = 'current'; }
            if (yearToShow === 'current' || !seasonHistory[yearToShow]) {
                standingsData = Object.entries(driverSeasonScores).map(([driverId, points]) => ({ driver: getDriverById(driverId), points: points || 0 })).filter(item => item.driver).sort((a, b) => b.points - a.points || a.driver.name.localeCompare(b.driver.name));
                displayYear = currentSeasonYear; listTitle.textContent = `Driver Standings (${displayYear})`; let seasonStatusText = `${currentSeasonYear} Season`;
                if (gameState === 'SEASON_END' || (gameState === 'DRIVER_MARKET' && currentRaceIndex === 0)) { seasonStatusText += ' - Final Standings'; } else if (currentRaceIndex === 0 && gameState !== 'DRIVER_MARKET') { seasonStatusText += ' - Pre-Season'; } else { seasonStatusText += ` - After Race ${currentRaceIndex} / ${totalRacesInSeason}`; } si.textContent = seasonStatusText;
                renderStandingsLineChart(standingsData, chartCanvas, chartPlaceholder);
                isHistoryView = false; // Flag for current view
            } else {
                standingsData = seasonHistory[yearToShow]; displayYear = yearToShow; isHistoryView = true; listTitle.textContent = `Driver Standings (${displayYear} Final)`; si.textContent = `${displayYear} Season - Final Standings (History)`;
                chartCanvas.style.display = 'none'; chartPlaceholder.style.display = 'block'; chartPlaceholder.textContent = 'Points progression chart is only available for the current season.'; if (standingsChartInstance) { standingsChartInstance.destroy(); standingsChartInstance = null; }
            }
            if (standingsData.length > 0) {
                sl.innerHTML = standingsData.map((item, index) => {
                    const position = index + 1;
                    const teamNameDisplay = isHistoryView ? ` (${item.teamName || 'Unknown Team'})` : ` (${getTeamById(item.driver?.teamId)?.name || 'Unknown Team'})`;
                    const driverName = isHistoryView ? item.driverName : item.driver?.name;
                    // *** Player Highlighting Logic ***
                    const isPlayerDriver = isHistoryView
                        ? (item.teamId === selectedEcurieId) // Check team ID in history view
                        : selectedDriverIds.includes(item.driver?.id); // Check driver IDs in current view

                    return `<li class="${isPlayerDriver ? 'player-driver' : ''}">
                                <span class="position-number">${position}.</span>
                                <span>${driverName}${teamNameDisplay}</span>
                                <span>${item.points} Pts</span>
                            </li>`;
                }).join('');
            } else {
                sl.innerHTML = `<li class="placeholder-text">No standings data available for ${displayYear}.</li>`;
            }
        }
        function renderStandingsLineChart(sortedScores, canvasElement, placeholderElement) {
             if (!Chart) { console.error("Chart.js not loaded!"); placeholderElement.textContent = 'Error loading chart library.'; placeholderElement.style.display = 'block'; canvasElement.style.display = 'none'; return; }
             if (gameState === 'DRIVER_MARKET' || gameState === 'SEASON_END' || currentRaceIndex === 0 ) { placeholderElement.textContent = 'Complete the first race of the current season to see the chart.'; placeholderElement.style.display = 'block'; canvasElement.style.display = 'none'; if (standingsChartInstance) { standingsChartInstance.destroy(); standingsChartInstance = null; } return; }
             placeholderElement.style.display = 'none'; canvasElement.style.display = 'block';
             if (standingsChartInstance) { standingsChartInstance.destroy(); } const ctx = canvasElement.getContext('2d'); const raceCountForLabels = Math.max(1, currentRaceIndex); const labels = Array.from({ length: raceCountForLabels }, (_, i) => `R${i + 1}`);
             const datasets = sortedScores.slice(0, 10).map((item, index) => { const driverId = item.driver.id; const history = driverRaceHistory[driverId] || []; const color = generateChartColors(index); const dataPoints = labels.map((_, raceIdx) => { return history[raceIdx] !== undefined && history[raceIdx] !== null ? history[raceIdx] : (raceIdx === 0 ? 0 : null); }); return { label: item.driver.name, data: dataPoints, borderColor: color, backgroundColor: color + '80', tension: 0.1, fill: false, pointRadius: 3, pointHoverRadius: 5, borderWidth: 2, }; });
             standingsChartInstance = new Chart(ctx, { type: 'line', data: { labels: labels, datasets: datasets }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: '#e0e0e0', boxWidth: 15, padding: 15 } }, tooltip: { mode: 'index', intersect: false, backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#ff8700', bodyColor: '#ffffff', }, title: { display: false } }, scales: { x: { title: { display: true, text: 'Race Number', color: '#ccc' }, ticks: { color: '#ccc' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { title: { display: true, text: 'Total Points', color: '#ccc' }, beginAtZero: true, ticks: { color: '#ccc' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } } } } });
         }
        function renderCarDevelopmentChart() {
            const container = document.getElementById('car-dev-chart-container');
            const canvasElement = document.getElementById('car-dev-line-chart-canvas');
            const placeholderElement = document.getElementById('car-dev-chart-placeholder');
            if (!container || !canvasElement || !placeholderElement || !Chart) return;

            // Only show chart after the first race is complete
            if (currentRaceIndex < 1 && gameState !== 'SEASON_END' && gameState !== 'DRIVER_MARKET') {
                container.style.display = 'none'; // Keep container hidden
                placeholderElement.style.display = 'block';
                canvasElement.style.display = 'none';
                if (carDevChartInstance) { carDevChartInstance.destroy(); carDevChartInstance = null; }
                return;
            }

            container.style.display = 'block'; // Show container
            placeholderElement.style.display = 'none';
            canvasElement.style.display = 'block';

            if (carDevChartInstance) { carDevChartInstance.destroy(); }

            const ctx = canvasElement.getContext('2d');
            // Labels: Start, R1, R2... up to the *current* race index (state AFTER race i)
            const labels = ["Start"].concat(Array.from({ length: currentRaceIndex }, (_, i) => `R${i + 1}`));

            const datasets = currentEcuries.map((team, index) => {
                const history = carPerformanceHistory[team.id] || [];
                const color = generateChartColors(index);
                const isPlayer = team.id === selectedEcurieId;
                // Ensure data length matches label length, using null for future/missing points
                // Data represents state AT THE END of that index (index 0 = start, index 1 = after R1, etc.)
                const dataPoints = labels.map((_, idx) => history[idx] !== undefined ? history[idx] : null);

                return {
                    label: team.name,
                    data: dataPoints,
                    borderColor: isPlayer ? '#ff8700' : color, // Highlight player
                    backgroundColor: (isPlayer ? '#ff8700' : color) + '80',
                    tension: 0.1,
                    fill: false,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: isPlayer ? 3 : 1.5, // Make player line thicker
                };
            }).sort((a, b) => { // Sort player to top, then by last known rating
                 if (a.label === teamName) return -1; // Player first
                 if (b.label === teamName) return 1;
                 // Find last valid data point for sorting
                 const lastA = a.data.slice().reverse().find(val => val !== null);
                 const lastB = b.data.slice().reverse().find(val => val !== null);
                 return (lastB || 0) - (lastA || 0); // Sort descending by last known rating
            });

            carDevChartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: '#e0e0e0', boxWidth: 12, padding: 10, font: { size: 10 } }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: '#ff8700',
                            bodyColor: '#ffffff',
                        },
                        title: { display: false }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Race Weekend', color: '#ccc' },
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'Overall Car Rating', color: '#ccc' },
                            beginAtZero: false, // Start near the actual values
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
        function renderCalendar() { const cl = document.getElementById('calendar-list'); const ci = document.getElementById('calendar-info'); if (!cl || !ci) return; ci.textContent = `${currentSeasonYear} Race Schedule: ${currentRaceIndex}/${totalRacesInSeason} completed.`; if (currentSeasonCalendar.length === 0) { cl.innerHTML = `<li class="placeholder-text">Calendar will be generated at season start.</li>`; return; } cl.innerHTML = currentSeasonCalendar.map((race, index) => { const isCompleted = index < currentRaceIndex; const isNextRace = index === currentRaceIndex && gameState !== 'SEASON_END' && gameState !== 'DRIVER_MARKET'; let liClasses = []; if (isCompleted) liClasses.push('completed'); if (isNextRace) liClasses.push('next-race'); return `<li class="${liClasses.join(' ')}"><span class="race-name">${index + 1}. ${race.name} (${race.laps} Laps)</span><ul class="race-details"><li>Track Type: ${getTrackType(race)}</li><li>Key Focus: Spd ${race.speedFocus} / Hnd ${race.handlingFocus} / Rel ${race.reliabilityStress}</li></ul></li>`; }).join(''); }
        function renderQualifyingResults(stage, results) {
             const listEl = document.querySelector(`#${stage}-results ol`); if (!listEl) return;
             const placeholder = listEl.querySelector('.placeholder-text'); if(placeholder) placeholder.remove();
             listEl.innerHTML = results.map((r, i) => {
                 const team = getTeamById(r.driver.teamId);
                 const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : '';
                 // Format the time (which is now in ms)
                 const timeStr = formatTimeMs(r.time);
                 const isPlayer = selectedDriverIds.includes(r.driver.id);
                 let position = i + 1;
                 return `<li class="${isPlayer ? 'player-driver' : ''}">${position}. ${r.driver.name}${teamAbbr} - <span class="time-display">${timeStr}</span></li>`;
             }).join('');
             if (stage === 'q1' || stage === 'q2') {
                 const cutoff = (stage === 'q1') ? 15 : 10;
                 listEl.querySelectorAll('li').forEach((li, i) => { if (i >= cutoff) li.style.opacity = '0.6'; });
             }
         }
        function renderStartingGrid() { const gridEl = document.querySelector('#starting-grid ol'); if (!gridEl) return; const placeholder = gridEl.querySelector('.placeholder-text'); if(placeholder) placeholder.remove(); gridEl.innerHTML = startingGrid.map((pos, i) => { const team = getTeamById(pos.driver.teamId); const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : ''; const isPlayer = selectedDriverIds.includes(pos.driver.id); return `<li class="${isPlayer ? 'player-driver' : ''}">${i + 1}. ${pos.driver.name}${teamAbbr}</li>`; }).join(''); }
        function renderLiveLeaderboard() { const lbEl = document.querySelector('#live-leaderboard ol'); const lcEl = document.getElementById('live-lap-counter'); const currentRace = currentSeasonCalendar[currentRaceIndex]; const totalLaps = currentRace ? currentRace.laps : 0; if (!lbEl || !lcEl) return; lcEl.textContent = `Lap: ${currentLap} / ${totalLaps}`; raceLeaderboard.sort((a, b) => { const statusOrder = { 'Racing': 1, 'Finished': 2, 'DNF': 3 }; if (statusOrder[a.status] !== statusOrder[b.status]) { return statusOrder[a.status] - statusOrder[b.status]; } if (a.lapsCompleted !== b.lapsCompleted) { return b.lapsCompleted - a.lapsCompleted; } return a.totalRaceTime - b.totalRaceTime; }); const leader = raceLeaderboard.find(e => e.status === 'Racing' || e.status === 'Finished'); lbEl.innerHTML = raceLeaderboard.map((entry, index) => { const team = getTeamById(entry.driver.teamId); const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : ''; const isPlayer = selectedDriverIds.includes(entry.driver.id); let statusText = entry.status === 'DNF' ? ' <span class="status-dnf">(DNF)</span>' : ''; let gapText = ''; if (entry.status === 'Racing' || entry.status === 'Finished') { if (entry === leader) { gapText = `Leader`; } else if (leader) { if (leader.lapsCompleted > entry.lapsCompleted) { const lapDiff = leader.lapsCompleted - entry.lapsCompleted; gapText = `+${lapDiff} Lap${lapDiff > 1 ? 's' : ''}`; } else { const timeDiffMs = entry.totalRaceTime - leader.totalRaceTime; gapText = `+${(timeDiffMs / 1000).toFixed(3)}s`; } } else { gapText = "-"; } } else if (entry.status === 'DNF') { gapText = `(DNF Lap ${entry.lapsCompleted})`; } return `<li class="${isPlayer ? 'player-driver' : ''}"><span>${index + 1}. ${entry.driver.name}${teamAbbr}${statusText}</span><span class="gap-display">${gapText}</span></li>`; }).join(''); }
        function renderFinalRaceResults(finalLeaderboard, raceName, totalPrizeMoney) {
            const resEl = document.getElementById('race-results'); const listEl = resEl?.querySelector('ol'); const msgEl = resEl?.querySelector('#race-message'); const prizeLEl = resEl?.querySelector('#prize-money-earned ul'); const prizeTEl = resEl?.querySelector('#prize-money-earned p'); const placeholder = document.getElementById('final-results-placeholder'); if (!resEl || !listEl || !msgEl || !prizeLEl || !prizeTEl || !placeholder) return;
            placeholder.style.display = 'none'; resEl.style.display = 'block'; resEl.querySelector('h3').textContent = `Final Results: ${raceName} (${currentSeasonYear})`;
            finalLeaderboard.sort((a, b) => { const statusOrder = { 'Finished': 1, 'DNF': 2 }; if (statusOrder[a.status] !== statusOrder[b.status]) return statusOrder[a.status] - statusOrder[b.status]; if (a.lapsCompleted !== b.lapsCompleted) return b.lapsCompleted - a.lapsCompleted; if (a.status === 'Finished' && b.status === 'Finished') return a.totalRaceTime - b.totalRaceTime; return 0; });
            listEl.innerHTML = finalLeaderboard.map((entry, index) => { const position = index + 1; const isPlayerDriver = selectedDriverIds.includes(entry.driver.id); const team = getTeamById(entry.driver.teamId); const teamAbbr = team ? ` (${team.name.substring(0, 3).toUpperCase()})` : ''; let driverText = `${entry.driver.name}${teamAbbr}`; let pointsText = ''; let detailText = ''; if (entry.status === 'Finished') { if (index < PointsSystem.length) { pointsText = ` (+${PointsSystem[index]} pts)`; } } else if (entry.status === 'DNF') { driverText += ` <span class="status-dnf">(DNF)</span>`; detailText = ` (Lap ${entry.lapsCompleted})`; } return `<li class="${isPlayerDriver ? 'player-driver' : ''}">${driverText}${detailText}${pointsText}</li>`; }).join('');
            msgEl.textContent = `Race finished. Points and prize money awarded. Check Standings tab for updates.`; let playerPrizeHtml = '';
            finalLeaderboard.forEach((entry, index) => { if (entry.status === 'Finished' && selectedDriverIds.includes(entry.driver.id)) { const pos = index + 1; let breakdownItems = []; const pointsAwarded = (index < PointsSystem.length) ? PointsSystem[index] : 0; const moneyPoints = pointsAwarded * PRIZE_MONEY_PER_POINT; if (moneyPoints > 0) { breakdownItems.push(`$${formatNumber(moneyPoints)} (Pts)`); } const moneyPodium = (pos <= 3) ? PRIZE_MONEY_PODIUM_BONUS : 0; if (moneyPodium > 0) { breakdownItems.push(`$${formatNumber(moneyPodium)} (Podium)`); } const moneyTop10 = (pos <= 10) ? PRIZE_MONEY_TOP_10_BONUS : 0; if (moneyTop10 > 0 && moneyPodium === 0) { breakdownItems.push(`$${formatNumber(moneyTop10)} (Top 10)`); } const moneyP11_P20 = (pos > 10 && pos <= 20) ? PRIZE_MONEY_P11_P20_BONUS : 0; if (moneyP11_P20 > 0) { breakdownItems.push(`$${formatNumber(moneyP11_P20)} (P11-P20)`); } if (breakdownItems.length > 0) { playerPrizeHtml += `<li>${entry.driver.name} (${getOrdinalSuffix(pos)}): ${breakdownItems.join(' + ')}</li>`; } } });
            prizeLEl.innerHTML = playerPrizeHtml || '<li>No prize money earned this race.</li>'; prizeTEl.textContent = `Total Earned: $${formatNumber(totalPrizeMoney)}`;
        }
        function renderNotifications() { const listEl = document.getElementById('notifications-list'); if (!listEl) return; const placeholder = listEl.querySelector('.placeholder'); if (notificationsLog.length === 0) { listEl.innerHTML = '<li class="placeholder">No notifications yet.</li>'; return; } if (placeholder) placeholder.remove(); listEl.innerHTML = notificationsLog.map(note => { return `<li class="${note.typeClass || ''}"><span class="timestamp">[${note.timestamp}]</span><span class="event-type">${note.type.toUpperCase()}:</span>${note.message}</li>`; }).join(''); }
        function renderDriverMarket() { const marketListDiv = document.getElementById('driver-market-list'); if (!marketListDiv) return; document.getElementById('market-season-year').textContent = currentSeasonYear; const baseDrivers = JSON.parse(JSON.stringify(DriversData)); const statsToCompare = ['qualyPace', 'racePace', 'consistency', 'overtaking', 'defending', 'skill']; let currentMarketCost = marketSelectedDriverIds.reduce((sum, id) => sum + (getDriverById(id)?.cost || 0), 0); let displayBudget = budget - currentMarketCost; document.getElementById('budget-display').textContent = `Budget Available: $${formatNumber(displayBudget)}`; marketListDiv.innerHTML = currentDrivers.sort((a, b) => b.skill - a.skill).map(driver => { const isCurrentPlayerDriver = selectedDriverIds.includes(driver.id); const isSelectedInMarket = marketSelectedDriverIds.includes(driver.id); const canAfford = displayBudget >= driver.cost || isSelectedInMarket; const slotsFull = marketSelectedDriverIds.length >= 2; let buttonText = 'Select Driver'; let buttonDisabled = false; let cardClasses = ['card']; if (isSelectedInMarket) { buttonText = 'Deselect'; cardClasses.push('market-selected'); } else if (slotsFull) { buttonText = 'Team Full'; buttonDisabled = true; } else if (!canAfford) { buttonText = 'Cannot Afford'; buttonDisabled = true; } if (isCurrentPlayerDriver) { cardClasses.push('market-current-player'); } if (buttonDisabled && !isSelectedInMarket) { cardClasses.push('disabled'); } const baseDriver = baseDrivers.find(bd => bd.id === driver.id); let statChangesHtml = {}; if (baseDriver) { statChangesHtml = statsToCompare.map(stat => { const diff = driver[stat] - baseDriver[stat]; if (diff === 0) return { stat: stat, html: '' }; const sign = diff > 0 ? '+' : ''; const changeClass = diff > 0 ? 'positive' : 'negative'; return { stat: stat, html: `<span class="stat-change ${changeClass}" title="vs Base">(${sign}${diff})</span>` }; }).reduce((acc, curr) => { acc[curr.stat] = curr.html; return acc; }, {}); } const getChange = (statName) => statChangesHtml[statName] || ''; return `<div class="${cardClasses.join(' ')}"><h3>${driver.name}</h3><ul><li>Cost: $${formatNumber(driver.cost)}</li><li>Skill: ${driver.skill} ${getChange('skill')}</li><li>Quali: ${driver.qualyPace} ${getChange('qualyPace')}</li><li>Race: ${driver.racePace} ${getChange('racePace')}</li><li>Cons: ${driver.consistency} ${getChange('consistency')}</li><li>Ovr: ${driver.overtaking} ${getChange('overtaking')}</li><li>Def: ${driver.defending} ${getChange('defending')}</li></ul><button data-driver-id="${driver.id}" ${buttonDisabled ? 'disabled' : ''}>${buttonText}</button></div>`; }).join(''); marketListDiv.querySelectorAll('button').forEach(button => { if (!button.disabled) { button.addEventListener('click', () => handleDriverMarketSelection(parseInt(button.dataset.driverId))); } }); document.getElementById('confirm-drivers-button').disabled = marketSelectedDriverIds.length !== 2; }
        function renderAllTabs() { renderCarsAndDevelopment(); renderDriversList('drivers-list-management', false); renderSeasonStandings(); renderCalendar(); renderNotifications(); }
        function updateRaceHQButtonState() { const qb = document.getElementById('run-qualifying-button'); const srb = document.getElementById('start-race-button'); const acb = document.getElementById('accelerate-race-button'); const ngb = document.getElementById('next-gp-button'); const nsb = document.getElementById('next-season-button'); const raceControls = document.getElementById('race-controls'); qb.style.display = 'none'; srb.style.display = 'none'; acb.style.display = 'none'; ngb.style.display = 'none'; nsb.style.display = 'none'; if (!raceControls) return; if (gameState === 'SEASON_END') { nsb.style.display = 'inline-block'; nsb.disabled = false; } else if (gameState === 'MANAGEMENT' && currentRaceIndex >= totalRacesInSeason) { gameState = 'SEASON_END'; updateRaceHQButtonState(); } else if (gameState === 'MANAGEMENT' && raceCompletedForCurrentIndex) { ngb.style.display = 'inline-block'; ngb.disabled = false; } else if (gameState === 'MANAGEMENT' && startingGrid.length > 0 && !raceCompletedForCurrentIndex) { srb.style.display = 'inline-block'; acb.style.display = 'inline-block'; const raceInProgress = raceIntervalId !== null; srb.disabled = raceInProgress; acb.disabled = raceInProgress; } else if (gameState === 'MANAGEMENT' && startingGrid.length === 0) { qb.style.display = 'inline-block'; qb.disabled = false; const raceName = currentSeasonCalendar[currentRaceIndex]?.name || 'Next Race'; qb.textContent = `Run Qualifying: ${raceName}`; } else { qb.style.display = 'none'; srb.style.display = 'none'; acb.style.display = 'none'; ngb.style.display = 'none'; nsb.style.display = 'none'; } }
        function clearQualifyingUI() { const stages = ['q1', 'q2', 'q3']; stages.forEach(stage => { const listEl = document.querySelector(`#${stage}-results ol`); if(listEl) listEl.innerHTML = `<li class="placeholder-text">${stage === 'q1' ? 'Run qualifying to see results.' : ''}</li>`; }); const gridEl = document.querySelector('#starting-grid ol'); if(gridEl) gridEl.innerHTML = `<li class="placeholder-text"></li>`; document.getElementById('qualifying-title').textContent = 'Qualifying'; }

        // --- UI Interaction Handlers ---

        function handleBudgetSelection(amount) { budget = amount; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; showMessage(`Budget set to $${formatNumber(amount)}`, 'success', 2000); document.getElementById('initial-budget-selection').style.display = 'none'; renderEcurieSelection(); document.getElementById('ecurie-selection').style.display = 'grid'; }
        function handleEcurieSelection(ecurieId) { const selectedEcurie = getTeamById(ecurieId); if (!selectedEcurie) { showMessage("Team not found.", 'error'); return; } if (budget < selectedEcurie.cost) { showMessage("Insufficient funds for this team.", 'error'); return; } selectedEcurieId = ecurieId; budget -= selectedEcurie.cost; teamName = selectedEcurie.name; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; selectedCar = getCarById(selectedEcurie.defaultCarId); if (!selectedCar) { console.error(`Initial car (ID: ${selectedEcurie.defaultCarId}) not found for ${teamName}`); } showMessage(`${selectedEcurie.name} selected! Cost: $${formatNumber(selectedEcurie.cost)}`, 'success'); document.getElementById('ecurie-selection').style.display = 'none'; document.getElementById('initial-driver-selection').style.display = 'block'; document.getElementById('drivers-title').textContent = `Select Two Drivers for ${teamName}`; renderDriversList('drivers-list', true); }
        function handleDriverSelection(driverId) { const driverToSelect = getDriverById(driverId); if (!driverToSelect) return; const isSelected = selectedDriverIds.includes(driverId); if (isSelected) { selectedDriverIds = selectedDriverIds.filter(id => id !== driverId); budget += driverToSelect.cost; showMessage(`${driverToSelect.name} deselected. Budget +$${formatNumber(driverToSelect.cost)}`, 'info', 2000); } else { if (selectedDriverIds.length >= 2) { showMessage("Team already full (Max 2 drivers). Deselect one first.", 'error'); return; } if (budget < driverToSelect.cost) { showMessage(`Insufficient funds for ${driverToSelect.name}. Need $${formatNumber(driverToSelect.cost)}`, 'error'); return; } selectedDriverIds.push(driverId); budget -= driverToSelect.cost; showMessage(`${driverToSelect.name} selected! Budget -$${formatNumber(driverToSelect.cost)}`, 'success', 2000); } document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; renderDriversList('drivers-list', true); if (selectedDriverIds.length === 2) { showMessage("Team complete! Initializing game management...", 'success', 2500); document.getElementById('drivers-list').querySelectorAll('button').forEach(b => b.disabled = true); setTimeout(initializeGameAfterSetup, 1500); } }
        function handleCarUpgrade(upgradeId) {
            const upgrade = UpgradesData.find(up => up.id === upgradeId); if (!upgrade || !selectedCar) return; if (purchasedUpgrades[upgrade.id]) { showMessage("Upgrade already purchased.", 'info'); return; } if (budget < upgrade.cost) { showMessage("Insufficient funds for this upgrade.", 'error'); return; } const stat = upgrade.effect.stat; if (selectedCar[stat] >= MAX_STAT_VALUE_PLAYER) { showMessage(`${stat.charAt(0).toUpperCase() + stat.slice(1)} is already maxed out.`, 'info'); return; } budget -= upgrade.cost; const currentValue = selectedCar[stat]; const newValue = clamp(currentValue + upgrade.effect.value, 50, MAX_STAT_VALUE_PLAYER); const actualChange = newValue - currentValue;
             if (actualChange > 0) { selectedCar[stat] = newValue; purchasedUpgrades[upgrade.id] = true; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; showMessage(`${upgrade.name} purchased! ${stat} +${actualChange}.`, 'success'); addNotification(`Player upgraded ${upgrade.name} (+${actualChange} ${stat})`, 'upgrade'); renderCarsAndDevelopment(); }
             else { budget += upgrade.cost; showMessage(`Upgrade ${upgrade.name} provided no benefit. Purchase cancelled.`, 'info'); document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; }
        }
        function handleNextSeasonInvestment(targetStat) {
            const selectedInvestment = NextSeasonInvestmentOptions.find(opt => opt.targetStat === targetStat); if (!selectedInvestment) { console.error("Selected investment stat not found:", targetStat); return; } if (playerInvestedStat !== null) { showMessage("You have already chosen an R&D focus for next season.", "info"); return; } if (budget < selectedInvestment.cost) { showMessage("Insufficient funds for this R&D focus.", "error"); return; }
            budget -= selectedInvestment.cost; playerInvestedStat = targetStat; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; showMessage(`Selected ${selectedInvestment.name}! (-$${formatNumber(selectedInvestment.cost)})`, 'success'); addNotification(`Player focused R&D on ${targetStat.toUpperCase()} for next season.`, 'investment'); renderNextSeasonInvestmentOptions();
        }
        function handleDriverMarketSelection(driverId) { const driver = getDriverById(driverId); if (!driver) return; const isSelected = marketSelectedDriverIds.includes(driverId); let otherDriversCost = marketSelectedDriverIds.filter(id => id !== driverId).reduce((sum, id) => sum + (getDriverById(id)?.cost || 0), 0); let availableBudget = budget - otherDriversCost; if (isSelected) { marketSelectedDriverIds = marketSelectedDriverIds.filter(id => id !== driverId); showMessage(`${driver.name} deselected.`, 'info'); } else { if (marketSelectedDriverIds.length >= 2) { showMessage("Deselect a driver first (Max 2).", 'error'); return; } if (availableBudget < driver.cost) { showMessage(`Insufficient funds for ${driver.name}. Need $${formatNumber(driver.cost)}, Available: $${formatNumber(availableBudget)}`, 'error'); return; } marketSelectedDriverIds.push(driverId); showMessage(`${driver.name} selected!`, 'success'); } renderDriverMarket(); }
        function handleConfirmDriverSelection() { if (marketSelectedDriverIds.length !== 2) { showMessage("You must select exactly two drivers.", "error"); return; } const previousPlayerDrivers = [...selectedDriverIds]; selectedDriverIds = [...marketSelectedDriverIds]; let finalBudget = budget; selectedDriverIds.forEach(id => { const driver = getDriverById(id); if (driver) finalBudget -= driver.cost; }); budget = finalBudget; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; const playerTeam = getTeamById(selectedEcurieId); if (playerTeam) playerTeam.driverIds = selectedDriverIds; selectedDriverIds.forEach(id => { const driver = getDriverById(id); if (driver) driver.teamId = selectedEcurieId; }); assignAIDriversRanked(); generateDriverChangeNotifications(previousPlayerDrivers); gameState = 'MANAGEMENT'; document.getElementById('driver-market-screen').style.display = 'none'; document.getElementById('team-management-screen').style.display = 'block'; resetSeasonState(true); showMessage(`Team confirmed for the ${currentSeasonYear} season! Check Notifications for transfers.`, 'success', 4000); updateRaceHQButtonState(); renderAllTabs(); activateTab('development'); activateRaceSubTab('qualifying'); }
        function setupTabs() { document.querySelectorAll('.tab-button').forEach(button => { button.addEventListener('click', () => activateTab(button.dataset.tab)); }); }
        function activateTab(targetTab) { if (gameState === 'DRIVER_MARKET') { showMessage("Confirm your driver selection first.", "info"); return; } if (raceIntervalId && targetTab !== 'race') { showMessage("Cannot switch tabs during live race simulation. Finish or wait.", "info"); activateTab('race'); activateRaceSubTab('live'); return; } document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none'); const activeButton = document.querySelector(`.tab-button[data-tab="${targetTab}"]`); const activeContent = document.getElementById(`${targetTab}-tab`); if (activeButton) activeButton.classList.add('active'); if (activeContent) activeContent.style.display = 'block'; if (targetTab === 'development') renderCarsAndDevelopment(); if (targetTab === 'drivers') renderDriversList('drivers-list-management', false); if (targetTab === 'standings') renderSeasonStandings(); if (targetTab === 'calendar') renderCalendar(); if (targetTab === 'notifications') renderNotifications(); if (targetTab === 'race') { updateRaceHQButtonState(); const raceSubTabs = document.querySelectorAll('#race-tab .sub-tab-button'); const activeSubTab = document.querySelector('#race-tab .sub-tab-button.active'); if (!activeSubTab && raceSubTabs.length > 0) { activateRaceSubTab(raceSubTabs[0].dataset.subtab); } } }
        function setupRaceSubTabs() { document.querySelectorAll('#race-tab .sub-tab-button').forEach(button => { button.addEventListener('click', () => { if (raceIntervalId && button.dataset.subtab !== 'live') { showMessage("Cannot switch sub-tabs during live race simulation.", "info"); return; } activateRaceSubTab(button.dataset.subtab); }); }); }
        function activateRaceSubTab(targetSubTab) { document.querySelectorAll('#race-tab .sub-tab-button').forEach(btn => btn.classList.remove('active')); document.querySelectorAll('#race-tab .sub-tab-content').forEach(content => content.classList.remove('active')); const activeButton = document.querySelector(`#race-tab .sub-tab-button[data-subtab="${targetSubTab}"]`); const activeContent = document.getElementById(`race-${targetSubTab}-subtab-content`); if (activeButton) activeButton.classList.add('active'); if (activeContent) activeContent.classList.add('active'); const livePlaceholder = document.getElementById('live-race-placeholder'); const finalPlaceholder = document.getElementById('final-results-placeholder'); const liveAreaVisible = document.getElementById('live-race-area').style.display !== 'none'; const finalAreaVisible = document.getElementById('race-results').style.display !== 'none'; if (livePlaceholder) livePlaceholder.style.display = (targetSubTab === 'live' && !liveAreaVisible) ? 'block' : 'none'; if (finalPlaceholder) finalPlaceholder.style.display = (targetSubTab === 'final' && !finalAreaVisible) ? 'block' : 'none'; }
        function setupHistoryDropdown() { const historySelect = document.getElementById('history-season-select'); if (historySelect) { historySelect.addEventListener('change', (event) => { renderSeasonStandings(event.target.value); }); } }

        // --- Simulation Logic ---

        function calculateCarGlobalStat(car) { if (!car) return 0; const stats = ['engine', 'aero', 'chassis', 'reliability']; let weightedSum = 0; let totalWeight = 0; stats.forEach(stat => { const weight = GLOBAL_STAT_WEIGHTS[stat] || 0; weightedSum += (car[stat] || 0) * weight; totalWeight += weight; }); return totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0; }
        function calculateQualifyingPerformance(driver, car, track) {
            let timeMs = QUALI_BASE_TIME_MS;
            // Subtract time for better stats (higher = faster = less time)
            timeMs -= (driver.qualyPace - 80) * QUALI_DRIVER_TIME_FACTOR; // Adjust base if needed
            timeMs -= (car.engine - 80) * QUALI_CAR_ENGINE_TIME_FACTOR * (track.speedFocus / 85);
            timeMs -= (car.aero - 80) * QUALI_CAR_AERO_TIME_FACTOR * ((track.speedFocus + track.handlingFocus) / 170);
            timeMs -= (car.chassis - 80) * QUALI_CAR_CHASSIS_TIME_FACTOR * (track.handlingFocus / 85);
            // Add random variation
            const randomVariation = (Math.random() * 2 - 1) * QUALI_RANDOM_MS_FACTOR;
            timeMs += randomVariation;
            return Math.max(60000, timeMs); // Ensure a minimum realistic time (e.g., 1 minute)
        }
        function calculateLapTime(driver, car, track, isCurrentlyLeader) { let baseTime = LAPTIME_BASE_MS; baseTime += (track.speedFocus - 85) * -4; baseTime += (track.handlingFocus - 85) * -3; let driverFactor = (driver.racePace - 85) * LAPTIME_DRIVER_PACE_FACTOR; let engineFactor = (car.engine - 85) * LAPTIME_CAR_ENGINE_FACTOR * (track.speedFocus / 85); let aeroFactor = (car.aero - 85) * LAPTIME_CAR_AERO_FACTOR * ((track.speedFocus + track.handlingFocus) / 170); let chassisFactor = (car.chassis - 85) * LAPTIME_CAR_CHASSIS_FACTOR * (track.handlingFocus / 85); let consistencyRange = (100 - driver.consistency) * LAPTIME_CONSISTENCY_FACTOR; let consistencyVariation = (Math.random() * 2 - 1) * consistencyRange; let lapTime = baseTime - driverFactor - engineFactor - aeroFactor - chassisFactor + consistencyVariation; let eventTimeAdjustment = 0; let eventHappened = false; const randomEventCheck = Math.random(); if (randomEventCheck < MAJOR_MISTAKE_CHANCE) { const penalty = MAJOR_MISTAKE_MIN_TIME_MS + Math.random() * (MAJOR_MISTAKE_MAX_TIME_MS - MAJOR_MISTAKE_MIN_TIME_MS); eventTimeAdjustment = penalty; eventHappened = true; const mistakeMsg = `Major Mistake: ${driver.name} lost significant time! (+${(penalty/1000).toFixed(2)}s)`; const leaderMsg = isCurrentlyLeader ? " (Race Leader!)" : ""; addNotification(mistakeMsg + leaderMsg, 'error'); } else if (!eventHappened && randomEventCheck < MAJOR_MISTAKE_CHANCE + MINOR_MISTAKE_CHANCE) { const penalty = MINOR_MISTAKE_BASE_TIME_MS + (100 - driver.consistency) * MINOR_MISTAKE_CONSISTENCY_SCALE * Math.random(); eventTimeAdjustment = penalty; eventHappened = true; } else if (!eventHappened && randomEventCheck > (1.0 - BOOST_CHANCE)) { const gain = BOOST_MIN_TIME_MS + Math.random() * (BOOST_MAX_TIME_MS - BOOST_MIN_TIME_MS); eventTimeAdjustment = -gain; eventHappened = true; } lapTime += eventTimeAdjustment; lapTime += (Math.random() - 0.5) * 30; return Math.max(10000, lapTime); }
        function checkReliability(driver, car, track) { if (dnfCountThisRace >= maxDnfThisRace) return false; const targetReliability = 85 + (100 - track.reliabilityStress); let dnfChance = RACE_RELIABILITY_DNF_BASE_CHANCE; if (car.reliability < targetReliability) { dnfChance += (targetReliability - car.reliability) * RACE_RELIABILITY_STAT_FACTOR; } dnfChance += (100 - track.reliabilityStress) * RACE_RELIABILITY_TRACK_FACTOR; dnfChance += (Math.random() - 0.4) * 0.0005; dnfChance = Math.max(0.0002, Math.min(0.025, dnfChance)); if (Math.random() < dnfChance) { return true; } return false; }
        function attemptOvertake(atkEntry, defEntry, track, currentLap) { if (!atkEntry || !defEntry || atkEntry.status !== 'Racing' || defEntry.status !== 'Racing' || currentLap <= 1) return false; if (atkEntry.lapsCompleted !== defEntry.lapsCompleted) return false; const gapMs = defEntry.totalRaceTime - atkEntry.totalRaceTime; const lapTimeDiffMs = defEntry.lastLapTime - atkEntry.lastLapTime; if (gapMs > 0 && gapMs < OVERTAKE_GAP_THRESHOLD_MS && lapTimeDiffMs > OVERTAKE_LAPTIME_DIFF_THRESHOLD_MS) { const a = atkEntry.driver, cA = atkEntry.car; const d = defEntry.driver, cD = defEntry.car; let skillFactor = (a.overtaking - d.defending) * RACE_OVERTAKE_SKILL_FACTOR; let carFactor = ((cA.engine - cD.engine) * RACE_CAR_OVERTAKE_ENGINE_FACTOR + (cA.aero - cD.aero) * RACE_CAR_OVERTAKE_AERO_FACTOR) * (track.speedFocus / 85); let overtakeChance = RACE_OVERTAKE_BASE_CHANCE + skillFactor + carFactor; const randomFluctuation = (Math.random() * 2 - 1) * OVERTAKE_RANDOM_FACTOR * overtakeChance; overtakeChance += randomFluctuation; overtakeChance = Math.max(0.05, Math.min(0.95, overtakeChance)); return Math.random() < overtakeChance; } return false; }
        function randomizeCarStats() { addNotification("Randomizing end-of-season car stats (influenced by R&D Focus)...", 'stats'); const carStatKeys = ['engine', 'aero', 'chassis', 'reliability']; const baseCars = JSON.parse(JSON.stringify(CarsData)); currentCars.forEach(car => { const baseCar = baseCars.find(bc => bc.id === car.id); if (!baseCar) return; const team = currentEcuries.find(t => t.defaultCarId === car.id); let investedStat = null; if (team) { investedStat = (team.id === selectedEcurieId) ? playerInvestedStat : (aiTeamInvestedStats[team.id] || null); } let changesLog = []; carStatKeys.forEach(stat => { let minChange, maxChange; if (stat === investedStat) { minChange = INVESTED_STAT_CHANGE_MIN; maxChange = INVESTED_STAT_CHANGE_MAX; } else { minChange = BASE_STAT_CHANGE_MIN; maxChange = BASE_STAT_CHANGE_MAX; } const change = randomizeBetween(minChange, maxChange); const oldValue = car[stat]; let newValue = clamp(baseCar[stat] + change, 50, MAX_STAT_VALUE_AI); if (team && team.id === selectedEcurieId) { newValue = clamp(newValue, 50, MAX_STAT_VALUE_PLAYER); } car[stat] = newValue; if (car[stat] !== oldValue) { const sign = car[stat] > oldValue ? '+' : ''; const focusIndicator = (stat === investedStat) ? ' (Focus)' : ''; changesLog.push(`${stat.charAt(0).toUpperCase() + stat.slice(1)} ${sign}${car[stat] - oldValue}${focusIndicator}`); } }); if (changesLog.length > 0) { addNotification(`Car ${team?.name || 'Unknown'}'s ${car.name} base stats changed: ${changesLog.join(', ')}.`, 'stats'); } if (team && team.id === selectedEcurieId) { Object.keys(purchasedUpgrades).forEach(upgradeId => { const upgrade = UpgradesData.find(u => u.id === parseInt(upgradeId)); if (upgrade && car[upgrade.effect.stat] !== undefined) { const stat = upgrade.effect.stat; const valueBeforeReapply = car[stat]; car[stat] = clamp(valueBeforeReapply + upgrade.effect.value, 50, MAX_STAT_VALUE_PLAYER); } }); selectedCar = car; } }); if (selectedEcurieId) { const playerTeamCarId = getTeamById(selectedEcurieId)?.defaultCarId; if(playerTeamCarId) selectedCar = getCarById(playerTeamCarId); } addNotification("Car stat randomization complete. Player upgrades re-applied.", 'stats'); }
        function randomizeDriverStats() {
            addNotification("Randomizing end-of-season driver stats and costs...", 'stats');
            const driverStatKeys = ['qualyPace', 'racePace', 'consistency', 'overtaking', 'defending', 'skill'];
            const originalDriversData = JSON.parse(JSON.stringify(DriversData)); // Get original base data

            currentDrivers.forEach(driver => {
                const baseDriver = originalDriversData.find(d => d.id === driver.id);
                if (!baseDriver) return; // Should not happen if data is consistent

                let changesLog = [];
                let oldSkill = driver.skill; // Store skill before changes this round

                driverStatKeys.forEach(stat => {
                    const change = randomizeBetween(-2, 2);
                    const oldValue = driver[stat];
                    driver[stat] = clamp(oldValue + change, 50, 100); // Apply change to *current* value, then clamp
                    if (driver[stat] !== oldValue) {
                        let statName = stat.replace('Pace', ' Pace');
                        statName = statName.charAt(0).toUpperCase() + statName.slice(1);
                        changesLog.push(`${statName} ${driver[stat] > oldValue ? '+' : ''}${driver[stat] - oldValue}`);
                    }
                });

                // Calculate Cost Change based on Skill change *relative to original base*
                const skillChangeVsBase = driver.skill - baseDriver.skill;
                const costAdjustment = skillChangeVsBase * DRIVER_COST_SKILL_FACTOR;
                const oldCost = driver.cost;
                // Apply adjustment to original base cost, then clamp
                driver.cost = clamp(baseDriver.cost + costAdjustment, DRIVER_MIN_COST, Infinity); // Apply min cost

                if (driver.cost !== oldCost) {
                    const costDiff = driver.cost - oldCost;
                    const costSign = costDiff > 0 ? '+' : '';
                    changesLog.push(`Cost ${costSign}$${formatNumber(Math.abs(costDiff))}`);
                    // Notify player if their driver's cost changed significantly
                    if (selectedDriverIds.includes(driver.id) && Math.abs(costDiff) > 0) {
                        addNotification(`${driver.name}'s contract cost changed to $${formatNumber(driver.cost)} (${costSign}$${formatNumber(Math.abs(costDiff))}) for next season.`, 'transfer');
                    }
                }

                if (changesLog.length > 0) {
                    addNotification(`Driver ${driver.name}'s stats/cost changed: ${changesLog.join(', ')}`, 'stats');
                }
            });
            addNotification("Driver stat and cost randomization complete.", 'stats');
        }
        function runQualifyingStage(participants, numToAdvance, stageName) {
            const currentRace = currentSeasonCalendar[currentRaceIndex];
            // Calculate time in milliseconds now
            let results = participants.map(p => ({
                driver: p.driver,
                car: p.car,
                time: calculateQualifyingPerformance(p.driver, p.car, currentRace) // Returns ms
            }));
            results.sort((a, b) => a.time - b.time); // Lower time is better
            qualifyingResults[stageName] = results.map(r => ({...r}));
            renderQualifyingResults(stageName, results); // Renders using the time (ms)
            return results.slice(0, numToAdvance);
        }
        function determineStartingGrid() { startingGrid = []; startingGrid = qualifyingResults.q3.map(r => ({ driver: r.driver, car: r.car })); const q2FinishersNotInQ3 = qualifyingResults.q2.filter(q2r => !startingGrid.some(sgr => sgr.driver.id === q2r.driver.id)); startingGrid = startingGrid.concat(q2FinishersNotInQ3.map(r => ({ driver: r.driver, car: r.car }))); const q1FinishersNotInQ2 = qualifyingResults.q1.filter(q1r => !startingGrid.some(sgr => sgr.driver.id === q1r.driver.id)); startingGrid = startingGrid.concat(q1FinishersNotInQ2.map(r => ({ driver: r.driver, car: r.car }))); }
        function runRaceLap() { const track = currentSeasonCalendar[currentRaceIndex]; currentLap++; const currentLeaderEntry = raceLeaderboard.find(e => e.status === 'Racing' || e.status === 'Finished'); raceLeaderboard.forEach((entry) => { if (entry.status === 'Racing') { if (checkReliability(entry.driver, entry.car, track)) { entry.status = 'DNF'; entry.lastLapTime = Infinity; entry.lapsCompleted = currentLap - 1; dnfCountThisRace++; const leaderMsg = (entry === currentLeaderEntry) ? " (Race Leader!)" : ""; addNotification(`${entry.driver.name} DNF on lap ${entry.lapsCompleted + 1}${leaderMsg}`, 'error'); } else { const isLeader = (entry === currentLeaderEntry); const lapTime = calculateLapTime(entry.driver, entry.car, track, isLeader); entry.lastLapTime = lapTime; entry.totalRaceTime += lapTime; entry.lapsCompleted = currentLap; } } else { if (entry.status === 'DNF') entry.lastLapTime = Infinity; } }); for (let i = raceLeaderboard.length - 2; i >= 0; i--) { const attackerEntry = raceLeaderboard[i + 1]; const defenderEntry = raceLeaderboard[i]; if (attemptOvertake(attackerEntry, defenderEntry, track, currentLap)) { [raceLeaderboard[i], raceLeaderboard[i + 1]] = [raceLeaderboard[i + 1], raceLeaderboard[i]]; } } }
        function endRaceSimulationPostProcessing() {
            const raceIdx = currentRaceIndex; // Capture index of the race that just finished (0-based)
            const currentRace = currentSeasonCalendar[raceIdx];
            const raceName = currentRace?.name || "Unknown Race";
            showMessage(`Race Finished: ${raceName}! Calculating results...`, 'success', 3000);
            raceLeaderboard.forEach(e => { if (e.status === 'Racing') e.status = 'Finished'; });
            const finalSortedBoard = [...raceLeaderboard];
            finalSortedBoard.sort((a, b) => { const statusOrder = { 'Finished': 1, 'DNF': 2 }; if (statusOrder[a.status] !== statusOrder[b.status]) return statusOrder[a.status] - statusOrder[b.status]; if (a.lapsCompleted !== b.lapsCompleted) return b.lapsCompleted - a.lapsCompleted; if (a.status === 'Finished' && b.status === 'Finished') return a.totalRaceTime - b.totalRaceTime; return 0; });
            let playerMoneyEarned = 0;
            finalSortedBoard.forEach((entry, finalPositionIndex) => { const driverId = entry.driver.id; const teamId = entry.driver.teamId; let pointsAwarded = 0; let moneyPoints = 0; let moneyPodium = 0; let moneyTop10 = 0; let moneyP11_P20 = 0; const position = finalPositionIndex + 1; if (entry.status === 'Finished') { if (finalPositionIndex < PointsSystem.length) { pointsAwarded = PointsSystem[finalPositionIndex]; driverSeasonScores[driverId] = (driverSeasonScores[driverId] || 0) + pointsAwarded; moneyPoints = pointsAwarded * PRIZE_MONEY_PER_POINT; } if (position <= 3) { moneyPodium = PRIZE_MONEY_PODIUM_BONUS; } if (position <= 10) { moneyTop10 = PRIZE_MONEY_TOP_10_BONUS; } else if (position <= 20) { moneyP11_P20 = PRIZE_MONEY_P11_P20_BONUS; } } if (!driverRaceHistory[driverId]) { driverRaceHistory[driverId] = Array(totalRacesInSeason).fill(null); } driverRaceHistory[driverId][raceIdx] = driverSeasonScores[driverId] || 0; const totalMoney = moneyPoints + moneyPodium + moneyTop10 + moneyP11_P20; if (totalMoney > 0) { if (teamId === selectedEcurieId) { playerMoneyEarned += totalMoney; } else if (aiTeamBudgets.hasOwnProperty(teamId)) { aiTeamBudgets[teamId] = (aiTeamBudgets[teamId] || 0) + totalMoney; } } });
            Object.keys(driverSeasonScores).forEach(driverIdStr => { const driverId = parseInt(driverIdStr); if (!driverRaceHistory[driverId]) { driverRaceHistory[driverId] = Array(totalRacesInSeason).fill(null); } for (let i = 0; i <= raceIdx; i++) { if (driverRaceHistory[driverId][i] === null || driverRaceHistory[driverId][i] === undefined) { driverRaceHistory[driverId][i] = (i > 0 ? (driverRaceHistory[driverId][i - 1] || 0) : 0); } } });
            budget += playerMoneyEarned; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`;
            if (playerMoneyEarned > 0) { addNotification(`Player earned $${formatNumber(playerMoneyEarned)} prize money this race.`, 'upgrade'); }
            runAIUpgradePhase(); generateAIUpgradeNotifications();

            // Record Car Performance History AFTER upgrades
            currentEcuries.forEach(team => {
                 const teamHistory = carPerformanceHistory[team.id];
                 if (!teamHistory) {
                     console.error(`Missing history init for team ${team.id}`);
                     carPerformanceHistory[team.id] = [calculateCarGlobalStat(getCarById(team.defaultCarId))]; // Attempt recovery
                     return; // Skip recording for this race if init failed
                 }
                 const car = getCarById(team.defaultCarId);
                 const currentRating = calculateCarGlobalStat(car);
                 // Store the rating *after* the completed race. Index `raceIdx + 1` corresponds to the state AFTER this race.
                 // Ensure array is long enough, pad with previous value if necessary
                 while (teamHistory.length <= raceIdx + 1) {
                     const lastRating = teamHistory.length > 0 ? teamHistory[teamHistory.length - 1] : null;
                     teamHistory.push(lastRating);
                 }
                 teamHistory[raceIdx + 1] = currentRating;
             });

            raceCompletedForCurrentIndex = true;
            renderFinalRaceResults(finalSortedBoard, raceName, playerMoneyEarned);
            renderAllTabs(); // Render all tabs AFTER results and history are processed
            updateRaceHQButtonState();
            document.getElementById('live-race-area').style.display = 'none';
            document.getElementById('live-race-placeholder').style.display = 'block';
            activateRaceSubTab('final');
        }
        function runAIUpgradePhase() { lastAIRaceUpgrades = {}; currentEcuries.forEach(team => { if (team.id === selectedEcurieId || !aiTeamBudgets.hasOwnProperty(team.id)) return; const teamId = team.id; const currentAIBudget = aiTeamBudgets[teamId]; const currentAIUpgrades = aiTeamUpgrades[teamId] || {}; const aiCar = getCarById(team.defaultCarId); if (!aiCar || currentAIBudget <= 0) return; const affordableUpgrades = UpgradesData.filter(u => !currentAIUpgrades[u.id] && u.cost <= currentAIBudget ).sort((a, b) => b.cost - a.cost); if (affordableUpgrades.length > 0) { const upgradeToBuy = affordableUpgrades[0]; const stat = upgradeToBuy.effect.stat; if (aiCar[stat] < MAX_STAT_VALUE_AI) { aiTeamBudgets[teamId] -= upgradeToBuy.cost; currentAIUpgrades[upgradeToBuy.id] = true; aiTeamUpgrades[teamId] = currentAIUpgrades; const currentValue = aiCar[stat]; const newValue = clamp(currentValue + upgradeToBuy.effect.value, 50, MAX_STAT_VALUE_AI); const actualChange = newValue - currentValue; if (actualChange > 0) { aiCar[stat] = newValue; lastAIRaceUpgrades[aiCar.id] = { stat: stat, change: actualChange }; } else { aiTeamBudgets[teamId] += upgradeToBuy.cost; delete currentAIUpgrades[upgradeToBuy.id]; aiTeamUpgrades[teamId] = currentAIUpgrades; } } } }); }
        function generateAIUpgradeNotifications() { Object.entries(lastAIRaceUpgrades).forEach(([carIdStr, upgradeInfo]) => { const carId = parseInt(carIdStr); const car = currentCars.find(c => c.id === carId); const team = currentEcuries.find(t => t.defaultCarId === car?.id); if (team && car && upgradeInfo.change > 0) { addNotification(`${team.name}'s ${car.name} improved ${upgradeInfo.stat} (+${upgradeInfo.change})`, 'upgrade'); } }); }
        function runAIInvestmentPhase() { aiTeamInvestedStats = {}; currentEcuries.forEach(team => { if (team.id === selectedEcurieId || !aiTeamBudgets.hasOwnProperty(team.id)) return; const teamId = team.id; const budget = aiTeamBudgets[teamId] || 0; const aiCar = getCarById(team.defaultCarId); let chosenStat = null; if (!aiCar) return; const affordableOptions = NextSeasonInvestmentOptions.filter(opt => budget >= opt.cost); if (affordableOptions.length > 0) { const stats = ['engine', 'aero', 'chassis', 'reliability']; let sortedStats = stats.map(stat => ({ name: stat, value: aiCar[stat] })).sort((a, b) => a.value - b.value); for (const statInfo of sortedStats) { const investmentOption = affordableOptions.find(opt => opt.targetStat === statInfo.name); if (investmentOption) { chosenStat = investmentOption.targetStat; aiTeamBudgets[teamId] -= investmentOption.cost; addNotification(`${team.name} focused R&D on ${chosenStat.toUpperCase()} for next season.`, 'investment'); break; } } if (!chosenStat) { /* No investment or fallback needed */ } } aiTeamInvestedStats[teamId] = chosenStat; }); }
        function assignAIDriversRanked() { currentEcuries.forEach(team => { if (team.id !== selectedEcurieId) { team.driverIds = []; } }); currentDrivers.forEach(driver => { if (!selectedDriverIds.includes(driver.id)) { driver.teamId = null; } }); const aiTeams = currentEcuries.filter(t => t.id !== selectedEcurieId); const rankedTeams = aiTeams.map(team => { const car = getCarById(team.defaultCarId); const score = calculateCarGlobalStat(car); return { team, score }; }).sort((a, b) => b.score - a.score); let availableDrivers = currentDrivers.filter(d => d.teamId === null).sort((a, b) => b.skill - a.skill); rankedTeams.forEach(({ team }) => { if (availableDrivers.length < 2) { if(availableDrivers.length === 1){ const d = availableDrivers.shift(); d.teamId = team.id; team.driverIds.push(d.id); } return; } const driver1 = availableDrivers.shift(); const driver2 = availableDrivers.shift(); driver1.teamId = team.id; driver2.teamId = team.id; team.driverIds.push(driver1.id, driver2.id); }); if (availableDrivers.length > 0) { console.error("ERROR: Drivers left unassigned!", availableDrivers.map(d=>d.name)); } currentEcuries.forEach(team => { if (team.id !== selectedEcurieId && team.driverIds.length !== 2) { console.error(`ERROR: Team ${team.name} has ${team.driverIds.length} drivers!`); } }); }
        function generateDriverChangeNotifications(oldPlayerDrivers) { const droppedDrivers = oldPlayerDrivers.filter(id => !selectedDriverIds.includes(id)); const newDrivers = selectedDriverIds.filter(id => !oldPlayerDrivers.includes(id)); if (droppedDrivers.length === 0 && newDrivers.length === 0) { addNotification(`You kept the same driver lineup for ${currentSeasonYear}.`, 'transfer'); } else { droppedDrivers.forEach(id => { const driver = getDriverById(id); if(driver) addNotification(`You released ${driver.name}.`, 'transfer'); }); newDrivers.forEach(id => { const driver = getDriverById(id); if(driver) addNotification(`You signed ${driver.name} for ${currentSeasonYear}!`, 'transfer'); }); } addNotification(`--- AI Team Driver Updates for ${currentSeasonYear} ---`, 'info'); currentEcuries.forEach(team => { if (team.id !== selectedEcurieId) { const driverNames = team.driverIds.map(id => getDriverById(id)?.name || 'Unknown').join(' & '); addNotification(`${team.name}: ${driverNames}`, 'transfer'); } }); }

        // --- Game Flow Control ---

        function handleRunQualifyingSequence() { const currentRace = currentSeasonCalendar[currentRaceIndex]; if (!currentRace) { showMessage("Error: Race data not found.", "error"); return; } if (raceCompletedForCurrentIndex) { showMessage("Qualifying for this race already completed.", "info"); return; } showMessage(`Running Qualifying for ${currentRace.name}...`, 'info', 3000); document.getElementById('run-qualifying-button').disabled = true; clearQualifyingUI(); const participants = currentDrivers.filter(d => d.teamId !== null).map(drv => ({ driver: drv, car: getCarById(getTeamById(drv.teamId)?.defaultCarId) })).filter(p => p.car); if (participants.length < 2) { showMessage("Not enough participants with assigned cars.", "error"); document.getElementById('run-qualifying-button').disabled = false; return; } document.getElementById('qualifying-title').textContent = `Qualifying: ${currentRace.name}`; activateRaceSubTab('qualifying'); setTimeout(() => { const q1Advanced = runQualifyingStage(participants, 15, 'q1'); showMessage('Q1 Complete. Running Q2...', 'info', 1500); setTimeout(() => { const q2Advanced = runQualifyingStage(q1Advanced, 10, 'q2'); showMessage('Q2 Complete. Running Q3...', 'info', 1500); setTimeout(() => { runQualifyingStage(q2Advanced, 10, 'q3'); showMessage('Qualifying Complete! Starting Grid determined.', 'success', 2000); determineStartingGrid(); renderStartingGrid(); raceCompletedForCurrentIndex = false; updateRaceHQButtonState(); }, 1000); }, 1000); }, 500); }
        function startRaceSimulation() { if (startingGrid.length === 0) { showMessage("Run qualifying first.", "error"); return; } if (raceIntervalId) { showMessage("Race already in progress.", "info"); return; } const currentRace = currentSeasonCalendar[currentRaceIndex]; if (!currentRace) { showMessage("Error: Current race data not found.", "error"); return; } maxDnfThisRace = Math.floor(startingGrid.length * MAX_DNF_PER_RACE_PERCENT * (0.8 + Math.random() * 0.4)); showMessage(`Starting Race: ${currentRace.name}! (${currentRace.laps} Laps)`, 'info', 3000); document.getElementById('start-race-button').disabled = true; document.getElementById('accelerate-race-button').disabled = true; document.getElementById('live-race-area').style.display = 'block'; document.getElementById('live-race-placeholder').style.display = 'none'; document.getElementById('race-results').style.display = 'none'; document.getElementById('final-results-placeholder').style.display = 'block'; currentLap = 0; dnfCountThisRace = 0; raceLeaderboard = startingGrid.map(p => ({ driver: p.driver, car: p.car, status: 'Racing', totalRaceTime: 0, lastLapTime: 0, lapsCompleted: 0 })); renderLiveLeaderboard(); activateRaceSubTab('live'); raceIntervalId = setInterval(() => { const racingCars = raceLeaderboard.filter(p => p.status === 'Racing'); if (currentLap >= currentRace.laps || racingCars.length === 0) { endRaceSimulation(); return; } runRaceLap(); renderLiveLeaderboard(); }, RACE_UPDATE_INTERVAL_MS); }
        function handleAccelerateRace() { if (startingGrid.length === 0) { showMessage("Run qualifying first.", "error"); return; } if (raceIntervalId) { showMessage("Cannot accelerate while live race is running.", "info"); return; } const currentRace = currentSeasonCalendar[currentRaceIndex]; if (!currentRace) { showMessage("Error: Current race data not found.", "error"); return; } if (raceCompletedForCurrentIndex) { showMessage("Race already completed.", "info"); activateRaceSubTab('final'); return; } showMessage(`Accelerating Race: ${currentRace.name}... (This may take a moment)`, 'info', 2500); document.getElementById('start-race-button').disabled = true; document.getElementById('accelerate-race-button').disabled = true; document.getElementById('live-race-area').style.display = 'none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display = 'none'; document.getElementById('final-results-placeholder').style.display = 'block'; activateRaceSubTab('final'); setTimeout(() => { maxDnfThisRace = Math.floor(startingGrid.length * MAX_DNF_PER_RACE_PERCENT * (0.8 + Math.random() * 0.4)); dnfCountThisRace = 0; currentLap = 0; raceLeaderboard = startingGrid.map(p => ({ driver: p.driver, car: p.car, status: 'Racing', totalRaceTime: 0, lastLapTime: 0, lapsCompleted: 0 })); for (let lap = 1; lap <= currentRace.laps; lap++) { const racingCars = raceLeaderboard.filter(p => p.status === 'Racing'); if (racingCars.length === 0) { break; } runRaceLap(); } currentLap = raceLeaderboard.reduce((max, p) => Math.max(max, p.lapsCompleted), 0); endRaceSimulationPostProcessing(); }, 100); }
        function endRaceSimulation() { if (raceIntervalId) { clearInterval(raceIntervalId); raceIntervalId = null; } endRaceSimulationPostProcessing(); updateRaceHQButtonState(); }
        function handleNextRaceWeekend() { if (currentRaceIndex >= totalRacesInSeason - 1) { gameState = 'SEASON_END'; showMessage(`Final race complete! Season ${currentSeasonYear} concluded. Proceed to Next Season.`, 'success'); updateRaceHQButtonState(); return; } currentRaceIndex++; const nextRace = currentSeasonCalendar[currentRaceIndex]; showMessage(`Advancing to next race weekend: ${nextRace.name}`, 'info'); startingGrid = []; qualifyingResults = { q1: [], q2: [], q3: [] }; raceLeaderboard = []; if(raceIntervalId) clearInterval(raceIntervalId); raceIntervalId = null; dnfCountThisRace = 0; maxDnfThisRace = 0; raceCompletedForCurrentIndex = false; clearQualifyingUI(); document.getElementById('live-race-area').style.display = 'none'; document.getElementById('live-race-placeholder').style.display = 'block'; document.getElementById('race-results').style.display = 'none'; document.getElementById('final-results-placeholder').style.display = 'block'; updateRaceHQButtonState(); renderCalendar(); activateRaceSubTab('qualifying'); renderOpponentCars(document.getElementById('opponent-cars-list')); }
        function handleStartNextSeason() {
            if(raceIntervalId) clearInterval(raceIntervalId); raceIntervalId = null; gameState = 'SEASON_END';
            const finalStandingsForHistory = Object.entries(driverSeasonScores).map(([driverId, points]) => { const driver = getDriverById(driverId); const team = driver ? getTeamById(driver.teamId) : null; return { driverId: parseInt(driverId), driverName: driver ? driver.name : 'Unknown Driver', teamId: team ? team.id : null, teamName: team ? team.name : 'Unknown Team', points: points || 0 }; }).sort((a, b) => b.points - a.points || a.driverName.localeCompare(b.driverName));
            seasonHistory[currentSeasonYear] = finalStandingsForHistory;
            let playerPointsThisSeason = selectedDriverIds.reduce((sum, id) => sum + (driverSeasonScores[id] || 0), 0); const playerBonus = playerPointsThisSeason * PLAYER_BONUS_PER_POINT; const previousPlayerBudget = budget; budget += playerBonus; addNotification(`End of Season ${currentSeasonYear}. History saved. Points Bonus: $${formatNumber(playerBonus)}. New Budget: $${formatNumber(budget)}`, 'upgrade');
            Object.keys(aiTeamBudgets).forEach(teamIdStr => { const teamId = parseInt(teamIdStr); const team = getTeamById(teamId); if (team && team.id !== selectedEcurieId) { let teamPoints = team.driverIds.reduce((sum, driverId) => sum + (driverSeasonScores[driverId] || 0), 0); const aiBonus = teamPoints * AI_BONUS_PER_POINT; const currentAIBudget = aiTeamBudgets[teamId] || 0; aiTeamBudgets[teamId] = currentAIBudget + aiBonus; } });
            runAIInvestmentPhase(); // AI invests
            randomizeCarStats(); // Car stats change (using AI investment info)
            randomizeDriverStats(); // Driver stats AND costs change
            gameState = 'DRIVER_MARKET'; currentSeasonYear++; document.getElementById('budget-display').textContent = `Budget: $${formatNumber(budget)}`; showMessage(`End of Season ${currentSeasonYear - 1}. History saved, R&D focus applied, stats & costs randomized. Entering Driver Market for ${currentSeasonYear}...`, 'info', 5000);
            document.getElementById('team-management-screen').style.display = 'none'; document.getElementById('driver-market-screen').style.display = 'block'; marketSelectedDriverIds = [...selectedDriverIds]; renderDriverMarket(); updateRaceHQButtonState(); addNotification(`Entering Driver Market for ${currentSeasonYear} season. Select your team!`, 'transfer');
        }

        // --- Helper Functions ---

        function showMessage(message, type = 'info', duration = 3000) { const mb = document.getElementById('message-box'); if (!mb) return; if (mb.timeoutId) clearTimeout(mb.timeoutId); mb.textContent = message; mb.className = `message-box ${type} show`; mb.timeoutId = setTimeout(() => { mb.classList.remove('show'); mb.timeoutId = null; }, duration); }
        function formatNumber(n) { return n.toLocaleString('en-US'); }
        function formatTimeMs(ms) { // Formats milliseconds to M:SS.mmm
            if (ms === Infinity || typeof ms !== 'number' || isNaN(ms)) {
                return "N/A"; // Handle DNF or invalid times
            }
            const totalSeconds = ms / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const milliseconds = Math.floor(ms % 1000);
            return `${minutes}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }
        function getTeamById(id) { return currentEcuries.find(t => t.id === id); }
        function getDriverById(id) { const drvId = typeof id === 'string' ? parseInt(id) : id; return currentDrivers.find(d => d.id === drvId); }
        function getCarById(id) { return currentCars.find(c => c.id === id); }
        function getBaseCarDataById(id) { const baseCar = CarsData.find(c => c.id === id); return baseCar ? JSON.parse(JSON.stringify(baseCar)) : null; }
        function shuffleArray(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } }
        function getOrdinalSuffix(n) { const s = ["th", "st", "nd", "rd"], v = n % 100; return n + (s[(v - 20) % 10] || s[v] || s[0]); }
        function generateSeasonCalendar() { currentSeasonCalendar = JSON.parse(JSON.stringify(RacesData)); shuffleArray(currentSeasonCalendar); totalRacesInSeason = currentSeasonCalendar.length; }
        function clamp(value, min, max) { return Math.max(min, Math.min(value, max)); }
        function randomizeBetween(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function addNotification(message, type = 'info') { const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); let notificationTypeClass = ''; if (type === 'upgrade') notificationTypeClass = 'event-type-upgrade'; else if (type === 'transfer') notificationTypeClass = 'event-type-transfer'; else if (type === 'stats') notificationTypeClass = 'event-type-stats'; else if (type === 'error') notificationTypeClass = 'event-type-error'; else if (type === 'investment') notificationTypeClass = 'event-type-investment'; notificationsLog.unshift({ message, type, timestamp, typeClass: notificationTypeClass }); if (notificationsLog.length > MAX_NOTIFICATIONS) { notificationsLog.pop(); } const notificationsTab = document.getElementById('notifications-tab'); if (notificationsTab && notificationsTab.style.display === 'block') { renderNotifications(); } }
        function getTrackType(r) { if (r.speedFocus >= 95 && r.handlingFocus <= 80) return "High Speed"; if (r.handlingFocus >= 95 && r.speedFocus <= 80) return "High Handling"; if (r.speedFocus >= 90 && r.handlingFocus >= 90) return "Balanced Fast"; if (r.speedFocus <= 75 && r.handlingFocus <= 75) return "Balanced Slow"; if (r.speedFocus > r.handlingFocus + 10) return "Speed Focused"; if (r.handlingFocus > r.speedFocus + 10) return "Handling Focused"; return "Mixed"; }
        function generateChartColors(index) { const colors = [ '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#E7E9ED', '#83AFA7', '#EF5350', '#AB47BC', '#42A5F5', '#66BB6A', '#FFA726', '#78909C', '#EC407A', '#5C6BC0', '#26A69A', '#FFCA28', '#8D6E63', '#BDBDBD' ]; return colors[index % colors.length]; }

        // --- Start Game ---
        window.onload = initGame;

    </script>

</body>
</html>