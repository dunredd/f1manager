<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Manager</title>
    <!-- ADDED: Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* --- Global Styles & Dark Mode Variables --- */
        :root {
            --bg-color: #1e1e1e; --text-color: #e0e0e0; --heading-color: #f5f5f5; --header-bg: #2c2c2c; --tab-bg: #252525;
            --tab-active-bg: #2c2c2c; --tab-border: #444444; --card-bg: #2c2c2c; --card-border: #444444; --primary-color: #4dabf7;
            --secondary-color: #a0a0a0; --positive-color: #40c057; --negative-color: #f03e3e; --accent-color: #ff922b;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --border-radius: 6px; --hover-bg-color: #383838;
            --disabled-bg-color: #555; --disabled-text-color: #999; --disabled-border-color: #666;
            --grid-gap: 20px; /* Added grid gap variable */
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--bg-color); color: var(--text-color); display: flex; flex-direction: column; min-height: 100vh; font-size: 14px; }
        h1, h2, h3, h4 { color: var(--heading-color); margin-top: 0; } h2 { margin-bottom: 20px; border-bottom: 1px solid var(--tab-border); padding-bottom: 10px;} h3 { margin-bottom: 10px; }
        a { color: var(--primary-color); text-decoration: none; } a:hover { text-decoration: underline; }
        /* --- Setup Screen Styles --- */
        #game-setup { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 1000; color: var(--text-color); }
        .setup-content { background-color: var(--card-bg); padding: 30px 40px; border-radius: var(--border-radius); border: 1px solid var(--card-border); max-width: 600px; width: 90%; text-align: center; max-height: 90vh; overflow-y: auto;}
        .setup-content h2 { border-bottom: 1px solid var(--tab-border); padding-bottom: 15px; margin-bottom: 25px; }
        .setup-option { margin-bottom: 20px; text-align: left; } .setup-option label { display: block; margin-bottom: 8px; font-weight: bold; color: var(--secondary-color); }
        .setup-option select, .setup-option input[type="radio"] { margin-right: 5px; } .setup-option select { width: 100%; padding: 10px; background-color: #3a3a3a; color: var(--text-color); border: 1px solid var(--tab-border); border-radius: var(--border-radius); }
        .setup-option .radio-group label { display: inline-block; margin-right: 15px; font-weight: normal;} #start-game-btn { margin-top: 30px; width: 50%; padding: 12px; }
        /* --- Header --- */
        .main-header { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; padding: 10px 25px; background-color: var(--header-bg); border-bottom: 1px solid var(--tab-border); }
        .header-title { flex-basis: 100%; text-align: center; margin-bottom: 10px; } @media (min-width: 992px) { .header-title { flex-basis: auto; text-align: left; margin-bottom: 0;} }
        .header-title h1 { margin: 0; font-size: 1.5em; display: inline-block; margin-right: 15px; } .header-title span { font-size: 0.9em; color: var(--secondary-color); }
        .game-status { display: flex; flex-wrap: wrap; justify-content: center; flex-grow: 1; margin-right: 15px;}
        .game-status span { margin: 0 10px; font-size: 0.9em; white-space: nowrap;} .game-status strong { color: var(--primary-color); font-weight: bold; }
        #advance-time-btn { margin-left: auto; margin-top: 10px;} @media (min-width: 992px) { #advance-time-btn { margin-top: 0; } }
        /* --- Buttons --- */
        .btn { padding: 8px 15px; border: 1px solid transparent; border-radius: var(--border-radius); cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease, opacity 0.2s; text-align: center; font-weight: 500; }
        .btn:disabled, .btn.disabled { background-color: var(--disabled-bg-color) !important; color: var(--disabled-text-color) !important; cursor: not-allowed; opacity: 0.7; border-color: var(--disabled-border-color) !important; }
        .btn-primary { background-color: var(--primary-color); color: #000; border-color: var(--primary-color); } .btn-primary:hover:not(:disabled):not(.disabled) { background-color: #1c92e8; border-color: #1c92e8; }
        .btn-secondary { background-color: var(--secondary-color); color: var(--bg-color); border-color: var(--secondary-color); } .btn-secondary:hover:not(:disabled):not(.disabled) { background-color: #888888; border-color: #888888; }
        .btn-positive { background-color: var(--positive-color); color: #000; border-color: var(--positive-color); } .btn-positive:hover:not(:disabled):not(.disabled) { background-color: #2f9e44; border-color: #2f9e44; }
        .btn-negative { background-color: var(--negative-color); color: #fff; border-color: var(--negative-color); } .btn-negative:hover:not(:disabled):not(.disabled) { background-color: #e03131; border-color: #e03131; }
        .btn-sm { padding: 4px 8px; font-size: 0.8em; }
        /* --- Tabs --- */
        .tabs { overflow: hidden; background-color: var(--tab-bg); border-bottom: 1px solid var(--tab-border); }
        .tab-button { background-color: inherit; float: left; border: none; outline: none; cursor: pointer; padding: 12px 18px; transition: 0.3s; font-size: 0.95em; border-right: 1px solid var(--tab-border); color: var(--secondary-color); }
        .tab-button:last-child { border-right: none; } .tab-button:hover { background-color: var(--hover-bg-color); }
        .tab-button.active { background-color: var(--tab-active-bg); border-bottom: 3px solid var(--primary-color); color: var(--primary-color); font-weight: bold; }
        /* --- Main Content Area --- */
        #main-content { padding: 25px; background-color: var(--bg-color); flex-grow: 1; }
        .tab-content { display: none; animation: fadeEffect 0.5s; } .tab-content.active-content { display: block; }
        @keyframes fadeEffect { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* --- Grid Layout --- */
        .grid-container { display: grid; gap: var(--grid-gap); grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
        .overview-grid { grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); } .drivers-grid, .staff-grid { grid-template-columns: minmax(0, 3fr) minmax(0, 1fr); }
        /* MODIFIED: Car Dev Grid Layout */
        .car-dev-grid { grid-template-columns: 1fr; } /* Outer grid is single column */
        .car-dev-top-section { /* Container for stats & comparison table */
            display: grid;
            /* Force 2 columns until medium breakpoint */
            grid-template-columns: repeat(2, 1fr);
            gap: var(--grid-gap);
            align-items: start; /* Align items to the top */
        }
        @media (max-width: 992px) { /* Stack on medium screens and below */
            .car-dev-top-section {
                grid-template-columns: 1fr;
            }
        }
        .car-dev-sections-grid { /* Grid for upgrade sections */
             display: grid;
             gap: var(--grid-gap);
             grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
             margin-top: var(--grid-gap);
        }
        /* END MODIFIED */
        .infra-grid { grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); }
        .finance-grid { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); } .sponsor-offer-grid, .active-sponsor-grid { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
        .season-grid { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
        .leaderboard-grid { grid-template-columns: 1fr 1fr; } .race-sim-grid { grid-template-columns: 1fr; }
        /* --- Card Styles --- */
        .info-card, .development-section, .table-container { background-color: var(--card-bg); padding: 20px; border-radius: var(--border-radius); border: 1px solid var(--card-border); }
        .card-full-width { grid-column: 1 / -1; } .card-span-2 { grid-column: span 2; } .card-span-3 { grid-column: span 3; }
        .info-card h3, .development-section h3 { border-bottom: 1px solid var(--tab-border); padding-bottom: 8px; margin-bottom: 15px; font-size: 1.1em; }
        .info-card p, .info-card li { margin-bottom: 8px; line-height: 1.5; color: var(--secondary-color); } .info-card strong { color: var(--text-color); font-weight: bold; }
        .info-card ul { list-style: none; padding: 0; margin: 0; }
        /* --- Table Styles --- */
        .table-container { overflow-x: auto; } table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; }
        th, td { border: 1px solid var(--card-border); padding: 10px 12px; text-align: left; vertical-align: middle; white-space: nowrap; }
        th { background-color: #3a3a3a; font-weight: bold; color: var(--heading-color); position: sticky; top: 0; z-index: 1; }
        tbody tr { transition: background-color 0.15s ease; } tbody tr:hover { background-color: var(--hover-bg-color); }
        /* --- Specific Element Styles --- */
        #active-dev-overview li, #active-train-overview li { padding: 5px 0; border-bottom: 1px dotted var(--tab-border); color: var(--secondary-color); font-size: 0.9em; } #alerts-overview li { padding: 5px 0; color: var(--accent-color); font-weight: bold; } #active-dev-overview li:last-child, #active-train-overview li:last-child, #alerts-overview li:last-child { border-bottom: none; }
        .upgrade-card { border: 1px solid var(--card-border); padding: 15px; margin-bottom: 10px; border-radius: var(--border-radius); background-color: #353535; transition: background-color 0.2s; position: relative; min-height: 100px; } .upgrade-card:hover { background-color: var(--hover-bg-color); } .upgrade-card strong { display: block; margin-bottom: 5px; color: var(--heading-color); } .upgrade-card em { font-size: 0.9em; color: var(--secondary-color); display: block; margin-bottom: 8px;} .upgrade-status { font-weight: bold; display: block; margin-top: 5px; } .status-locked { color: var(--negative-color); } .status-available { color: var(--positive-color); } .status-applied { color: var(--secondary-color); font-style: italic; } .status-developing { color: var(--primary-color); } .upgrade-details span { margin-right: 10px; font-size: 0.85em; white-space: nowrap;} .upgrade-cost { color: var(--negative-color); font-weight: bold;} .upgrade-benefit { color: var(--positive-color); } .upgrade-duration { color: var(--secondary-color); } .upgrade-card .btn { position: absolute; bottom: 15px; right: 15px; }
        .infra-card { position: relative; min-height: 150px; } .infra-card .btn { position: absolute; bottom: 20px; right: 20px; } .infra-card p:last-of-type { margin-bottom: 45px; }
        .sponsor-offer, .active-sponsor-card { border-left: 4px solid var(--primary-color); background-color: #353535; margin-bottom: 15px; } .sponsor-offer.tier-1 { border-left-color: var(--accent-color); } .sponsor-objective { margin-top: 10px; padding-top: 10px; border-top: 1px dashed var(--card-border); } .objective-progress-bar { background-color: #555; border-radius: 3px; height: 8px; width: 100%; margin-top: 5px; overflow: hidden;} .objective-progress-bar div { background-color: var(--positive-color); height: 100%; border-radius: 3px; transition: width 0.3s ease;}
        #race-calendar-list { list-style: none; padding: 0; max-height: 400px; overflow-y: auto;} #race-calendar-list li { padding: 8px 10px; border-bottom: 1px solid var(--card-border); transition: background-color 0.15s ease; font-size: 0.95em; cursor: default;} #race-calendar-list li:hover { background-color: var(--hover-bg-color); } #race-calendar-list li.next-race { font-weight: bold; background-color: #3a3a3a; border-left: 3px solid var(--accent-color); color: var(--accent-color); padding-left: 7px; } #race-calendar-list li.completed-race { opacity: 0.6; } #race-calendar-list li.completed-race .result { float: right; font-size: 0.9em; color: var(--secondary-color);}
        /* Race Sim Area Adjustments */
        .race-data-area { background-color: var(--card-bg); padding: 15px; border: 1px solid var(--card-border); border-radius: var(--border-radius); min-height: 450px; display: flex; flex-direction: column; }
        #race-sim-leaderboard { flex-grow: 1; flex-shrink: 0; margin-bottom: 10px; }
        #race-sim-leaderboard p { font-size: 0.8em; margin-bottom: 3px; color: var(--secondary-color); white-space: nowrap; }
        #race-sim-leaderboard strong { color: var(--text-color); }
        #race-sim-events { height: 150px; overflow-y: scroll; list-style-type: none; padding-left: 0; margin-top: 10px; border-top: 1px solid var(--card-border); padding-top: 10px; font-size: 0.85em;} #race-sim-events li { padding: 3px 0; border-bottom: 1px dotted var(--tab-border);} #race-sim-events li:last-child { border-bottom: none;}
        #race-speed-controls { margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--tab-border); text-align: center; } #race-speed-controls button { margin: 0 5px; } #race-speed-controls button.active { background-color: var(--primary-color); color: #000; border: 1px solid var(--primary-color); }
        #player-strategy-area { margin-bottom: 20px; padding: 15px; border: 1px dashed var(--tab-border); border-radius: var(--border-radius); } #quali-results-area { margin-bottom: 20px; }
        /* Race Sim Tab - Result Table */
        #race-results-area { margin-bottom: 20px; }
        #race-results-area h3 { margin-bottom: 10px; }
        #pre-race-layout { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: var(--grid-gap); margin-bottom: var(--grid-gap); }
        #pre-race-layout > .info-card { margin-bottom: 0; }
        /* Driver Filter Styles */
        #driver-filters { display: flex; flex-wrap: wrap; gap: 15px; padding: 15px; background-color: var(--tab-bg); border-radius: var(--border-radius); margin-bottom: 20px; border: 1px solid var(--card-border); }
        #driver-filters label { font-weight: bold; color: var(--secondary-color); margin-right: 5px; white-space: nowrap; }
        #driver-filters input, #driver-filters select { padding: 6px 8px; background-color: #3a3a3a; color: var(--text-color); border: 1px solid var(--tab-border); border-radius: var(--border-radius); font-size: 0.9em; }
        #driver-filters input { flex-grow: 1; min-width: 150px; }
        #driver-filters select { min-width: 120px; }
        #driver-replacement-info { padding: 10px; background-color: rgba(77, 171, 247, 0.1); border: 1px dashed var(--primary-color); border-radius: var(--border-radius); margin-bottom: 15px; text-align: center; }
        /* Car Comparison Table Styles */
        #car-comparison-table th, #car-comparison-table td { padding: 8px 10px; font-size: 0.85em; text-align: center;} /* Centered text */
        #car-comparison-table th:first-child, #car-comparison-table td:first-child { text-align: left; } /* Align stat name left */
        #car-comparison-table .player-row td { background-color: rgba(77, 171, 247, 0.1); font-weight: bold; }
        #car-comparison-table .best-row td { background-color: rgba(64, 192, 87, 0.1); }
        #car-comparison-table .avg-row td { background-color: rgba(160, 160, 160, 0.1); }
        /* Car Comparison Chart Container */
        #car-comparison-chart-container {
            min-height: 400px; /* Increased height */
            max-height: 550px; /* Increased max-height */
            margin-top: 20px;
            padding: 15px;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            border: 1px solid var(--card-border);
        }
        /* Utility Classes */
        .text-positive { color: var(--positive-color) !important; } .text-negative { color: var(--negative-color) !important; } .text-accent { color: var(--accent-color) !important; } .text-secondary { color: var(--secondary-color) !important; } .text-light { color: var(--text-color) !important; } .text-large { font-size: 1.4em; font-weight: bold; color: var(--heading-color); } .text-center { text-align: center; } .bold { font-weight: bold; } .hidden { display: none !important; }
        /* --- Responsiveness --- */
        @media (max-width: 1200px) { .drivers-grid, .staff-grid, .season-grid, .leaderboard-grid { grid-template-columns: 1fr; } .card-span-2, .card-span-3 { grid-column: span 1; } }
        @media (max-width: 992px) { .main-header { flex-direction: column; align-items: stretch; } .game-status span { margin: 5px 5px;} #advance-time-btn { width: 100%; margin-left:0; } .car-dev-top-section { grid-template-columns: 1fr; } /* Stack comparison/stats on smaller screens */ }
        @media (max-width: 768px) { .game-status span { font-size: 0.85em; } .grid-container { grid-template-columns: 1fr; } .tabs { white-space: nowrap; overflow-x: auto; -webkit-overflow-scrolling: touch; } .tab-button { display: inline-block; float: none; } th, td { white-space: normal; } #driver-filters { flex-direction: column; align-items: stretch; } /* Stack pre-race columns on small screens */ #pre-race-layout { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <!-- === Game Setup Screen === -->
    <div id="game-setup">
        <div class="setup-content">
            <h2>New Game Setup</h2>
            <div class="setup-option">
                <label for="team-select">Choose Your Team:</label>
                <select id="team-select"> <option value="">-- Select Team --</option> </select>
            </div>
            <div class="setup-option">
                <label for="driver1-select">Choose Driver 1:</label>
                <select id="driver1-select"> <option value="">-- Select Driver 1 --</option> </select>
            </div>
            <div class="setup-option">
                <label for="driver2-select">Choose Driver 2:</label>
                <select id="driver2-select"> <option value="">-- Select Driver 2 --</option> </select>
            </div>
            <div class="setup-option">
                <label>Choose Difficulty (Starting Budget):</label>
                <div class="radio-group">
                    <!-- MODIFIED Budget Labels - Updated -->
                    <input type="radio" id="diff-easy" name="difficulty" value="easy" checked>
                    <label for="diff-easy">Easy ($50 000 000)</label>
                    <input type="radio" id="diff-medium" name="difficulty" value="medium">
                    <label for="diff-medium">Medium ($30 000 000)</label>
                    <input type="radio" id="diff-hard" name="difficulty" value="hard">
                    <label for="diff-hard">Hard ($5 000 000)</label>
                </div>
            </div>
            <button id="start-game-btn" class="btn btn-primary" onclick="startGame()">Start Game</button>
            <p id="setup-error" class="text-negative" style="margin-top: 15px; height: 1em;"></p>
        </div>
    </div>

    <!-- === Main Game UI (Initially Hidden) === -->
    <header class="main-header hidden"> <div class="header-title"><h1>F1 Manager Sim</h1><span id="player-team-header">[Player Team Name] - <span id="current-year-header">2025</span></span></div> <div class="game-status"><span>Stage: <strong id="current-stage-header">PreSeason</strong></span><span>Week: <strong id="current-week-header">0</strong></span><span>Next Race: <strong id="next-race-header">Bahrain GP</strong></span><span>Budget: <strong id="budget-header">$0</strong></span></div> <button id="advance-time-btn" class="btn btn-primary" onclick="advanceTime()">Advance Time</button> </header>
    <nav class="tabs hidden"> <button class="tab-button active" onclick="openTab(event, 'Overview')">Overview</button> <button class="tab-button" onclick="openTab(event, 'Drivers')">Drivers</button> <button class="tab-button" onclick="openTab(event, 'Staff')">Staff</button> <button class="tab-button" onclick="openTab(event, 'CarDevelopment')">Car Development</button> <button class="tab-button" onclick="openTab(event, 'Infrastructure')">Infrastructure</button> <button class="tab-button" onclick="openTab(event, 'Finances')">Finances</button> <button class="tab-button" onclick="openTab(event, 'Sponsors')">Sponsors</button> <button class="tab-button" onclick="openTab(event, 'Season')">Season</button> <button class="tab-button" onclick="openTab(event, 'Leaderboard')">Leaderboard</button> <button class="tab-button" id="race-tab-button" onclick="openTab(event, 'RaceSim')">Race</button> </nav>

    <main id="main-content" class="hidden">
        <!-- Overview Tab -->
        <div id="Overview" class="tab-content active-content"> <h2>Team Overview</h2><div class="grid-container overview-grid"><div class="info-card"><h3>Team Status</h3><p>Reputation: <strong id="team-reputation-overview">[Value]</strong>%</p><p>Next Race Focus: <span id="next-race-focus">[Track Type]</span></p><p>Team Principal Mood: <span id="principal-mood">[Not Implemented]</span></p></div><div class="info-card"><h3>Driver Summary</h3><div id="driver-summary-overview"><p>Driver 1: <strong id="overview-driver1-name">[Name]</strong> - Morale: <span id="overview-driver1-morale">[Val]</span></p><p>Driver 2: <strong id="overview-driver2-name">[Name]</strong> - Morale: <span id="overview-driver2-morale">[Val]</span></p></div></div><div class="info-card"><h3>Financial Snapshot</h3><p>Budget: <strong id="budget-overview" class="text-large">$[Value]</strong></p><p>Proj. Income (Next Race): <span id="income-overview" class="text-positive">$[Value]</span></p><p>Season Spend: <span id="spend-overview" class="text-negative">$[Value]</span></p></div><div class="info-card"><h3>Active Developments</h3><ul id="active-dev-overview"><li>No active developments.</li></ul><h3>Active Training</h3><ul id="active-train-overview"><li>No active staff training.</li></ul></div><div class="info-card card-full-width"><h3>Urgent Alerts / Messages</h3><ul id="alerts-overview"><li>No alerts.</li></ul></div></div> </div>
        <!-- Drivers Tab -->
        <div id="Drivers" class="tab-content">
            <h2>Drivers</h2>
            <div class="grid-container drivers-grid">
                <div class="card-span-2"> <!-- Container for filters and table -->
                     <!-- Driver Filters -->
                     <div id="driver-filters">
                         <div>
                            <label for="driver-filter-name">Name:</label>
                            <input type="text" id="driver-filter-name" placeholder="Filter by name...">
                         </div>
                         <div>
                            <label for="driver-filter-status">Status:</label>
                            <select id="driver-filter-status">
                                <option value="all">All</option>
                                <option value="player">My Team</option>
                                <option value="ai">AI Teams</option>
                                <option value="free">Free Agents</option>
                            </select>
                         </div>
                     </div>
                     <!-- Driver Replacement Info -->
                     <div id="driver-replacement-info" class="hidden">
                        <p>Replacing <strong id="replacement-outgoing-driver"></strong>. Select a driver below to hire.</p>
                        <button class="btn btn-negative btn-sm" onclick="cancelDriverReplace()">Cancel Replacement</button>
                     </div>
                     <!-- Driver Table -->
                     <div class="table-container">
                        <h3>Driver Market / Team Roster</h3>
                        <table id="driver-list-table">
                            <thead> <!-- MODIFIED: Added Age Header -->
                                <tr>
                                    <th>Name</th>
                                    <th>Team</th>
                                    <th>Age</th> <!-- ADDED -->
                                    <th>Morale</th>
                                    <th>Pace</th>
                                    <th>Cons.</th>
                                    <th>Tyre Mgmt</th>
                                    <th>Ovr/Def</th>
                                    <th>Exp.</th>
                                    <th>Salary/Race</th>
                                    <th>Expiry</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="driver-list-tbody">
                                <!-- Driver rows will be populated by JS -->
                            </tbody>
                        </table>
                     </div>
                </div>
                <div class="info-card" id="driver-details-card">
                    <h3>Driver Details</h3>
                    <p id="driver-detail-placeholder">Select a driver from the list.</p>
                    <div id="driver-detail-content" class="hidden">
                        <h4 id="driver-detail-name">[Driver Name]</h4> <!-- Age will be added here by JS -->
                        <p>Team: <span id="driver-detail-team"></span></p>
                        <p>Nationality: <span id="driver-detail-nat"></span></p>
                        <p>Morale: <span id="driver-detail-morale"></span></p>
                        <p>Pace: <span id="driver-detail-pace"></span> | Cons: <span id="driver-detail-cons"></span></p>
                        <p>Tyre Mgmt: <span id="driver-detail-tyre"></span> | Ovr: <span id="driver-detail-ovr"></span> | Def: <span id="driver-detail-def"></span></p>
                        <p>Experience: <span id="driver-detail-exp"></span></p>
                        <p>Salary/Race: <span id="driver-detail-salary"></span></p>
                        <p>Contract Expiry: <span id="driver-detail-expiry"></span></p>
                        <button class="btn btn-secondary btn-sm disabled" id="negotiate-contract-btn">Negotiate (Not Impl.)</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- Staff Tab -->
        <div id="Staff" class="tab-content"> <h2>Staff Management</h2><div class="grid-container staff-grid"><div class="table-container card-span-2"><h3>Team Staff</h3><table id="staff-list-table"><thead><tr><th>Role</th><th>Name</th><th>Level</th><th>Key Effect</th><th>Status</th><th>Actions</th></tr></thead><tbody id="staff-list-tbody"></tbody></table><p><em>Staff changes may occur at the end of the season. Training improves levels.</em></p></div><div class="info-card" id="staff-details-card"><h3>Staff Details & Training</h3><p id="staff-detail-placeholder">Select staff member to view details or train.</p><div id="staff-detail-content" class="hidden"><h4 id="staff-detail-name">[Staff Name] - <span id="staff-detail-role">[Role]</span></h4><p>Level: <span id="staff-detail-level"></span></p><p>Effects: <span id="staff-detail-effects"></span></p><div id="staff-training-options"><h4>Available Training</h4><ul id="staff-training-list"><li>No training available or staff already training.</li></ul></div></div></div></div> </div>
        <!-- Car Development Tab -->
        <div id="CarDevelopment" class="tab-content">
            <h2>Car Development</h2>
            <div class="grid-container car-dev-grid"> <!-- Single column -->

                <!-- Combined Top Section Wrapper -->
                <div class="info-card card-full-width car-dev-top-section">
                     <div> <!-- Column 1: Player Stats & R&D -->
                        <h3>Current Car Performance</h3>
                        <div id="car-stats-display" style="display: flex; justify-content: space-around; padding: 10px 0; flex-wrap: wrap;">
                            <span>Aero: <strong id="car-stat-aero">[Val]</strong></span>
                            <span>Engine: <strong id="car-stat-engine">[Val]</strong></span>
                            <span>Chassis: <strong id="car-stat-chassis">[Val]</strong></span>
                            <span>Reliability: <strong id="car-stat-reliability">[Val]</strong></span>
                        </div>
                        <h3 style="margin-top: 15px;">In Progress R&D</h3>
                        <ul id="inprogress-rd-list"><li>No active developments.</li></ul>
                    </div>
                    <div> <!-- Column 2: Grid Comparison Table -->
                        <h3>Grid Comparison (Current)</h3> <!-- Changed title -->
                        <div class="table-container">
                            <table id="car-comparison-table">
                                <thead>
                                    <tr><th>Stat</th><th>Your Car</th><th>Grid Avg.</th><th>Grid Best</th></tr>
                                </thead>
                                <tbody id="car-comparison-tbody">
                                    <!-- Populated by JS -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <!-- END Combined Top Section -->

                <!-- Chart Section - Changed Title -->
                <div class="info-card card-full-width">
                    <h3>Car Performance Over Season (Grid)</h3> <!-- Changed title -->
                    <div id="car-comparison-chart-container">
                        <canvas id="carComparisonChart"></canvas>
                    </div>
                </div>
                <!-- END Chart Section -->

                 <!-- Upgrade Sections -->
                 <div class="car-dev-sections-grid card-full-width">
                    <div class="development-section"><h3>Aerodynamics</h3><div id="aero-upgrades"><p>Loading upgrades...</p></div></div>
                    <div class="development-section"><h3>Engine</h3><div id="engine-upgrades"><p>Loading upgrades...</p></div></div>
                    <div class="development-section"><h3>Chassis</h3><div id="chassis-upgrades"><p>Loading upgrades...</p></div></div>
                </div>
            </div>
        </div>
        <!-- Infrastructure Tab -->
        <div id="Infrastructure" class="tab-content"> <h2>Infrastructure</h2><p>Invest in facilities to improve staff, reduce costs, unlock R&D, and influence end-of-season changes.</p><div class="grid-container infra-grid" id="infrastructure-list"><div class="info-card">Loading infrastructure...</div></div> </div>
        <!-- Finances Tab -->
        <div id="Finances" class="tab-content"> <h2>Finances</h2><div class="grid-container finance-grid"><div class="info-card"><h3>Financial Summary</h3><p>Current Budget: <strong id="finance-budget" class="text-large">$[Value]</strong></p><p>Income this Season: <span id="finance-season-income" class="text-positive">$[Value]</span></p><p>Expenses this Season: <span id="finance-season-expenses" class="text-negative">$[Value]</span></p><p>Projected Balance (End of Season): <span id="finance-projected-balance">$[Value]</span></p></div><div class="info-card"><h3>Income Breakdown (Season)</h3><ul id="income-breakdown"><li>Loading...</li></ul></div><div class="info-card"><h3>Expense Breakdown (Season)</h3><ul id="expense-breakdown"><li>Loading...</li></ul></div><div class="table-container card-span-3"><h3>Transaction History (Last 20)</h3><table id="transaction-history-table"><thead><tr><th>Week/Stage</th><th>Description</th><th>Amount</th><th>Balance</th></tr></thead><tbody id="transaction-history-tbody"><tr><td>No transactions yet.</td><td colspan="3"></td></tr></tbody></table></div></div> </div>
        <!-- Sponsors Tab -->
        <div id="Sponsors" class="tab-content"> <h2>Sponsors</h2><div id="sponsor-selection-ui" class="hidden"><h3>Select Sponsors for <span id="sponsor-select-year">[Year]</span></h3><p>Choose <span id="sponsor-slots-available">X</span> sponsor packages. Consider objectives carefully!</p><div class="grid-container sponsor-offer-grid" id="sponsor-offer-list"><div class="info-card">Loading Sponsor Offers...</div></div><button class="btn btn-primary hidden" id="confirm-sponsors-btn" onclick="confirmSponsorSelection()">Confirm Selection</button></div><div id="active-sponsors-ui"><h3>Active Sponsor Deals (<span id="active-sponsor-year">[Year]</span>)</h3><div class="grid-container active-sponsor-grid" id="active-sponsor-list"><div class="info-card"><p>No active sponsors selected yet.</p></div></div></div> </div>
        <!-- Season Tab -->
        <div id="Season" class="tab-content">
            <h2>Season Calendar & Results</h2>
            <div class="grid-container season-grid"> <!-- Adjusted Grid Layout -->
                <div class="info-card"> <!-- Removed card-span-1 -->
                    <h3>Race Calendar (<span id="season-tab-year">[Year]</span>)</h3>
                    <p>Current Race Week: <span id="current-race-index-display">1</span> / 24</p>
                    <ul id="race-calendar-list"><li>Loading calendar...</li></ul>
                </div>
                <div class="info-card"> <!-- Removed card-span-2 -->
                    <h3>Upcoming Race: <span id="upcoming-race-name">[Race Name]</span></h3>
                    <div id="upcoming-race-details">
                        <p>Track: <span id="upcoming-track-name">[Track]</span></p><p>Laps: <span id="upcoming-laps">[Laps]</span></p>
                        <p>Track Characteristics: <span id="upcoming-track-chars">[Characteristics]</span></p>
                        <div id="upcoming-results-area" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--card-border);">
                            <h4>Results (Current Week)</h4>
                            <p>Qualifying: <span id="upcoming-quali-result">[Not run yet]</span></p>
                            <p>Race: <span id="upcoming-race-result">[Not run yet]</span></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Leaderboard Tab -->
        <div id="Leaderboard" class="tab-content"> <h2>Season Standings (<span id="leaderboard-tab-year">[Year]</span>)</h2><div class="grid-container leaderboard-grid"><div class="table-container"><h3>Drivers' Championship</h3><table id="driver-leaderboard-table"><thead><tr><th>Pos</th><th>Driver</th><th>Team</th><th>Points</th></tr></thead><tbody id="driver-leaderboard-tbody"></tbody></table></div><div class="table-container"><h3>Constructors' Championship</h3><table id="constructor-leaderboard-table"><thead><tr><th>Pos</th><th>Team</th><th>Points</th></tr></thead><tbody id="constructor-leaderboard-tbody"></tbody></table></div></div> </div>
         <!-- Race Sim Tab -->
        <div id="RaceSim" class="tab-content">
            <h2 id="race-sim-title">Race Simulation & Strategy</h2>
            <p id="race-sim-status-msg">Waiting for Race Stage...</p>

            <!-- Pre-Race Layout Container -->
            <div id="pre-race-layout" class="hidden">
                <!-- Qualifying Results Area -->
                <div id="quali-results-area" class="info-card">
                     <h3>Qualifying Results - <span id="quali-results-track-name"></span></h3>
                     <div class="table-container">
                         <table id="quali-results-table">
                             <thead><tr><th>Pos</th><th>Driver</th><th>Team</th><th>Time</th></tr></thead>
                             <tbody id="quali-results-tbody"></tbody>
                         </table>
                     </div>
                </div>

                <!-- Strategy Selection Area -->
                <div id="player-strategy-area" class="info-card">
                     <h4>Select Race Strategy</h4>
                     <div id="strategy-options-list"></div>
                     <button id="confirm-strategy-btn" class="btn btn-primary btn-sm" onclick="confirmStrategy()">Confirm Strategy</button>
                     <p><small>Selected Strategy: <span id="selected-strategy-display">None</span></small></p>
                </div>
            </div>
            <!-- End Pre-Race Layout -->

            <!-- Race Simulation Area (Live Data / Events) -->
            <div id="race-sim-content" class="grid-container race-sim-grid hidden">
                 <div class="race-data-area info-card">
                     <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
                         <h3 id="live-data-title">Live Data - <span id="race-lap-display">Lap: 0 / 0</span></h3>
                         <div id="race-speed-controls">
                             Speed:
                             <button class="btn btn-secondary btn-sm speed-btn active" onclick="setRaceSpeed(1)">x1</button>
                             <button class="btn btn-secondary btn-sm speed-btn" onclick="setRaceSpeed(2)">x2</button>
                             <button class="btn btn-secondary btn-sm speed-btn" onclick="setRaceSpeed(5)">x5</button>
                             <button class="btn btn-secondary btn-sm speed-btn" onclick="setRaceSpeed(10)">x10</button>
                         </div>
                     </div>
                     <div id="race-sim-leaderboard">
                         <p>Waiting for race start...</p>
                     </div>
                     <h3 style="margin-top: 15px;">Race Events</h3>
                     <ul id="race-sim-events">
                         <li>Race pending...</li>
                     </ul>
                 </div>
            </div>

             <!-- Final Race Results Area -->
            <div id="race-results-area" class="hidden info-card" style="margin-bottom: 20px;">
                 <h3>Final Race Results - <span id="final-results-track-name"></span></h3>
                 <div class="table-container">
                     <table id="race-results-table">
                         <thead><tr><th>Pos</th><th>Driver</th><th>Team</th><th>Status</th><th>Points</th><th>Laps</th></tr></thead>
                         <tbody id="race-results-tbody"></tbody>
                     </table>
                 </div>
            </div>

        </div>
    </main>

    <script>
    // ==========================================================================
    // F1 Manager Sim - Core JavaScript Logic
    // ==========================================================================

    // --- Game Configuration ---
    const START_YEAR = 2025; const SPONSOR_SLOTS = 3; const RACE_SIM_INTERVAL_MS = 500;
    const RACES_PER_SEASON = 24; // Define this for salary calculations
    // Updated budget values based on user request
    const difficultySettings = { easy: { budget: 50000000 }, medium: { budget: 30000000 }, hard: { budget: 5000000 } };
    const tyreSpecs = { 'Soft': { basePerfModifier: 0.010, degRate: 0.006, color: '#ff3838' }, 'Medium':{ basePerfModifier: 0.000, degRate: 0.0035, color: '#fff200' }, 'Hard': { basePerfModifier: -0.010, degRate: 0.002, color: '#f0f0f0' } };
    const pointsSystem = [25, 18, 15, 12, 10, 8, 6, 4, 2, 1]; const fastestLapPoint = 1;

    // --- Game State Variables ---
    let gameState = {}; let teams = []; let drivers = []; let playerCar = {}; let infrastructure = {}; let season = { year: START_YEAR, races: [] };
    let leaderboard = {}; let potentialSponsors = []; let staffTrainingOptions = {};
    let aiCarData = {};
    let aiInfrastructureData = {}; // To store AI infra levels { teamId: { facilityId: level, ... } }
    let transactionLog = [];
    let raceSimulationInterval = null; let liveLeaderboardData = { drivers: [] }; let raceSpeedMultiplier = 1;
    let availableDriversPool = []; let baseRaceCalendar = [];
    let carComparisonChartInstance = null; // Chart.js instance variable for the performance chart


    // ==========================================================================
    // DATA STRUCTURES (Initial Definitions)
    // ==========================================================================
     function defineInitialDataStructures() {
        // Add a budget property, scaled roughly by reputation
        teams = [
            { id: 'mercedes', name: 'Mercedes', color: '#00D2BE', reputation: 88, staff: null, teamStats: {}, budget: 90000000 },
            { id: 'ferrari', name: 'Ferrari', color: '#DC0000', reputation: 90, staff: null, teamStats: {}, budget: 100000000 },
            { id: 'redbull', name: 'Red Bull Racing', color: '#0600EF', reputation: 95, staff: null, teamStats: {}, budget: 110000000 },
            { id: 'mclaren', name: 'McLaren', color: '#FF8700', reputation: 85, staff: null, teamStats: {}, budget: 85000000 },
            { id: 'astonmartin', name: 'Aston Martin', color: '#006F62', reputation: 80, staff: null, teamStats: {}, budget: 80000000 },
            { id: 'alpine', name: 'Alpine', color: '#0090FF', reputation: 75, staff: null, teamStats: {}, budget: 70000000 },
            { id: 'williams', name: 'Williams', color: '#005AFF', reputation: 70, staff: null, teamStats: {}, budget: 60000000 },
            { id: 'visa', name: 'Racing Bulls', color: '#00A0DF', reputation: 72, staff: null, teamStats: {}, budget: 65000000 },
            { id: 'kick', name: 'Kick Sauber', color: '#52E252', reputation: 68, staff: null, teamStats: {}, budget: 55000000 },
            { id: 'haas', name: 'Haas F1 Team', color: '#B6BABD', reputation: 65, staff: null, teamStats: {}, budget: 50000000 },
        ];
        // ADDED age and potential to drivers
        drivers = [
            { id: 'russell', teamId: null, name: 'G. Russell', nationality: 'GBR', age: 27, potential: 94, morale: 85, stats: { pace: 91, consistency: 88, tyreManagement: 85, overtaking: 86, defending: 87, experience: 75 }, contract: { expiryYear: 2026 } },
            { id: 'antonelli', teamId: null, name: 'A. Antonelli', nationality: 'ITA', age: 19, potential: 96, morale: 75, stats: { pace: 86, consistency: 80, tyreManagement: 82, overtaking: 83, defending: 80, experience: 20 }, contract: { expiryYear: 2026 } },
            { id: 'leclerc', teamId: null, name: 'C. Leclerc', nationality: 'MON', age: 27, potential: 97, morale: 88, stats: { pace: 96, consistency: 85, tyreManagement: 84, overtaking: 90, defending: 85, experience: 80 }, contract: { expiryYear: 2028 } },
            { id: 'hamilton', teamId: null, name: 'L. Hamilton', nationality: 'GBR', age: 40, potential: 94, morale: 90, stats: { pace: 93, consistency: 94, tyreManagement: 95, overtaking: 92, defending: 93, experience: 99 }, contract: { expiryYear: 2026 } },
            { id: 'verstappen', teamId: null, name: 'M. Verstappen', nationality: 'NED', age: 27, potential: 99, morale: 95, stats: { pace: 99, consistency: 96, tyreManagement: 92, overtaking: 97, defending: 95, experience: 88 }, contract: { expiryYear: 2028 } },
            { id: 'perez', teamId: null, name: 'S. Pérez', nationality: 'MEX', age: 35, potential: 88, morale: 80, stats: { pace: 87, consistency: 82, tyreManagement: 93, overtaking: 88, defending: 89, experience: 92 }, contract: { expiryYear: 2025 } },
            { id: 'norris', teamId: null, name: 'L. Norris', nationality: 'GBR', age: 25, potential: 96, morale: 90, stats: { pace: 94, consistency: 90, tyreManagement: 87, overtaking: 89, defending: 86, experience: 78 }, contract: { expiryYear: 2027 } },
            { id: 'piastri', teamId: null, name: 'O. Piastri', nationality: 'AUS', age: 24, potential: 95, morale: 86, stats: { pace: 90, consistency: 89, tyreManagement: 86, overtaking: 85, defending: 84, experience: 45 }, contract: { expiryYear: 2026 } },
            { id: 'alonso', teamId: null, name: 'F. Alonso', nationality: 'ESP', age: 43, potential: 93, morale: 92, stats: { pace: 92, consistency: 95, tyreManagement: 96, overtaking: 94, defending: 97, experience: 100 }, contract: { expiryYear: 2026 } },
            { id: 'stroll', teamId: null, name: 'L. Stroll', nationality: 'CAN', age: 26, potential: 85, morale: 70, stats: { pace: 82, consistency: 75, tyreManagement: 80, overtaking: 81, defending: 80, experience: 82 }, contract: { expiryYear: 2025 } },
            { id: 'gasly', teamId: null, name: 'P. Gasly', nationality: 'FRA', age: 29, potential: 90, morale: 78, stats: { pace: 88, consistency: 86, tyreManagement: 85, overtaking: 87, defending: 84, experience: 84 }, contract: { expiryYear: 2025 } },
            { id: 'ocon', teamId: null, name: 'E. Ocon', nationality: 'FRA', age: 28, potential: 89, morale: 77, stats: { pace: 87, consistency: 87, tyreManagement: 86, overtaking: 84, defending: 88, experience: 83 }, contract: { expiryYear: 2025 } },
            { id: 'albon', teamId: null, name: 'A. Albon', nationality: 'THA', age: 29, potential: 91, morale: 82, stats: { pace: 89, consistency: 88, tyreManagement: 83, overtaking: 85, defending: 85, experience: 76 }, contract: { expiryYear: 2026 } },
            { id: 'sargeant', teamId: null, name: 'L. Sargeant', nationality: 'USA', age: 24, potential: 86, morale: 65, stats: { pace: 78, consistency: 72, tyreManagement: 75, overtaking: 76, defending: 74, experience: 40 }, contract: { expiryYear: 2025 } },
            { id: 'tsunoda', teamId: null, name: 'Y. Tsunoda', nationality: 'JPN', age: 25, potential: 88, morale: 79, stats: { pace: 85, consistency: 80, tyreManagement: 81, overtaking: 83, defending: 80, experience: 65 }, contract: { expiryYear: 2025 } },
            { id: 'ricciardo', teamId: null, name: 'D. Ricciardo', nationality: 'AUS', age: 35, potential: 87, morale: 76, stats: { pace: 86, consistency: 84, tyreManagement: 88, overtaking: 91, defending: 85, experience: 93 }, contract: { expiryYear: 2025 } },
            { id: 'hulkenberg', teamId: null, name: 'N. Hülkenberg', nationality: 'GER', age: 37, potential: 87, morale: 84, stats: { pace: 86, consistency: 90, tyreManagement: 85, overtaking: 82, defending: 86, experience: 94 }, contract: { expiryYear: 2026 } },
            { id: 'bottas', teamId: null, name: 'V. Bottas', nationality: 'FIN', age: 35, potential: 86, morale: 81, stats: { pace: 85, consistency: 89, tyreManagement: 90, overtaking: 83, defending: 87, experience: 95 }, contract: { expiryYear: 2025 } },
            { id: 'magnussen', teamId: null, name: 'K. Magnussen', nationality: 'DEN', age: 32, potential: 85, morale: 74, stats: { pace: 84, consistency: 81, tyreManagement: 82, overtaking: 86, defending: 88, experience: 87 }, contract: { expiryYear: 2025 } },
            { id: 'bearman', teamId: null, name: 'O. Bearman', nationality: 'GBR', age: 20, potential: 92, morale: 72, stats: { pace: 83, consistency: 82, tyreManagement: 80, overtaking: 80, defending: 78, experience: 15 }, contract: { expiryYear: 2026 } },
         ];
        availableDriversPool = JSON.parse(JSON.stringify(drivers)); // Keep this for setup selects
        infrastructure = { aero: { id: 'aero', name: "Aerodynamics Facility", level: 1, maxLevel: 5, costPerLevel: [0, 10000000, 25000000, 50000000, 100000000], benefits: "Unlocks Aero upgrades. Reduces Aero costs by 5%/lvl. Improves 'Head of Aero' training success. +1% chance positive Aero staff change/lvl end of season." }, engine: { id: 'engine', name: "Powertrain Department", level: 1, maxLevel: 5, costPerLevel: [0, 12000000, 30000000, 60000000, 120000000], benefits: "Unlocks Engine upgrades. Reduces Engine costs by 5%/lvl. Improves 'Engine Chief' training success. +1% chance positive Engine staff change/lvl end of season." }, chassis: { id: 'chassis', name: "Chassis Workshop", level: 1, maxLevel: 5, costPerLevel: [0, 8000000, 20000000, 40000000, 90000000], benefits: "Unlocks Chassis upgrades. Reduces Chassis costs by 5%/lvl. Improves 'Chief Designer' training success. +1% chance positive Chassis staff change/lvl end of season." }, factory: { id: 'factory', name: "Manufacturing Plant", level: 1, maxLevel: 4, costPerLevel: [0, 15000000, 40000000, 80000000], benefits: "Reduces all upgrade costs by 2%/lvl. Reduces upgrade *duration* by 3%/lvl. +1% chance positive Factory staff change/lvl end of season." }, };
        baseRaceCalendar = [ { id: 1, name: "Bahrain GP", laps: 57, fastestLaptime: 88.0, aeroDep: 0.5, engineDep: 0.6, chassisDep: 0.4, tyreWearRate: 1.2, overtakingDifficulty: 0.5, basePenaltySpan: 4.5 }, { id: 2, name: "Saudi Arabian GP", laps: 50, fastestLaptime: 87.5, aeroDep: 0.4, engineDep: 0.8, chassisDep: 0.3, tyreWearRate: 0.9, overtakingDifficulty: 0.4, basePenaltySpan: 4.0 }, { id: 3, name: "Australian GP", laps: 58, fastestLaptime: 79.0, aeroDep: 0.6, engineDep: 0.5, chassisDep: 0.5, tyreWearRate: 1.0, overtakingDifficulty: 0.6, basePenaltySpan: 4.2 }, { id: 4, name: "Japanese GP", laps: 53, fastestLaptime: 90.5, aeroDep: 0.7, engineDep: 0.5, chassisDep: 0.6, tyreWearRate: 1.1, overtakingDifficulty: 0.7, basePenaltySpan: 4.8 }, { id: 5, name: "Chinese GP", laps: 56, fastestLaptime: 92.0, aeroDep: 0.6, engineDep: 0.6, chassisDep: 0.5, tyreWearRate: 1.0, overtakingDifficulty: 0.5, basePenaltySpan: 4.5 }, { id: 6, name: "Miami GP", laps: 57, fastestLaptime: 85.5, aeroDep: 0.5, engineDep: 0.7, chassisDep: 0.4, tyreWearRate: 0.9, overtakingDifficulty: 0.4, basePenaltySpan: 4.0 }, { id: 7, name: "Emilia Romagna GP", laps: 63, fastestLaptime: 75.5, aeroDep: 0.6, engineDep: 0.5, chassisDep: 0.6, tyreWearRate: 1.0, overtakingDifficulty: 0.8, basePenaltySpan: 4.2 }, { id: 8, name: "Monaco GP", laps: 78, fastestLaptime: 71.5, aeroDep: 0.9, engineDep: 0.3, chassisDep: 0.8, tyreWearRate: 0.7, overtakingDifficulty: 1.0, basePenaltySpan: 5.5 }, { id: 9, name: "Canadian GP", laps: 70, fastestLaptime: 73.5, aeroDep: 0.4, engineDep: 0.7, chassisDep: 0.5, tyreWearRate: 0.8, overtakingDifficulty: 0.6, basePenaltySpan: 4.0 }, { id: 10, name: "Spanish GP", laps: 66, fastestLaptime: 76.0, aeroDep: 0.7, engineDep: 0.5, chassisDep: 0.6, tyreWearRate: 1.2, overtakingDifficulty: 0.7, basePenaltySpan: 4.8 }, { id: 11, name: "Austrian GP", laps: 71, fastestLaptime: 65.0, aeroDep: 0.4, engineDep: 0.8, chassisDep: 0.4, tyreWearRate: 1.0, overtakingDifficulty: 0.5, basePenaltySpan: 3.8 }, { id: 12, name: "British GP", laps: 52, fastestLaptime: 87.0, aeroDep: 0.8, engineDep: 0.6, chassisDep: 0.5, tyreWearRate: 1.1, overtakingDifficulty: 0.6, basePenaltySpan: 4.7 }, { id: 13, name: "Hungarian GP", laps: 70, fastestLaptime: 77.5, aeroDep: 0.8, engineDep: 0.4, chassisDep: 0.7, tyreWearRate: 1.0, overtakingDifficulty: 0.9, basePenaltySpan: 5.0 }, { id: 14, name: "Belgian GP", laps: 44, fastestLaptime: 104.0, aeroDep: 0.6, engineDep: 0.8, chassisDep: 0.5, tyreWearRate: 1.1, overtakingDifficulty: 0.4, basePenaltySpan: 4.6 }, { id: 15, name: "Dutch GP", laps: 72, fastestLaptime: 71.0, aeroDep: 0.7, engineDep: 0.5, chassisDep: 0.7, tyreWearRate: 1.0, overtakingDifficulty: 0.8, basePenaltySpan: 4.9 }, { id: 16, name: "Italian GP", laps: 53, fastestLaptime: 79.5, aeroDep: 0.3, engineDep: 0.9, chassisDep: 0.3, tyreWearRate: 0.9, overtakingDifficulty: 0.4, basePenaltySpan: 3.9 }, { id: 17, name: "Azerbaijan GP", laps: 51, fastestLaptime: 93.0, aeroDep: 0.4, engineDep: 0.8, chassisDep: 0.4, tyreWearRate: 0.9, overtakingDifficulty: 0.4, basePenaltySpan: 4.1 }, { id: 18, name: "Singapore GP", laps: 62, fastestLaptime: 96.0, aeroDep: 0.9, engineDep: 0.4, chassisDep: 0.8, tyreWearRate: 1.0, overtakingDifficulty: 0.9, basePenaltySpan: 5.2 }, { id: 19, name: "United States GP", laps: 56, fastestLaptime: 93.5, aeroDep: 0.6, engineDep: 0.6, chassisDep: 0.6, tyreWearRate: 1.1, overtakingDifficulty: 0.6, basePenaltySpan: 4.4 }, { id: 20, name: "Mexico City GP", laps: 71, fastestLaptime: 77.0, aeroDep: 0.5, engineDep: 0.7, chassisDep: 0.5, tyreWearRate: 1.0, overtakingDifficulty: 0.5, basePenaltySpan: 4.3 }, { id: 21, name: "São Paulo GP", laps: 71, fastestLaptime: 69.0, aeroDep: 0.6, engineDep: 0.6, chassisDep: 0.6, tyreWearRate: 1.1, overtakingDifficulty: 0.6, basePenaltySpan: 4.5 }, { id: 22, name: "Las Vegas GP", laps: 50, fastestLaptime: 90.0, aeroDep: 0.3, engineDep: 0.9, chassisDep: 0.4, tyreWearRate: 0.8, overtakingDifficulty: 0.4, basePenaltySpan: 4.0 }, { id: 23, name: "Qatar GP", laps: 57, fastestLaptime: 83.0, aeroDep: 0.7, engineDep: 0.7, chassisDep: 0.5, tyreWearRate: 1.2, overtakingDifficulty: 0.5, basePenaltySpan: 4.7 }, { id: 24, name: "Abu Dhabi GP", laps: 58, fastestLaptime: 86.5, aeroDep: 0.6, engineDep: 0.6, chassisDep: 0.6, tyreWearRate: 1.0, overtakingDifficulty: 0.6, basePenaltySpan: 4.4 }, ];
        potentialSponsors = [ { id: 'sponsor_local_motors', name: 'Local Motors Inc.', tier: 3, basePayoutPerRace: 50000, relationship: 0, difficulty: 'Low', objectives: [ { id: 'obj_lm1', type: 'race_pos', target: 15, reward: 250000, durationWeeks: 1, description: "Finish P15 or higher" }, { id: 'obj_lm2', type: 'quali_pos', target: 16, reward: 150000, durationWeeks: 1, description: "Qualify P16 or higher" }, ]},{ id: 'sponsor_quick_lube', name: 'Quick Lube', tier: 3, basePayoutPerRace: 60000, relationship: 0, difficulty: 'Low', objectives: [ { id: 'obj_ql1', type: 'finish_both', target: null, reward: 300000, durationWeeks: 1, description: "Have both cars finish the race" }, ]},{ id: 'sponsor_techtronix', name: 'TechTronix Computing', tier: 2, basePayoutPerRace: 150000, relationship: 0, difficulty: 'Mid', objectives: [ { id: 'obj_tt1', type: 'race_pos', target: 10, reward: 1000000, durationWeeks: 1, description: "Finish P10 or higher" }, { id: 'obj_tt2', type: 'quali_pos', target: 12, reward: 750000, durationWeeks: 1, description: "Qualify P12 or higher" }, { id: 'obj_tt3', type: 'consecutive_points', target: 2, reward: 2000000, durationWeeks: 2, description: "Score points in 2 consecutive races", progress: 0 }, ]},{ id: 'sponsor_aero_dynamics', name: 'Aero Dynamics Ltd.', tier: 2, basePayoutPerRace: 175000, relationship: 0, difficulty: 'Mid', objectives: [ { id: 'obj_ad1', type: 'both_cars_in_points', target: null, reward: 2500000, durationWeeks: 1, description: "Finish with both cars in the points" }, { id: 'obj_ad2', type: 'team_standing_mid', target: 7, reward: 5000000, durationWeeks: 24, description: "Finish Top 7 in Constructors'" }, ]},{ id: 'sponsor_velocity_oil', name: 'Velocity Oil', tier: 1, basePayoutPerRace: 300000, relationship: 0, difficulty: 'High', objectives: [ { id: 'obj_vo1', type: 'race_pos', target: 6, reward: 4000000, durationWeeks: 1, description: "Finish P6 or higher" }, { id: 'obj_vo2', type: 'quali_pos', target: 8, reward: 3000000, durationWeeks: 1, description: "Qualify P8 or higher" }, { id: 'obj_vo3', type: 'podium_finish', target: null, reward: 7500000, durationWeeks: 4, description: "Achieve a podium finish within 4 races", achieved: false }, ]},{ id: 'sponsor_global_banking', name: 'Global Banking Corp.', tier: 1, basePayoutPerRace: 350000, relationship: 0, difficulty: 'High', objectives: [ { id: 'obj_gb1', type: 'team_standing_top', target: 4, reward: 15000000, durationWeeks: 24, description: "Finish Top 4 in Constructors'" }, { id: 'obj_gb2', type: 'win_race', target: null, reward: 10000000, durationWeeks: 8, description: "Win a race within 8 races", achieved: false }, ]}, ];
        staffTrainingOptions = { 'Technical Director': [{ id: 'td_manage_1', name: 'Project Management', cost: 500000, durationWeeks: 3, successChance: 0.95, levelReq: 1, effect: { RDSuccessRate: 1 } },{ id: 'td_manage_2', name: 'Resource Allocation', cost: 1500000, durationWeeks: 5, successChance: 0.85, levelReq: 5, effect: { RDSuccessRate: 2, CarBuildSpeed: 1 } },],'Head of Aerodynamics': [{ id: 'aero_cfd_1', name: 'CFD Basics', cost: 400000, durationWeeks: 2, successChance: 0.97, levelReq: 1, effect: { AeroDevEffectiveness: 1 } },{ id: 'aero_wt_1', name: 'Wind Tunnel Ops', cost: 600000, durationWeeks: 3, successChance: 0.95, levelReq: 3, effect: { AeroDevEffectiveness: 2 } },{ id: 'aero_adv_concept', name: 'Advanced Concepts', cost: 2000000, durationWeeks: 6, successChance: 0.80, levelReq: 7, effect: { AeroDevEffectiveness: 4 } },],'Chief Designer': [{ id: 'des_cad_1', name: 'CAD Proficiency', cost: 300000, durationWeeks: 2, successChance: 0.98, levelReq: 1, effect: { ChassisDevEffectiveness: 1 } },{ id: 'des_materials_1', name: 'Materials Science', cost: 750000, durationWeeks: 4, successChance: 0.92, levelReq: 4, effect: { ChassisDevEffectiveness: 2, ReliabilityDevEffectiveness: 1 } },],'Engine Chief': [{ id: 'eng_calib_1', name: 'ECU Calibration', cost: 500000, durationWeeks: 3, successChance: 0.96, levelReq: 1, effect: { EngineDevEffectiveness: 1 } },{ id: 'eng_dyno_1', name: 'Dyno Optimization', cost: 1000000, durationWeeks: 4, successChance: 0.90, levelReq: 5, effect: { EngineDevEffectiveness: 2 } },],'Pit Crew Chief': [{ id: 'pit_routine_1', name: 'Routine Practice', cost: 100000, durationWeeks: 1, successChance: 0.99, levelReq: 1, effect: { PitStopTime: -0.05 } },{ id: 'pit_equip_1', name: 'Equipment Handling', cost: 400000, durationWeeks: 3, successChance: 0.95, levelReq: 4, effect: { PitStopTime: -0.10 } },], };
    }
    function createInitialStaff(teamId) { const team = teams.find(t => t.id === teamId); const baseLevel = team ? Math.max(1, Math.floor(team.reputation / 15)) : 3; return [ { id: `${teamId}_tech_dir`, role: 'Technical Director', name: `Tech Dir ${teamId.slice(0,3).toUpperCase()}`, level: baseLevel + Math.floor(Math.random()*3), statEffect: { RDSuccessRate: 1 }, isTraining: false, trainingProgress: 0 }, { id: `${teamId}_head_aero`, role: 'Head of Aerodynamics', name: `Aero Head ${teamId.slice(0,3).toUpperCase()}`, level: baseLevel + Math.floor(Math.random()*3), statEffect: { AeroDevEffectiveness: 1 }, isTraining: false, trainingProgress: 0 }, { id: `${teamId}_chief_des`, role: 'Chief Designer', name: `Designer ${teamId.slice(0,3).toUpperCase()}`, level: baseLevel + Math.floor(Math.random()*2), statEffect: { ChassisDevEffectiveness: 1 }, isTraining: false, trainingProgress: 0 }, { id: `${teamId}_eng_chief`, role: 'Engine Chief', name: `Engine Chief ${teamId.slice(0,3).toUpperCase()}`, level: baseLevel + Math.floor(Math.random()*3), statEffect: { EngineDevEffectiveness: 1 }, isTraining: false, trainingProgress: 0 }, { id: `${teamId}_pit_chief`, role: 'Pit Crew Chief', name: `Pit Chief ${teamId.slice(0,3).toUpperCase()}`, level: baseLevel + Math.floor(Math.random()*2), statEffect: { PitStopTime: -0.05 }, isTraining: false, trainingProgress: 0 }, ].map(s => ({...s, level: Math.max(1, Math.min(10, s.level))})); }
    function initializeCarDevelopmentParts() {
        return {
            aero: [
                { id: 'aero_t1_fw', name: 'Front Wing Endplate Tweak', description: 'Minor endplate adjustment for outwash.', cost: 500000, performanceBoost: { aero: 1 }, requiredInfra: { facility: 'aero', level: 1 }, unlocked: false, durationWeeks: 2, baseSuccessChance: 0.98 },
                { id: 'aero_t1_rw', name: 'Basic Rear Wing Refinement', description: 'Small drag reduction effort.', cost: 600000, performanceBoost: { aero: 1 }, requiredInfra: { facility: 'aero', level: 1 }, unlocked: false, durationWeeks: 2, baseSuccessChance: 0.97 },
                { id: 'aero_t1_floor', name: 'Floor Edge Detail', description: 'Small vortex generator added.', cost: 700000, performanceBoost: { aero: 2 }, requiredInfra: { facility: 'aero', level: 1 }, unlocked: false, durationWeeks: 3, baseSuccessChance: 0.96 },
                { id: 'aero_t2_fw', name: 'Revised Front Wing Concept', description: 'New front wing philosophy.', cost: 1800000, performanceBoost: { aero: 4 }, requiredInfra: { facility: 'aero', level: 2 }, unlocked: false, durationWeeks: 4, baseSuccessChance: 0.92 },
                { id: 'aero_t2_floor', name: 'Underfloor Channel Tuning', description: 'Improved ground effect sealing.', cost: 2500000, performanceBoost: { aero: 5 }, requiredInfra: { facility: 'aero', level: 2 }, unlocked: false, durationWeeks: 5, baseSuccessChance: 0.90 },
                { id: 'aero_t3_package', name: 'Full Aero Package', description: 'Comprehensive aero surface redesign.', cost: 6000000, performanceBoost: { aero: 10, reliability: 1 }, requiredInfra: { facility: 'aero', level: 3 }, unlocked: false, durationWeeks: 8, baseSuccessChance: 0.85 },
            ],
            engine: [
                { id: 'eng_t1_calib', name: 'ECU Mapping Update', description: 'Optimize fuel burn and power delivery.', cost: 800000, performanceBoost: { engine: 2 }, requiredInfra: { facility: 'engine', level: 1 }, unlocked: false, durationWeeks: 3, baseSuccessChance: 0.95 },
                { id: 'eng_t1_cool', name: 'Improved Cooling Layout', description: 'Better heat management.', cost: 600000, performanceBoost: { reliability: 2 }, requiredInfra: { facility: 'engine', level: 1 }, unlocked: false, durationWeeks: 2, baseSuccessChance: 0.98 },
                { id: 'eng_t2_turbo', name: 'Turbocharger Efficiency', description: 'Revised compressor design.', cost: 2200000, performanceBoost: { engine: 5 }, requiredInfra: { facility: 'engine', level: 2 }, unlocked: false, durationWeeks: 5, baseSuccessChance: 0.90 },
                { id: 'eng_t2_ers', name: 'ERS Deployment Strategy', description: 'Enhanced energy recovery/deployment map.', cost: 1800000, performanceBoost: { engine: 4 }, requiredInfra: { facility: 'engine', level: 2 }, unlocked: false, durationWeeks: 4, baseSuccessChance: 0.91 },
                { id: 'eng_t3_comb', name: 'Combustion Chamber Design', description: 'Advanced internal combustion research.', cost: 7000000, performanceBoost: { engine: 12, reliability: 2 }, requiredInfra: { facility: 'engine', level: 3 }, unlocked: false, durationWeeks: 9, baseSuccessChance: 0.82 },
            ],
            chassis: [
                { id: 'cha_t1_susp', name: 'Suspension Geometry Tweak', description: 'Minor kinematic adjustments.', cost: 400000, performanceBoost: { chassis: 1 }, requiredInfra: { facility: 'chassis', level: 1 }, unlocked: false, durationWeeks: 2, baseSuccessChance: 0.97 },
                { id: 'cha_t1_wgt', name: 'Weight Distribution Tuning', description: 'Optimize ballast placement.', cost: 300000, performanceBoost: { chassis: 1, reliability: 1 }, requiredInfra: { facility: 'chassis', level: 1 }, unlocked: false, durationWeeks: 1, baseSuccessChance: 0.99 },
                { id: 'cha_t2_stiff', name: 'Chassis Stiffness Increase', description: 'Carbon layup optimization.', cost: 1500000, performanceBoost: { chassis: 4, reliability: 1 }, requiredInfra: { facility: 'chassis', level: 2 }, unlocked: false, durationWeeks: 4, baseSuccessChance: 0.93 },
                { id: 'cha_t2_damp', name: 'Advanced Damper Tech', description: 'Improved ride control.', cost: 1200000, performanceBoost: { chassis: 3 }, requiredInfra: { facility: 'chassis', level: 2 }, unlocked: false, durationWeeks: 3, baseSuccessChance: 0.94 },
                { id: 'cha_t3_monoc', name: 'Monocoque Redesign', description: 'Lighter, stiffer core structure.', cost: 5500000, performanceBoost: { chassis: 9, reliability: 1 }, requiredInfra: { facility: 'chassis', level: 3 }, unlocked: false, durationWeeks: 8, baseSuccessChance: 0.86 },
            ],
        };
    }
    function createInitialCarData(teamId) { const team = teams.find(t => t.id === teamId); const baseStat = team ? Math.max(40, Math.floor(team.reputation * 0.7)) : 50; const reliabilityBase = 80 + Math.floor(Math.random() * 15); return { teamId: teamId, baseStats: { aero: Math.min(100, baseStat + Math.floor(Math.random() * 10) - 5), engine: Math.min(100, baseStat + Math.floor(Math.random() * 10) - 5), chassis: Math.min(100, baseStat + Math.floor(Math.random() * 10) - 5), reliability: Math.min(99, Math.max(70, reliabilityBase)), }, appliedUpgrades: [], development: initializeCarDevelopmentParts() }; }

    // ==========================================================================
    // HELPER FUNCTIONS
    // ==========================================================================
    function getTeamById(id) { return teams.find(t => t.id === id); }
    function getDriverById(id) { return drivers.find(d => d.id === id); }
    function getInfrastructureById(id) { return infrastructure[id]; } // Player only
    function getStaffById(teamId, staffId) { return getTeamById(teamId)?.staff.find(s => s.id === staffId); }
    function getCarData(teamId) { return teamId === gameState.playerTeamId ? playerCar : aiCarData[teamId]; }
    function formatCurrency(value) { if (value === undefined || value === null) return '$0'; try { return `$${new Intl.NumberFormat('sv-SE').format(value)}`; } catch (e) { console.warn("Intl.NumberFormat failed, using regex fallback for currency."); let numStr = Math.round(value).toString().replace(/\B(?=(\d{3})+(?!\d))/g, " "); return `$${numStr}`; } }
    function logTransaction(description, amount, currentBudget) { transactionLog.unshift({ stage: gameState.currentGameStage, week: gameState.currentWeek, description: description, amount: amount, balance: currentBudget }); if (transactionLog.length > 20) { transactionLog.pop(); } }
    function addPlayerMessage(text, type = 'info') { if (!gameState.currentMessages) gameState.currentMessages = []; gameState.currentMessages.unshift({ text: text, type: type, week: gameState.currentWeek, stage: gameState.currentGameStage }); if (gameState.currentMessages.length > 10) { gameState.currentMessages.pop(); } const overviewTab = document.getElementById('Overview'); if (overviewTab && overviewTab.classList.contains('active-content')) { displayAlerts(); } }
    function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
    function shuffleAndAssignRaceCalendar() { let shuffledRaces = shuffleArray([...baseRaceCalendar]); shuffledRaces.forEach((race, index) => { race.calendarId = index + 1; }); season.races = shuffledRaces; console.log("Race calendar shuffled for the season."); }
    function calculateDriverOverall(driver) { if (!driver || !driver.stats) return 0; const stats = driver.stats; return Math.round( (stats.pace * 0.3) + (stats.consistency * 0.2) + (stats.tyreManagement * 0.15) + (stats.overtaking * 0.15) + (stats.defending * 0.1) + (stats.experience * 0.1) ); }
    function calculateOverallPerformance(carData) { if (!carData || !carData.baseStats) return 50; const { aero, engine, chassis } = carData.baseStats; return ( (aero || 50) + (engine || 50) + (chassis || 50) ) / 3; }
    function hexToRgba(hex, alpha = 1) { hex = hex.replace('#', ''); const r = parseInt(hex.length === 3 ? hex.slice(0, 1).repeat(2) : hex.slice(0, 2), 16); const g = parseInt(hex.length === 3 ? hex.slice(1, 2).repeat(2) : hex.slice(2, 4), 16); const b = parseInt(hex.length === 3 ? hex.slice(2, 3).repeat(2) : hex.slice(4, 6), 16); if (isNaN(r) || isNaN(g) || isNaN(b)) { console.warn(`Invalid hex color: ${hex}. Using default.`); return `rgba(160, 160, 160, ${alpha})`; } return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

    // ==========================================================================
    // DRIVER STAT PROGRESSION HELPERS (NEW)
    // ==========================================================================
    function calculatePotentialChange(driver) {
        const age = driver.age;
        const oldPotential = driver.potential;
        let potentialChange = 0;

        // --- Age Modifier ---
        let ageModifier = 0;
        if (age <= 23) ageModifier = (24 - age) * 0.4; // Strong growth for young drivers
        else if (age <= 28) ageModifier = (29 - age) * 0.2; // Moderate growth
        else if (age <= 33) ageModifier = (33 - age) * 0.1; // Slow growth / plateau near peak
        else if (age <= 40) ageModifier = (35 - age) * 0.15; // Gradual decline after peak (negative value)

        // --- Results Modifier ---
        let resultsModifier = 0;
        const driverStanding = leaderboard.drivers.find(d => d.driverId === driver.id);
        const teamStanding = leaderboard.teams.find(t => t.teamId === driver.teamId);

        if (driverStanding && teamStanding && teamStanding.points > 0) { // Avoid division by zero or calcs for teams with 0 points
            const teamRank = getCurrentTeamRank(driver.teamId) || teams.length;
            const driverRank = leaderboard.drivers.findIndex(d => d.driverId === driver.id) + 1;

            // Compare driver rank vs expected rank based on team (simple heuristic)
            const expectedDriverRankFloor = Math.max(1, teamRank * 2 - 2); // Rough expectation floor
            const expectedDriverRankCeiling= Math.max(1, teamRank * 2 + 1); // Rough expectation ceiling

            if (driverRank <= expectedDriverRankFloor) {
                resultsModifier = 1.0 + (expectedDriverRankFloor - driverRank) * 0.1; // Bonus for exceeding expectations
            } else if (driverRank > expectedDriverRankCeiling) {
                resultsModifier = -0.5 - (driverRank - expectedDriverRankCeiling) * 0.1; // Penalty for underperforming
            } else {
                 resultsModifier = 0.2; // Met expectations - small positive bump
            }
        } else if (driverStanding) {
             // Driver didn't score or team didn't score - slight negative pressure unless very young
             resultsModifier = age <= 22 ? 0 : -0.3;
        }

        // --- Calculate Final Change ---
        const baseChangeRate = 1.5; // How much potential can change per year overall

        if (age <= 40) {
            potentialChange = (ageModifier + resultsModifier) * baseChangeRate * (Math.random() * 0.4 + 0.8); // Add some randomness
        } else {
             // Over 40: Only allow potential decrease, and only if results were poor. Cap decrease.
             potentialChange = Math.max(-1.5, Math.min(0, resultsModifier * baseChangeRate * 0.5)); // Limited decline rate
        }

        // Round potential change to integer.
        potentialChange = Math.round(potentialChange);

        return potentialChange; // Return the calculated change
    }

    function updateDriverStats(driver) {
        const age = driver.age;
        const potential = driver.potential; // Use the *newly updated* potential
        const statsToUpdate = ['pace', 'consistency', 'tyreManagement', 'overtaking', 'defending'];

        // --- Growth/Decline Rate based on Age ---
        let changeRate = 0;
        if (age <= 22) changeRate = 0.15;       // Very Fast growth/adjustment
        else if (age <= 26) changeRate = 0.10;  // Fast
        else if (age <= 30) changeRate = 0.07;  // Medium
        else if (age <= 35) changeRate = 0.05;  // Slow
        else if (age <= 40) changeRate = 0.03;  // Very Slow adjustment (mostly decline)
        else changeRate = 0.04;                 // Slow decline rate for >40

        // --- Update Core Stats ---
        statsToUpdate.forEach(stat => {
            const currentStat = driver.stats[stat];
            // Target stat based on potential (e.g., potential is the ideal ceiling)
            const targetStat = potential;
            const difference = targetStat - currentStat;
            let statChange = 0;

            if (age <= 40) {
                // Adjust towards target based on age rate
                statChange = difference * changeRate * (Math.random() * 0.5 + 0.75); // Add randomness
            } else { // Age > 40
                // Only allow stats to decrease if they are above potential
                if (difference < 0) {
                    statChange = difference * changeRate * (Math.random() * 0.5 + 0.75); // Apply decline
                }
                 // Crucially, set statChange to 0 if difference >= 0 to prevent increase
                 else {
                     statChange = 0;
                 }
            }

            // Apply change and clamp (e.g., between 10 and 100)
            driver.stats[stat] = Math.max(10, Math.min(100, Math.round(currentStat + statChange)));
        });

        // --- Update Experience ---
        // Simple increment, capped at 100
        driver.stats.experience = Math.min(100, driver.stats.experience + 1);
    }

    // ==========================================================================
    // HISTORY & STATS RECORDING
    // ==========================================================================
    function recordPerformanceHistory() { console.log(`Recording performance history at Week ${gameState.currentWeek}, Stage ${gameState.currentGameStage}`); teams.forEach(team => { const carData = getCarData(team.id); const performance = calculateOverallPerformance(carData); if (!gameState.performanceHistory[team.id]) { gameState.performanceHistory[team.id] = []; } const lastValue = gameState.performanceHistory[team.id][gameState.performanceHistory[team.id].length - 1]; if (gameState.performanceHistory[team.id].length === 0 || performance !== lastValue) { gameState.performanceHistory[team.id].push(performance); } }); if (document.getElementById('CarDevelopment')?.classList.contains('active-content')) { renderCarComparisonChart(); } }

    // ==========================================================================
    // SETUP PHASE FUNCTIONS
    // ==========================================================================
    function populateTeamSelect() { const select = document.getElementById('team-select'); if (!select) return; select.innerHTML = '<option value="">-- Select Team --</option>'; teams.forEach(team => { const option = document.createElement('option'); option.value = team.id; option.textContent = team.name; select.appendChild(option); }); }
    function populateDriverSelects() { const select1 = document.getElementById('driver1-select'); const select2 = document.getElementById('driver2-select'); if (!select1 || !select2) return; select1.innerHTML = '<option value="">-- Select Driver 1 --</option>'; select2.innerHTML = '<option value="">-- Select Driver 2 --</option>'; availableDriversPool.forEach(driver => { const option1 = document.createElement('option'); option1.value = driver.id; option1.textContent = `${driver.name} (${driver.age}) (P:${driver.stats.pace} C:${driver.stats.consistency} E:${driver.stats.experience})`; select1.appendChild(option1); const option2 = document.createElement('option'); option2.value = driver.id; option2.textContent = `${driver.name} (${driver.age}) (P:${driver.stats.pace} C:${driver.stats.consistency} E:${driver.stats.experience})`; select2.appendChild(option2); }); } // Added Age to driver select text
    function startGame() { const teamSelect = document.getElementById('team-select'); const driver1Select = document.getElementById('driver1-select'); const driver2Select = document.getElementById('driver2-select'); const difficultyRadio = document.querySelector('input[name="difficulty"]:checked'); const errorEl = document.getElementById('setup-error'); errorEl.textContent = ''; const selectedTeamId = teamSelect.value; const selectedDriver1Id = driver1Select.value; const selectedDriver2Id = driver2Select.value; const selectedDifficulty = difficultyRadio.value; if (!selectedTeamId) { errorEl.textContent = 'Please select a team.'; return; } if (!selectedDriver1Id) { errorEl.textContent = 'Please select Driver 1.'; return; } if (!selectedDriver2Id) { errorEl.textContent = 'Please select Driver 2.'; return; } if (selectedDriver1Id === selectedDriver2Id) { errorEl.textContent = 'Please select two different drivers.'; return; } console.log("Starting game with selections:", selectedTeamId, selectedDriver1Id, selectedDriver2Id, selectedDifficulty); const startingBudget = difficultySettings[selectedDifficulty].budget; setupGameData(selectedTeamId, selectedDriver1Id, selectedDriver2Id, startingBudget); assignAIDrivers(selectedTeamId, [selectedDriver1Id, selectedDriver2Id]); document.getElementById('game-setup').classList.add('hidden'); document.querySelector('.main-header').classList.remove('hidden'); document.querySelector('.tabs').classList.remove('hidden'); document.getElementById('main-content').classList.remove('hidden'); calculateInitialSalaries(); teams.forEach(t => calculateTeamStats(t.id)); shuffleAndAssignRaceCalendar(); initializeLeaderboard(); gameState.currentGameStage = 'PreSeason'; ensureFullGrid(); recordPerformanceHistory(); updateUI(); openTab(null, 'Overview'); addPlayerMessage(`Game started! Managing ${getTeamById(selectedTeamId).name}. Budget: ${formatCurrency(startingBudget)}`, "success"); }
    function setupGameData(pTeamId, pDriver1Id, pDriver2Id, pBudget) { gameState = { currentYear: START_YEAR, playerTeamId: pTeamId, finances: { budget: pBudget, incomePerRaceBase: 500000, seasonIncome: 0, seasonExpenses: 0, }, currentRaceIndex: 0, currentGameStage: 'Setup', currentWeek: 0, inProgressDevelopment: [], inProgressStaffTraining: [], activeSponsorContracts: [], selectedSponsors: [], playerStrategy: null, raceResultsLog: [], currentMessages: [], raceSpeedMultiplier: 1, driverReplacementInProgress: null, performanceHistory: {}, }; const driver1 = drivers.find(d => d.id === pDriver1Id); const driver2 = drivers.find(d => d.id === pDriver2Id); if (driver1) driver1.teamId = pTeamId; if (driver2) driver2.teamId = pTeamId; playerCar = createInitialCarData(pTeamId); teams.forEach(t => { if (t.id !== pTeamId) { aiCarData[t.id] = createInitialCarData(t.id); } else { t.staff = createInitialStaff(t.id); } }); teams.forEach(t => { gameState.performanceHistory[t.id] = []; }); season.year = gameState.currentYear; }
    function assignAIDrivers(playerTeamId, playerDriverIds) { const aiTeams = teams.filter(t => t.id !== playerTeamId); let remainingDrivers = drivers.filter(d => !playerDriverIds.includes(d.id)); remainingDrivers.sort((a, b) => b.stats.pace - a.stats.pace); const sortedAITeams = [...aiTeams].sort((a,b) => b.reputation - a.reputation); sortedAITeams.forEach(team => { team.staff = createInitialStaff(team.id); aiInfrastructureData[team.id] = {}; for (const facilityKey in infrastructure) { aiInfrastructureData[team.id][facilityKey] = 1; } console.log(`Initialized Level 1 infrastructure for AI team ${team.name}`); if (remainingDrivers.length < 2) { console.error(`Not enough drivers to fill team ${team.name}`); return; } const driver1 = remainingDrivers.shift(); const driver2 = remainingDrivers.shift(); driver1.teamId = team.id; driver2.teamId = team.id; console.log(`Assigned ${driver1.name} and ${driver2.name} to AI team ${team.name}`); }); }
    function calculateInitialSalaries() { drivers.forEach(d => { if (d.teamId) { const team = getTeamById(d.teamId); d.contract.salaryPerRace = calculateSalaryPerRace(d, team?.reputation || 70); } else { d.contract.salaryPerRace = 0; } }); }
    function initializeLeaderboard() { leaderboard = { drivers: drivers.map(d => ({ driverId: d.id, points: 0, teamId: d.teamId })), teams: teams.map(t => ({ teamId: t.id, points: 0 })) }; }

    // ==========================================================================
    // UI UPDATE FUNCTIONS
    // ==========================================================================
    function openTab(evt, tabName) { document.querySelectorAll('.tab-content').forEach(tc => { tc.style.display = 'none'; tc.classList.remove('active-content'); }); document.querySelectorAll('.tab-button').forEach(tb => tb.classList.remove('active')); const tabToShow = document.getElementById(tabName); if (tabToShow) { tabToShow.style.display = 'block'; tabToShow.classList.add('active-content'); } else { console.warn(`Tab content not found for ID: ${tabName}`); const overviewTab = document.getElementById('Overview'); if (overviewTab) { overviewTab.style.display = 'block'; overviewTab.classList.add('active-content'); } } const clickedButton = evt?.currentTarget; const targetButton = clickedButton || document.querySelector(`.tab-button[onclick*="'${tabName}'"]`); if (targetButton) { targetButton.classList.add('active'); } else { document.querySelector('.tab-button[onclick*="\'Overview\'"]')?.classList.add('active'); } if (tabName !== 'Drivers' && gameState.driverReplacementInProgress) { cancelDriverReplace(); } switch(tabName) { case 'Leaderboard': displayLeaderboard(); break; case 'CarDevelopment': displayCarDevelopment(); break; case 'Infrastructure': displayInfrastructure(); break; case 'Finances': displayFinances(); break; case 'Sponsors': displaySponsors(); break; case 'Staff': displayStaff(); break; case 'Drivers': displayDrivers(); break; case 'Season': displaySeasonCalendar(); break; case 'Overview': updateOverviewTab(); break; case 'RaceSim': displayRaceSim(); break; default: updateOverviewTab(); } }
    function updateHeader() { const playerTeam = getTeamById(gameState.playerTeamId); const playerTeamHeaderEl = document.getElementById('player-team-header'); if (playerTeamHeaderEl) playerTeamHeaderEl.textContent = `${playerTeam?.name || 'Team'} - ${gameState.currentYear}`; const currentYearHeaderEl = document.getElementById('current-year-header'); if (currentYearHeaderEl) currentYearHeaderEl.textContent = gameState.currentYear; const currentStageHeaderEl = document.getElementById('current-stage-header'); if (currentStageHeaderEl) currentStageHeaderEl.textContent = gameState.currentGameStage; const currentWeekHeaderEl = document.getElementById('current-week-header'); if (currentWeekHeaderEl) currentWeekHeaderEl.textContent = gameState.currentWeek; const budgetHeaderEl = document.getElementById('budget-header'); if (budgetHeaderEl) budgetHeaderEl.textContent = formatCurrency(gameState.finances?.budget || 0); const nextRaceIndex = (gameState.currentGameStage === 'EndOfSeason' || gameState.currentGameStage === 'PreSeason') ? 0 : gameState.currentRaceIndex; const nextRace = season?.races?.[nextRaceIndex]; const nextRaceHeaderEl = document.getElementById('next-race-header'); if (nextRaceHeaderEl) nextRaceHeaderEl.textContent = nextRace ? `#${nextRace.calendarId} ${nextRace.name}` : 'Season Over'; const advanceTimeBtnEl = document.getElementById('advance-time-btn'); if (advanceTimeBtnEl) { const requiresStrategy = (gameState.currentGameStage === 'PreRace' && !gameState.playerStrategy); const requiresSponsors = (gameState.currentGameStage === 'PreSeason' && (!gameState.activeSponsorContracts || gameState.activeSponsorContracts.length === 0)); advanceTimeBtnEl.disabled = gameState.currentGameStage === 'Race' || requiresStrategy || requiresSponsors || gameState.driverReplacementInProgress; switch (gameState.currentGameStage) { case 'PreSeason': advanceTimeBtnEl.textContent = requiresSponsors ? "Select Sponsors!" : (gameState.driverReplacementInProgress ? "Finalize Driver!" : "Start Season"); break; case 'StartOfWeek': advanceTimeBtnEl.textContent = "Run Qualifying"; break; case 'Qualifying': advanceTimeBtnEl.textContent = "Prepare for Race"; break; case 'PreRace': advanceTimeBtnEl.textContent = requiresStrategy ? "Select Strategy!" : "Start Race"; break; case 'Race': advanceTimeBtnEl.textContent = "Race in Progress..."; break; case 'PostRace': advanceTimeBtnEl.textContent = "End Weekend"; break; case 'EndOfSeason': advanceTimeBtnEl.textContent = "Start Pre-Season"; break; default: advanceTimeBtnEl.textContent = "Advance Time"; } } }
    function updateOverviewTab() { const playerTeam = getTeamById(gameState.playerTeamId); const repEl = document.getElementById('team-reputation-overview'); if(repEl && playerTeam) repEl.textContent = playerTeam.reputation?.toFixed(1) || 'N/A'; const budgetEl = document.getElementById('budget-overview'); if (budgetEl) budgetEl.textContent = formatCurrency(gameState.finances.budget); const spendEl = document.getElementById('spend-overview'); if (spendEl) spendEl.textContent = formatCurrency(gameState.finances.seasonExpenses); const incomeEl = document.getElementById('income-overview'); if (incomeEl) { const projIncome = gameState.finances.incomePerRaceBase + (gameState.activeSponsorContracts?.reduce((sum, c) => sum + c.basePayoutPerRace, 0) || 0); incomeEl.textContent = formatCurrency(projIncome); } const teamDrivers = drivers.filter(d => d.teamId === gameState.playerTeamId); const d1NameEl = document.getElementById('overview-driver1-name'); const d1MoraleEl = document.getElementById('overview-driver1-morale'); if (d1NameEl && d1MoraleEl && teamDrivers.length > 0) { d1NameEl.textContent = `${teamDrivers[0].name} (${teamDrivers[0].age})`; d1MoraleEl.textContent = teamDrivers[0].morale; } else if (d1NameEl) { d1NameEl.textContent = '[N/A]'; d1MoraleEl.textContent = '[N/A]'; } const d2NameEl = document.getElementById('overview-driver2-name'); const d2MoraleEl = document.getElementById('overview-driver2-morale'); if (d2NameEl && d2MoraleEl && teamDrivers.length > 1) { d2NameEl.textContent = `${teamDrivers[1].name} (${teamDrivers[1].age})`; d2MoraleEl.textContent = teamDrivers[1].morale; } else if (d2NameEl) { d2NameEl.textContent = '[N/A]'; d2MoraleEl.textContent = '[N/A]'; } const devList = document.getElementById('active-dev-overview'); if(devList) { devList.innerHTML = ''; if (gameState.inProgressDevelopment?.length > 0) { gameState.inProgressDevelopment.forEach(dev => { const upgrade = findUpgradeByIdRecursive(dev.upgradeId); devList.innerHTML += `<li>${upgrade?.name || 'Unknown Upgrade'} - ETA: Wk ${dev.targetCompletionWeek} ${dev.targetCompletionStage}</li>`; }); } else { devList.innerHTML = '<li>No active developments.</li>'; } } const trainList = document.getElementById('active-train-overview'); if(trainList) { trainList.innerHTML = ''; if (gameState.inProgressStaffTraining?.length > 0) { gameState.inProgressStaffTraining.forEach(train => { const staff = getStaffById(gameState.playerTeamId, train.staffId); trainList.innerHTML += `<li>${staff?.name || 'Unknown Staff'} (${train.trainingName}) - ETA: Wk ${train.targetCompletionWeek} ${train.targetCompletionStage}</li>`; }); } else { trainList.innerHTML = '<li>No active staff training.</li>'; } } const nextRaceFocusEl = document.getElementById('next-race-focus'); if (nextRaceFocusEl) { const nextRace = season?.races?.[gameState.currentRaceIndex]; let focus = "Balanced"; if (nextRace) { if (nextRace.aeroDep > 0.7) focus = "High Aero"; else if (nextRace.engineDep > 0.7) focus = "High Engine Power"; else if (nextRace.chassisDep > 0.7) focus = "Chassis Performance"; else if (nextRace.tyreWearRate > 1.1) focus = "Tyre Management"; } nextRaceFocusEl.textContent = focus; } displayAlerts(); }
    function displayAlerts() { const alertList = document.getElementById('alerts-overview'); if (!alertList) return; alertList.innerHTML = ''; if (gameState.currentMessages?.length > 0) { gameState.currentMessages.slice(0, 5).forEach(msg => { alertList.innerHTML += `<li class="text-${msg.type || 'secondary'}">[Wk ${msg.week} ${msg.stage}] ${msg.text}</li>`; }); } else { alertList.innerHTML = '<li>No alerts.</li>'; } }

    // START OF FUNCTION displayDrivers (Updated for Stat Changes)
    function displayDrivers() {
        const tbody = document.getElementById('driver-list-tbody');
        const nameFilter = document.getElementById('driver-filter-name').value.toLowerCase();
        const statusFilter = document.getElementById('driver-filter-status').value;
        const replacementInfoDiv = document.getElementById('driver-replacement-info');

        if (!tbody) return;
        tbody.innerHTML = '';

        // --- Filtering Logic ---
        let filteredDrivers = drivers.filter(driver => {
            // Name filter
            if (nameFilter && !driver.name.toLowerCase().includes(nameFilter)) {
                return false;
            }
            // Status filter
            if (statusFilter !== 'all') {
                const isPlayerDriver = driver.teamId === gameState.playerTeamId;
                const isFreeAgent = !driver.teamId;
                const isAIDriver = !isPlayerDriver && !isFreeAgent;

                if (statusFilter === 'player' && !isPlayerDriver) return false;
                if (statusFilter === 'ai' && !isAIDriver) return false;
                if (statusFilter === 'free' && !isFreeAgent) return false;
            }
            return true;
        });

        // --- Sorting Logic ---
        const sortedDrivers = filteredDrivers.sort((a,b) => {
            const teamA = getTeamById(a.teamId)?.name || 'ZZZ'; // Sort Free Agents last
            const teamB = getTeamById(b.teamId)?.name || 'ZZZ';
            return teamA.localeCompare(teamB) || a.name.localeCompare(b.name);
        });

        // --- Update Replacement Info Visibility ---
        if (gameState.driverReplacementInProgress) {
            const outgoingDriver = getDriverById(gameState.driverReplacementInProgress.outgoingDriverId);
            document.getElementById('replacement-outgoing-driver').textContent = outgoingDriver?.name || 'Unknown';
            replacementInfoDiv.classList.remove('hidden');
        } else {
            replacementInfoDiv.classList.add('hidden');
        }


        // --- Render Table Rows ---
        sortedDrivers.forEach(driver => {
            const team = getTeamById(driver.teamId);
            const row = tbody.insertRow();
            let actionButtonHTML = '';
            const isPlayerDriver = driver.teamId === gameState.playerTeamId;
            const isPreSeason = gameState.currentGameStage === 'PreSeason';
            const isReplacing = gameState.driverReplacementInProgress;

            // --- Action Button Logic (remains the same) ---
            if (isPreSeason) {
                if (isReplacing) {
                    if (isPlayerDriver && driver.id === isReplacing.outgoingDriverId) {
                        actionButtonHTML = `<button class="btn btn-secondary btn-sm disabled" disabled>Replacing...</button>`;
                    } else if (driver.id === isReplacing.otherPlayerDriverId) {
                         actionButtonHTML = `<button class="btn btn-secondary btn-sm disabled" disabled>Teammate</button>`;
                    } else {
                         const estimatedCost = calculateReplacementCost(isReplacing.outgoingDriverId, driver.id);
                         const canAfford = gameState.finances.budget >= estimatedCost.total;
                         actionButtonHTML = `<button class="btn ${canAfford ? 'btn-positive' : 'btn-secondary'} btn-sm" ${!canAfford ? 'disabled' : ''} onclick="confirmDriverHire('${driver.id}')" title="Total Cost: ${formatCurrency(estimatedCost.total)} (Break: ${formatCurrency(estimatedCost.breakFee)}, Hire: ${formatCurrency(estimatedCost.hireFee)})">${canAfford ? 'Hire' : 'Funds'}</button>`;
                    }
                } else {
                    if (isPlayerDriver) {
                        actionButtonHTML = `<button class="btn btn-negative btn-sm" onclick="initiateDriverReplace('${driver.id}')">Replace</button>`;
                    } else {
                        actionButtonHTML = `<button class="btn btn-secondary btn-sm" onclick="showDriverDetails('${driver.id}')">View</button>`;
                    }
                }
            } else {
                actionButtonHTML = `<button class="btn btn-secondary btn-sm" onclick="showDriverDetails('${driver.id}')">View</button>`;
            }


            // --- Stat Change Display Logic ---
            const showChanges = isPreSeason && driver.previousStats;
            const statDisplay = (statName) => {
                const currentVal = driver.stats[statName];
                if (showChanges && driver.previousStats[statName] !== undefined) {
                    const diff = Math.round(currentVal - driver.previousStats[statName]); // Ensure integer diff
                    if (diff !== 0) {
                        const sign = diff > 0 ? '+' : '';
                        const colorClass = diff > 0 ? 'text-positive' : 'text-negative';
                        // Use innerHTML for the stat cell to render the span correctly
                        return `${currentVal} <span class="${colorClass}" style="font-size:0.8em;">(${sign}${diff})</span>`;
                    }
                }
                return currentVal; // Return only current value if no change or not PreSeason
            };
            // --- END Stat Change Display Logic ---


            row.style.backgroundColor = isPlayerDriver ? 'rgba(77, 171, 247, 0.1)' : '';
            // --- Use statDisplay helper in innerHTML ---
            row.innerHTML = `
                <td>${driver.name}</td>
                <td style="color:${team?.color || '#fff'}; font-weight: bold;">${team?.name || 'Free Agent'}</td>
                <td>${driver.age}</td>
                <td>${driver.morale}</td>
                <td>${statDisplay('pace')}</td>
                <td>${statDisplay('consistency')}</td>
                <td>${statDisplay('tyreManagement')}</td>
                <td>${statDisplay('overtaking')}/${statDisplay('defending')}</td> <!-- Note: Shows changes for both -->
                <td>${statDisplay('experience')}</td>
                <td>${formatCurrency(driver.contract.salaryPerRace)}</td>
                <td>${driver.contract.expiryYear}</td>
                <td>${actionButtonHTML}</td>`;
        });

        // Reset driver details view
        const detailContent = document.getElementById('driver-detail-content');
        if (detailContent && !detailContent.classList.contains('hidden')) {
             const selectedDriverId = detailContent.dataset.driverId;
             if (isReplacing || !sortedDrivers.some(d => d.id === selectedDriverId)) {
                 document.getElementById('driver-detail-placeholder')?.classList.remove('hidden');
                 detailContent.classList.add('hidden');
                 delete detailContent.dataset.driverId;
             }
        } else if (!isReplacing) {
             document.getElementById('driver-detail-placeholder')?.classList.remove('hidden');
             detailContent?.classList.add('hidden');
        }
    }
    // END OF FUNCTION displayDrivers

    // START OF FUNCTION showDriverDetails (Updated for Stat Changes)
    function showDriverDetails(driverId) {
        const driver = getDriverById(driverId);
        if (!driver || gameState.driverReplacementInProgress) return;
        const team = getTeamById(driver.teamId);
        document.getElementById('driver-detail-placeholder')?.classList.add('hidden');
        const detailContent = document.getElementById('driver-detail-content');
        if (!detailContent) return;
        detailContent.classList.remove('hidden');
        detailContent.dataset.driverId = driverId;

        // --- Stat Change Display Logic Helper ---
        const isPreSeason = gameState.currentGameStage === 'PreSeason';
        const showChanges = isPreSeason && driver.previousStats;
        const statDetailDisplay = (statName) => {
            const currentVal = driver.stats[statName];
            if (showChanges && driver.previousStats[statName] !== undefined) {
                const diff = Math.round(currentVal - driver.previousStats[statName]); // Ensure integer diff
                if (diff !== 0) {
                    const sign = diff > 0 ? '+' : '';
                    const colorClass = diff > 0 ? 'text-positive' : 'text-negative';
                    return `${currentVal} <span class="${colorClass}" style="font-size:0.9em;">(${sign}${diff})</span>`;
                }
            }
            return currentVal;
        };
        // --- END Stat Change Display Logic Helper ---

        document.getElementById('driver-detail-name').innerHTML = `${driver.name} (${driver.age} yrs)`; // Display age
        document.getElementById('driver-detail-team').textContent = team?.name || 'Free Agent';
        document.getElementById('driver-detail-nat').textContent = driver.nationality;
        document.getElementById('driver-detail-morale').textContent = driver.morale; // Morale doesn't use the helper

        // --- Use statDetailDisplay helper for stats ---
        document.getElementById('driver-detail-pace').innerHTML = statDetailDisplay('pace');
        document.getElementById('driver-detail-cons').innerHTML = statDetailDisplay('consistency');
        document.getElementById('driver-detail-tyre').innerHTML = statDetailDisplay('tyreManagement');
        document.getElementById('driver-detail-ovr').innerHTML = statDetailDisplay('overtaking');
        document.getElementById('driver-detail-def').innerHTML = statDetailDisplay('defending');
        document.getElementById('driver-detail-exp').innerHTML = statDetailDisplay('experience');
        // --- END Use statDetailDisplay helper ---

        document.getElementById('driver-detail-salary').textContent = formatCurrency(driver.contract.salaryPerRace);
        document.getElementById('driver-detail-expiry').textContent = driver.contract.expiryYear;

        // --- Negotiate Button Logic (remains the same) ---
        const negotiateBtn = document.getElementById('negotiate-contract-btn');
        if (negotiateBtn) {
            const canNegotiate = driver.teamId === gameState.playerTeamId && driver.contract.expiryYear <= gameState.currentYear + 1;
            negotiateBtn.classList.toggle('disabled', !canNegotiate);
            negotiateBtn.disabled = !canNegotiate;
            negotiateBtn.title = canNegotiate ? "Negotiate contract (feature not implemented)" : (driver.teamId !== gameState.playerTeamId ? "Cannot negotiate with other team's driver" : "Contract not expiring soon");
        }
    }
    // END OF FUNCTION showDriverDetails

    function displayStaff() { const playerTeam = getTeamById(gameState.playerTeamId); const tbody = document.getElementById('staff-list-tbody'); if (!tbody) return; if (!playerTeam || !playerTeam.staff) { tbody.innerHTML = '<tr><td colspan="6">Error: Player staff data not found.</td></tr>'; return; }; tbody.innerHTML = ''; playerTeam.staff.forEach(staff => { const isTraining = gameState.inProgressStaffTraining.some(t => t.staffId === staff.id); const row = tbody.insertRow(); row.innerHTML = `<td>${staff.role}</td><td>${staff.name}</td><td>${staff.level}</td><td>${getStaffEffectDescription(staff)}</td><td class="${isTraining ? 'text-primary' : ''}">${isTraining ? 'Training' : 'Available'}</td><td><button class="btn btn-secondary btn-sm" onclick="showStaffDetails('${staff.id}')">View/Train</button></td>`; }); document.getElementById('staff-detail-placeholder')?.classList.remove('hidden'); document.getElementById('staff-detail-content')?.classList.add('hidden'); }
    function getStaffEffectDescription(staff) { if (!staff.statEffect) return "No direct effect"; let effects = []; if (staff.statEffect.RDSuccessRate) effects.push(`+${(staff.statEffect.RDSuccessRate * (staff.level || 1) * 0.1).toFixed(1)}% R&D`); if (staff.statEffect.AeroDevEffectiveness) effects.push(`+${(staff.statEffect.AeroDevEffectiveness * (staff.level || 1) * 0.1).toFixed(1)}% Aero`); if (staff.statEffect.EngineDevEffectiveness) effects.push(`+${(staff.statEffect.EngineDevEffectiveness * (staff.level || 1) * 0.1).toFixed(1)}% Eng`); if (staff.statEffect.ChassisDevEffectiveness) effects.push(`+${(staff.statEffect.ChassisDevEffectiveness * (staff.level || 1) * 0.1).toFixed(1)}% Cha`); if (staff.statEffect.ReliabilityDevEffectiveness) effects.push(`+${(staff.statEffect.ReliabilityDevEffectiveness * (staff.level || 1) * 0.1).toFixed(1)}% Relia`); if (staff.statEffect.PitStopTime) effects.push(`${(staff.statEffect.PitStopTime * ((staff.level || 1) / 5.0)).toFixed(2)}s Pit`); return effects.join(', ') || "General Support"; }
    function showStaffDetails(staffId) { const staff = getStaffById(gameState.playerTeamId, staffId); if (!staff) return; document.getElementById('staff-detail-placeholder')?.classList.add('hidden'); const detailContent = document.getElementById('staff-detail-content'); if (!detailContent) return; detailContent.classList.remove('hidden'); document.getElementById('staff-detail-name').textContent = staff.name; document.getElementById('staff-detail-role').textContent = staff.role; document.getElementById('staff-detail-level').textContent = staff.level; document.getElementById('staff-detail-effects').textContent = getStaffEffectDescription(staff); const trainingList = document.getElementById('staff-training-list'); if (!trainingList) return; trainingList.innerHTML = ''; const availableTraining = staffTrainingOptions[staff.role] || []; const isCurrentlyTraining = gameState.inProgressStaffTraining.some(t => t.staffId === staff.id); let canTrain = false; if (isCurrentlyTraining) { trainingList.innerHTML = '<li>Staff member is currently training.</li>'; } else { availableTraining.forEach(trainOpt => { if (staff.level >= trainOpt.levelReq) { const canAfford = gameState.finances.budget >= trainOpt.cost; const li = document.createElement('li'); li.style.borderBottom = '1px dotted var(--tab-border)'; li.style.padding = '8px 0'; li.style.overflow = 'hidden'; li.innerHTML = `<div style="float: left; width: 70%;"><strong>${trainOpt.name}</strong> (Lvl ${trainOpt.levelReq}+) <br><small>Cost: ${formatCurrency(trainOpt.cost)} | Dur: ${trainOpt.durationWeeks} Wks | Chance: ${Math.round(trainOpt.successChance * 100)}% | Effect: ${getTrainingEffectDesc(trainOpt.effect)}</small></div><button class="btn ${canAfford ? 'btn-positive' : 'btn-secondary'} btn-sm" style="float: right;" ${!canAfford ? 'disabled' : ''} onclick="startStaffTraining('${staff.id}', '${trainOpt.id}')">${canAfford ? 'Start' : 'Funds'}</button>`; trainingList.appendChild(li); canTrain = true; } }); if (!canTrain && !isCurrentlyTraining) { trainingList.innerHTML = '<li>No suitable training available for current level.</li>'; } } }
    function getTrainingEffectDesc(effect) { if (!effect) return "None"; let effects = []; if (effect.RDSuccessRate) effects.push(`+${effect.RDSuccessRate}% R&D`); if (effect.AeroDevEffectiveness) effects.push(`+${effect.AeroDevEffectiveness}% Aero`); if (effect.EngineDevEffectiveness) effects.push(`+${effect.EngineDevEffectiveness}% Eng`); if (effect.ChassisDevEffectiveness) effects.push(`+${effect.ChassisDevEffectiveness}% Cha`); if (effect.ReliabilityDevEffectiveness) effects.push(`+${effect.ReliabilityDevEffectiveness}% Relia`); if (effect.PitStopTime) effects.push(`${effect.PitStopTime.toFixed(2)}s Pit`); return effects.join(', ') || "Skill"; }
    function displayCarDevelopment() { if (!playerCar || !playerCar.baseStats) { console.error("Player car data is missing!"); return; } document.getElementById('car-stat-aero').textContent = playerCar.baseStats.aero?.toFixed(1) || 0; document.getElementById('car-stat-engine').textContent = playerCar.baseStats.engine?.toFixed(1) || 0; document.getElementById('car-stat-chassis').textContent = playerCar.baseStats.chassis?.toFixed(1) || 0; document.getElementById('car-stat-reliability').textContent = (playerCar.baseStats.reliability || 0).toFixed(1) + '%'; const rdList = document.getElementById('inprogress-rd-list'); if (rdList) { rdList.innerHTML = ''; if (gameState.inProgressDevelopment?.length > 0) { gameState.inProgressDevelopment.forEach(dev => { const upgrade = findUpgradeByIdRecursive(dev.upgradeId); rdList.innerHTML += `<li>${upgrade?.name || 'Unknown'} - ETA: Wk ${dev.targetCompletionWeek} ${dev.targetCompletionStage} (Success: ${Math.round(dev.successChance * 100)}%)</li>`; }); } else { rdList.innerHTML = '<li>No active developments.</li>'; } } const comparisonTbody = document.getElementById('car-comparison-tbody'); if (comparisonTbody) { comparisonTbody.innerHTML = ''; const allCarsData = teams.map(t => getCarData(t.id)).filter(Boolean); if (allCarsData.length > 0) { const statsToCompare = ['aero', 'engine', 'chassis', 'reliability']; statsToCompare.forEach(stat => { let sum = 0; let best = -Infinity; allCarsData.forEach(carData => { const value = carData.baseStats[stat] || 0; sum += value; if (value > best) { best = value; } }); const avg = sum / allCarsData.length; const playerStat = playerCar.baseStats[stat] || 0; const row = comparisonTbody.insertRow(); row.innerHTML = `<td>${stat.charAt(0).toUpperCase() + stat.slice(1)}</td><td class="player-row">${playerStat.toFixed(1)}${stat === 'reliability' ? '%' : ''}</td><td class="avg-row">${avg.toFixed(1)}${stat === 'reliability' ? '%' : ''}</td><td class="best-row">${best.toFixed(1)}${stat === 'reliability' ? '%' : ''}</td>`; }); } else { comparisonTbody.innerHTML = '<tr><td colspan="4">No car data available for comparison.</td></tr>'; } } renderCarComparisonChart(); const playerInfra = infrastructure; for (const partType in playerCar.development) { if (!playerCar.development[partType]) { console.warn(`Development data missing for part type: ${partType}`); continue; } playerCar.development[partType].forEach(upgrade => { const req = upgrade.requiredInfra; upgrade.unlocked = req ? (playerInfra[req.facility] && playerInfra[req.facility].level >= req.level) : true; }); } for (const partType in playerCar.development) { const container = document.getElementById(`${partType}-upgrades`); if (!container) continue; container.innerHTML = ''; if (!playerCar.development[partType]) continue; playerCar.development[partType].forEach(upgrade => { const card = document.createElement('div'); card.className = 'upgrade-card'; const isApplied = playerCar.appliedUpgrades.includes(upgrade.id); const isDeveloping = gameState.inProgressDevelopment.some(dev => dev.upgradeId === upgrade.id); const cost = calculateUpgradeCost(upgrade); const canAfford = gameState.finances.budget >= cost; let statusText = ''; let statusClass = ''; let buttonHTML = ''; if (isApplied) { statusText = 'Applied'; statusClass = 'status-applied'; buttonHTML = `<button class="btn btn-secondary btn-sm disabled" disabled>Applied</button>`; } else if (isDeveloping) { statusText = 'Developing'; statusClass = 'status-developing'; buttonHTML = `<button class="btn btn-secondary btn-sm disabled" disabled>Developing</button>`; } else if (!upgrade.unlocked) { const req = upgrade.requiredInfra; statusText = `Locked (Req: ${req?.facility.toUpperCase()} Lvl ${req?.level})`; statusClass = 'status-locked'; buttonHTML = `<button class="btn btn-secondary btn-sm disabled" disabled>Locked</button>`; } else { statusText = 'Available'; statusClass = 'status-available'; if (!canAfford){ buttonHTML = `<button class="btn btn-secondary btn-sm disabled" disabled>Cannot Afford</button>`; } else { buttonHTML = `<button class="btn btn-positive btn-sm" onclick="startDevelopment('${upgrade.id}')">Develop</button>`; } } let boostText = Object.entries(upgrade.performanceBoost).map(([stat, value]) => `+${value} ${stat}`).join(', '); card.innerHTML = `<strong>${upgrade.name}</strong><em>${upgrade.description}</em><div class="upgrade-details"><span class="upgrade-cost">${formatCurrency(cost)}</span> | <span class="upgrade-benefit">${boostText}</span> | <span class="upgrade-duration">${upgrade.durationWeeks} Wks</span></div><span class="upgrade-status ${statusClass}">${statusText}</span>${buttonHTML}`; container.appendChild(card); }); } }
    function renderCarComparisonChart() { const ctx = document.getElementById('carComparisonChart')?.getContext('2d'); if (!ctx) { console.error("Comparison Chart canvas not found!"); return; } if (typeof Chart === 'undefined') { console.error("Chart.js library not loaded!"); const container = document.getElementById('car-comparison-chart-container'); if(container) container.innerHTML = "<p class='text-negative'>Chart library failed to load. Please check your internet connection.</p>"; return; } const datasets = []; let historyLength = 0; const playerTeamId = gameState.playerTeamId; if (gameState.performanceHistory && gameState.performanceHistory[playerTeamId] && gameState.performanceHistory[playerTeamId].length > 0) { historyLength = gameState.performanceHistory[playerTeamId].length; } else { if (carComparisonChartInstance) { carComparisonChartInstance.destroy(); carComparisonChartInstance = null; } ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.fillStyle = 'var(--secondary-color)'; ctx.textAlign = 'center'; ctx.font = '14px ' + getComputedStyle(document.body).fontFamily; ctx.fillText('Performance history will be charted after the first race.', ctx.canvas.width / 2, ctx.canvas.height / 2); return; } const chartLabels = ["Start"]; for (let i = 1; i < historyLength; i++) { const race = season?.races?.[i - 1]; chartLabels.push(race ? `R${race.calendarId}` : `Post R${i}`); } teams.forEach(team => { const teamHistory = gameState.performanceHistory[team.id]; if (!teamHistory || teamHistory.length === 0) return; const dataPoints = teamHistory.slice(0, historyLength); const lastValue = dataPoints[dataPoints.length - 1]; while (dataPoints.length < historyLength) { dataPoints.push(lastValue); } datasets.push({ label: team.name + (team.id === playerTeamId ? " (You)" : ""), data: dataPoints, borderColor: team.color || '#ffffff', backgroundColor: hexToRgba(team.color || '#ffffff', 0.1), fill: false, tension: 0.1, borderWidth: (team.id === playerTeamId ? 2.5 : 1.5), pointRadius: (team.id === playerTeamId ? 3 : 2), pointHoverRadius: (team.id === playerTeamId ? 5 : 4), order: (team.id === playerTeamId ? 1 : 2) }); }); if (carComparisonChartInstance) { carComparisonChartInstance.destroy(); carComparisonChartInstance = null; } Chart.defaults.color = '#FFFFFF'; Chart.defaults.borderColor = 'var(--tab-border)'; try { carComparisonChartInstance = new Chart(ctx, { type: 'line', data: { labels: chartLabels, datasets: datasets }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { title: { display: true, text: 'Overall Performance Rating', color: '#FFFFFF' }, grid: { color: 'var(--tab-border)' }, ticks: { color: '#FFFFFF' } }, x: { title: { display: true, text: 'Season Progression (Post-Race)', color: '#FFFFFF' }, grid: { color: 'var(--tab-border)' }, ticks: { color: '#FFFFFF' } } }, plugins: { legend: { position: 'bottom', labels: { color: '#FFFFFF', boxWidth: 15, padding: 10 } }, tooltip: { mode: 'index', intersect: false, bodyColor: 'var(--text-color)', titleColor: 'var(--text-color)', backgroundColor: 'var(--header-bg)', borderColor: 'var(--card-border)', borderWidth: 1, padding: 10, displayColors: true, callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += context.parsed.y.toFixed(1); } return label; } } } }, elements: { line: {} }, animation: { duration: 250 } } }); } catch(e) { console.error("Error creating Chart.js instance:", e); if (carComparisonChartInstance) { carComparisonChartInstance.destroy(); carComparisonChartInstance = null; } ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.fillStyle = 'var(--negative-color)'; ctx.textAlign = 'center'; ctx.font = '14px ' + getComputedStyle(document.body).fontFamily; ctx.fillText('Error creating performance chart. Check console.', ctx.canvas.width / 2, ctx.canvas.height / 2); } }
    function displayInfrastructure() { const container = document.getElementById('infrastructure-list'); if (!container) return; container.innerHTML = ''; for (const key in infrastructure) { const facility = infrastructure[key]; const card = document.createElement('div'); card.className = 'info-card infra-card'; const currentLevel = facility.level; const maxLevel = facility.maxLevel; const isMaxLevel = currentLevel >= maxLevel; const upgradeCost = isMaxLevel ? 0 : facility.costPerLevel[currentLevel]; const canAfford = gameState.finances.budget >= upgradeCost; let buttonHTML = ''; if (isMaxLevel) { buttonHTML = `<button class="btn btn-secondary disabled" disabled>Max Level</button>`; } else if (!canAfford) { buttonHTML = `<button class="btn btn-secondary disabled" disabled>Cannot Afford</button>`; } else { buttonHTML = `<button class="btn btn-primary" onclick="investInfrastructure('${key}')">Invest</button>`; } card.innerHTML = `<h4>${facility.name}</h4><p>Level: <strong>${currentLevel} / ${maxLevel}</strong></p><p><em>${facility.benefits}</em></p>${!isMaxLevel ? `<p>Cost to upgrade to Level ${currentLevel + 1}: <span class="upgrade-cost">${formatCurrency(upgradeCost)}</span></p>` : ''}${buttonHTML}`; container.appendChild(card); } }
    function displayFinances() { const finBudgetEl = document.getElementById('finance-budget'); const finSeasonIncomeEl = document.getElementById('finance-season-income'); const finSeasonExpensesEl = document.getElementById('finance-season-expenses'); const finProjBalanceEl = document.getElementById('finance-projected-balance'); const incomeListEl = document.getElementById('income-breakdown'); const expenseListEl = document.getElementById('expense-breakdown'); const historyTbodyEl = document.getElementById('transaction-history-tbody'); if (finBudgetEl) finBudgetEl.textContent = formatCurrency(gameState.finances.budget); if (finSeasonIncomeEl) finSeasonIncomeEl.textContent = formatCurrency(gameState.finances.seasonIncome); if (finSeasonExpensesEl) finSeasonExpensesEl.textContent = formatCurrency(gameState.finances.seasonExpenses); if (finProjBalanceEl && season.races) { const racesRemaining = Math.max(0, RACES_PER_SEASON - gameState.currentRaceIndex); const estimatedBaseIncome = gameState.finances.incomePerRaceBase * racesRemaining; const estimatedSponsorBase = (gameState.activeSponsorContracts?.reduce((sum, c) => sum + c.basePayoutPerRace, 0) || 0) * racesRemaining; const playerDrivers = drivers.filter(d => d.teamId === gameState.playerTeamId); const estimatedFutureSalaries = playerDrivers.reduce((sum, d) => sum + d.contract.salaryPerRace, 0) * racesRemaining; const avgOtherExpensePerRace = gameState.currentRaceIndex > 0 ? (gameState.finances.seasonExpenses - transactionLog.filter(tx => tx.description.includes('Salary')).reduce((s,tx)=>s-tx.amount, 0)) / gameState.currentRaceIndex : 5000000; const estimatedFutureOtherExpenses = avgOtherExpensePerRace * racesRemaining; const projectedBalance = gameState.finances.budget + estimatedBaseIncome + estimatedSponsorBase - estimatedFutureSalaries - estimatedFutureOtherExpenses; finProjBalanceEl.textContent = formatCurrency(projectedBalance); } let incomeSponsorBase = 0, incomeSponsorBonus = 0, expenseDev = 0, expenseInfra = 0, expenseSalary = 0, expenseTraining = 0, expenseTransfer = 0; transactionLog.forEach(tx => { if (tx.amount > 0) { if (tx.description.includes("Sponsor Bonus")) incomeSponsorBonus += tx.amount; else if (tx.description.includes("Race Income")) incomeSponsorBase += tx.amount; } else { if (tx.description.includes("R&D")) expenseDev += -tx.amount; else if (tx.description.includes("Infrastructure")) expenseInfra += -tx.amount; else if (tx.description.includes("Salary")) expenseSalary += -tx.amount; else if (tx.description.includes("Training")) expenseTraining += -tx.amount; else if (tx.description.includes("Driver Transfer")) expenseTransfer += -tx.amount; } }); if (incomeListEl) { incomeListEl.innerHTML = `<li>Race Base Income (Est): <span class="text-positive">${formatCurrency(gameState.finances.incomePerRaceBase * gameState.currentRaceIndex)}</span></li><li>Sponsor Income (Base - Est): <span class="text-positive">${formatCurrency(incomeSponsorBase)}</span></li><li>Sponsor Income (Bonus): <span class="text-positive">${formatCurrency(incomeSponsorBonus)}</span></li><li>Prize Money (Est.): <span class="text-positive">[Not Implemented]</span></li><li><strong>Total Income:</strong> <span class="text-positive bold">${formatCurrency(gameState.finances.seasonIncome)}</span></li>`; } if (expenseListEl) { expenseListEl.innerHTML = `<li>Car Development: <span class="text-negative">${formatCurrency(expenseDev)}</span></li><li>Infrastructure: <span class="text-negative">${formatCurrency(expenseInfra)}</span></li><li>Staff Training: <span class="text-negative">${formatCurrency(expenseTraining)}</span></li><li>Driver Salaries: <span class="text-negative">${formatCurrency(expenseSalary)}</span></li><li>Driver Transfers: <span class="text-negative">${formatCurrency(expenseTransfer)}</span></li><li>Staff Salaries (Est): <span class="text-negative">[Needs Tracking]</span></li><li><strong>Total Expenses:</strong> <span class="text-negative bold">${formatCurrency(gameState.finances.seasonExpenses)}</span></li>`; } if (historyTbodyEl) { historyTbodyEl.innerHTML = ''; if (transactionLog.length === 0) { historyTbodyEl.innerHTML = '<tr><td colspan="4">No transactions yet.</td></tr>'; } else { transactionLog.forEach(tx => { const row = historyTbodyEl.insertRow(); row.innerHTML = `<td>Wk ${tx.week} ${tx.stage}</td><td>${tx.description}</td><td class="${tx.amount < 0 ? 'text-negative' : 'text-positive'}">${formatCurrency(tx.amount)}</td><td>${formatCurrency(tx.balance)}</td>`; }); } } }
    function displaySponsors() { const selectionUI = document.getElementById('sponsor-selection-ui'); const activeUI = document.getElementById('active-sponsors-ui'); const offerList = document.getElementById('sponsor-offer-list'); const activeList = document.getElementById('active-sponsor-list'); const confirmBtn = document.getElementById('confirm-sponsors-btn'); const yearSpanSelect = document.getElementById('sponsor-select-year'); const yearSpanActive = document.getElementById('active-sponsor-year'); const slotsSpan = document.getElementById('sponsor-slots-available'); if (!selectionUI || !activeUI || !offerList || !activeList || !confirmBtn || !yearSpanSelect || !yearSpanActive || !slotsSpan) { console.warn("Sponsor UI elements not found."); return; } if (gameState.currentGameStage === 'PreSeason') { selectionUI.classList.remove('hidden'); activeUI.classList.add('hidden'); yearSpanSelect.textContent = gameState.currentYear; slotsSpan.textContent = SPONSOR_SLOTS - gameState.selectedSponsors.length; offerList.innerHTML = ''; potentialSponsors.forEach(sponsor => { const isSelected = gameState.selectedSponsors.includes(sponsor.id); const canSelectMore = gameState.selectedSponsors.length < SPONSOR_SLOTS; const card = document.createElement('div'); card.className = 'info-card sponsor-offer'; card.style.borderLeftColor = sponsor.tier === 1 ? 'var(--accent-color)' : sponsor.tier === 2 ? 'var(--primary-color)' : 'var(--secondary-color)'; let objectivesHTML = '<h5>Objectives:</h5><ul>'; sponsor.objectives.forEach(obj => { objectivesHTML += `<li>${obj.description} (+${formatCurrency(obj.reward)})</li>`; }); objectivesHTML += '</ul>'; card.innerHTML = `<h4>${sponsor.name} (Tier ${sponsor.tier})</h4><p>Base / Race: ${formatCurrency(sponsor.basePayoutPerRace)} | Difficulty: ${sponsor.difficulty}</p>${objectivesHTML}<button class="btn ${isSelected ? 'btn-negative' : (canSelectMore ? 'btn-positive' : 'btn-secondary disabled') } btn-sm" style="float: right;" onclick="toggleSponsorSelection('${sponsor.id}')" ${!isSelected && !canSelectMore ? 'disabled' : ''}>${isSelected ? 'Deselect' : (canSelectMore ? 'Select' : 'Slots Full')}</button>`; offerList.appendChild(card); }); confirmBtn.classList.toggle('hidden', gameState.selectedSponsors.length !== SPONSOR_SLOTS); } else { selectionUI.classList.add('hidden'); activeUI.classList.remove('hidden'); yearSpanActive.textContent = gameState.currentYear; activeList.innerHTML = ''; if (!gameState.activeSponsorContracts || gameState.activeSponsorContracts.length === 0) { activeList.innerHTML = '<div class="info-card"><p>No active sponsors.</p></div>'; return; } gameState.activeSponsorContracts.forEach(contract => { const sponsor = potentialSponsors.find(s => s.id === contract.sponsorId); if (!sponsor) return; const card = document.createElement('div'); card.className = 'info-card active-sponsor-card'; card.style.borderLeftColor = sponsor.tier === 1 ? 'var(--accent-color)' : sponsor.tier === 2 ? 'var(--primary-color)' : 'var(--secondary-color)'; let objectivesHTML = ''; contract.objectives.forEach(obj => { let progressText = ''; let progressPercent = 0; const deadlineWeek = contract.startWeek + (obj.durationWeeks || 0) - 1; if (obj.complete) { progressText = 'Completed!'; progressPercent = 100; } else if (obj.expired) { progressText = `Expired (Deadline Wk ${deadlineWeek})`; progressPercent = 0; } else { if (obj.type === 'consecutive_points') { progressText = `Progress: ${obj.progress || 0}/${obj.target} (Deadline Wk ${deadlineWeek})`; progressPercent = ((obj.progress || 0) / obj.target) * 100; } else if (obj.type === 'team_standing_top' || obj.type === 'team_standing_mid') { const currentRank = getCurrentTeamRank(gameState.playerTeamId); progressText = `Target: Top ${obj.target} (Current: ${currentRank || 'N/A'})`; progressPercent = currentRank ? Math.max(0, 100 - ((currentRank - 1) / (obj.target -1 )) * 100) : 0; } else if (obj.type === 'podium_finish' || obj.type === 'win_race') { progressText = obj.achieved ? 'Achieved!' : `Pending (Deadline Wk ${deadlineWeek})`; progressPercent = obj.achieved ? 100 : 0; } else { progressText = `Pending (Per Race)`; progressPercent = 0; } } objectivesHTML += `<div class="sponsor-objective"><p><strong>Objective:</strong> ${obj.description}</p><p>Reward: ${formatCurrency(obj.reward)} | Status: <span class="text-secondary">${progressText}</span></p><div class="objective-progress-bar"><div style="width: ${progressPercent}%; background-color: ${obj.complete ? 'var(--positive-color)' : (obj.expired ? 'var(--negative-color)' : 'var(--primary-color)')};"></div></div></div>`; }); card.innerHTML = `<h4>${sponsor.name}</h4><p>Base / Race: ${formatCurrency(contract.basePayoutPerRace)}</p>${objectivesHTML}`; activeList.appendChild(card); }); } }
    function displaySeasonCalendar() { const yearEl = document.getElementById('season-tab-year'); const indexEl = document.getElementById('current-race-index-display'); const calendarList = document.getElementById('race-calendar-list'); const upcomingNameEl = document.getElementById('upcoming-race-name'); const upcomingTrackEl = document.getElementById('upcoming-track-name'); const upcomingLapsEl = document.getElementById('upcoming-laps'); const upcomingCharsEl = document.getElementById('upcoming-track-chars'); const upcomingQualiEl = document.getElementById('upcoming-quali-result'); const upcomingRaceEl = document.getElementById('upcoming-race-result'); if (yearEl) yearEl.textContent = gameState.currentYear; if (indexEl) indexEl.textContent = `${gameState.currentRaceIndex + 1}`; if (!calendarList) return; calendarList.innerHTML = ''; season.races.forEach((race, index) => { const li = document.createElement('li'); li.textContent = `#${race.calendarId} ${race.name}`; const raceLog = gameState.raceResultsLog.find(r => r.raceId === race.id); if (index < gameState.currentRaceIndex) { li.classList.add('completed-race'); const playerResults = raceLog?.race?.filter(r => getDriverById(r.driverId)?.teamId === gameState.playerTeamId).sort((a,b)=>a.position - b.position); if(playerResults && playerResults.length > 0) { li.innerHTML += `<span class="result">P${playerResults[0].position}</span>`; } else if (raceLog) { li.innerHTML += `<span class="result">N/A</span>`; } } else if (index === gameState.currentRaceIndex) { li.classList.add('next-race'); if(upcomingNameEl) upcomingNameEl.textContent = race.name; if(upcomingTrackEl) upcomingTrackEl.textContent = trackNameFromId(race.id); if(upcomingLapsEl) upcomingLapsEl.textContent = race.laps; if(upcomingCharsEl) upcomingCharsEl.textContent = `Aero: ${Math.round(race.aeroDep*100)}% Eng: ${Math.round(race.engineDep*100)}% Cha: ${Math.round(race.chassisDep*100)}% Wear: ${race.tyreWearRate}x Ovr: ${Math.round(100-(race.overtakingDifficulty*100))}%`; const playerQualiResults = raceLog?.quali?.filter(r => getDriverById(r.driverId)?.teamId === gameState.playerTeamId).sort((a,b)=>a.position - b.position); const playerRaceResults = raceLog?.race?.filter(r => getDriverById(r.driverId)?.teamId === gameState.playerTeamId).sort((a,b)=>a.position - b.position); if (upcomingQualiEl) upcomingQualiEl.textContent = playerQualiResults?.length > 0 ? `P${playerQualiResults[0].position}` : '[Not run yet]'; if (upcomingRaceEl) upcomingRaceEl.textContent = playerRaceResults?.length > 0 ? `P${playerRaceResults[0].position}` : '[Not run yet]'; } calendarList.appendChild(li); }); }
    function trackNameFromId(id) { return baseRaceCalendar?.find(r => r.id === id)?.name.replace(' GP', '') || 'Unknown Track'; }
    function displayLeaderboard() { const yearEl = document.getElementById('leaderboard-tab-year'); const driverTbody = document.getElementById('driver-leaderboard-tbody'); const teamTbody = document.getElementById('constructor-leaderboard-tbody'); if (yearEl) yearEl.textContent = gameState.currentYear; if (!driverTbody || !teamTbody) return; leaderboard.drivers.sort((a, b) => b.points - a.points); driverTbody.innerHTML = ''; leaderboard.drivers.forEach((entry, index) => { const driver = getDriverById(entry.driverId); const team = getTeamById(driver?.teamId); if (!driver) return; const row = driverTbody.insertRow(); row.style.backgroundColor = driver.teamId === gameState.playerTeamId ? 'rgba(77, 171, 247, 0.1)' : ''; row.innerHTML = `<td>${index + 1}</td><td>${driver.name}</td><td style="color:${team?.color || '#fff'}; font-weight: bold;">${team?.name || 'N/A'}</td><td>${entry.points}</td>`; }); leaderboard.teams.forEach(teamEntry => { teamEntry.points = leaderboard.drivers.filter(d => d.teamId === teamEntry.teamId).reduce((sum, d) => sum + d.points, 0); }); leaderboard.teams.sort((a, b) => b.points - a.points); teamTbody.innerHTML = ''; leaderboard.teams.forEach((entry, index) => { const team = getTeamById(entry.teamId); if (!team) return; const row = teamTbody.insertRow(); row.style.backgroundColor = team.id === gameState.playerTeamId ? 'rgba(77, 171, 247, 0.1)' : ''; row.innerHTML = `<td>${index + 1}</td><td style="color:${team?.color || '#fff'}; font-weight: bold;">${team.name}</td><td>${entry.points}</td>`; }); }
    function displayRaceSim() { const statusMsg = document.getElementById('race-sim-status-msg'); const title = document.getElementById('race-sim-title'); const preRaceLayout = document.getElementById('pre-race-layout'); const simContent = document.getElementById('race-sim-content'); const strategyArea = document.getElementById('player-strategy-area'); const confirmStrategyBtn = document.getElementById('confirm-strategy-btn'); const selectedStratEl = document.getElementById('selected-strategy-display'); const qualiArea = document.getElementById('quali-results-area'); const raceResultsArea = document.getElementById('race-results-area'); if (!statusMsg || !simContent || !strategyArea || !confirmStrategyBtn || !selectedStratEl || !qualiArea || !raceResultsArea || !title || !preRaceLayout) return; statusMsg.classList.add('hidden'); preRaceLayout.classList.add('hidden'); simContent.classList.add('hidden'); qualiArea.classList.add('hidden'); strategyArea.classList.add('hidden'); raceResultsArea.classList.add('hidden'); title.textContent = "Race Simulation & Strategy"; const currentRace = season?.races?.[gameState.currentRaceIndex]; if (gameState.currentGameStage === 'PreRace') { preRaceLayout.classList.remove('hidden'); qualiArea.classList.remove('hidden'); strategyArea.classList.remove('hidden'); populateQualiResultsTable(); populateStrategyOptions(currentRace); confirmStrategyBtn.disabled = !!gameState.playerStrategy; selectedStratEl.textContent = gameState.playerStrategy?.name || 'None'; title.textContent = `Prepare for ${currentRace?.name || 'Race'}`; } else if (gameState.currentGameStage === 'Race') { simContent.classList.remove('hidden'); updateRaceSimUI(); updateSpeedButtonUI(); title.textContent = `${currentRace?.name || 'Race'} In Progress`; } else if (gameState.currentGameStage === 'PostRace') { raceResultsArea.classList.remove('hidden'); populateFinalRaceResultsTable(); title.textContent = `Final Results - ${currentRace?.name || 'Race'}`; } else { statusMsg.classList.remove('hidden'); statusMsg.textContent = "Waiting for PreRace, Race, or PostRace Stage..."; } }
    function populateQualiResultsTable() { const tbody = document.getElementById('quali-results-tbody'); const trackNameEl = document.getElementById('quali-results-track-name'); const currentRace = season?.races?.[gameState.currentRaceIndex]; if (trackNameEl && currentRace) { trackNameEl.textContent = currentRace.name; } else if (trackNameEl) { trackNameEl.textContent = "N/A"; } const raceLog = gameState.raceResultsLog.find(r => r.raceId === currentRace?.id); if (!tbody || !raceLog || !raceLog.quali || raceLog.quali.length === 0) { tbody.innerHTML = '<tr><td colspan="4">Qualifying not run yet or data missing.</td></tr>'; return; } tbody.innerHTML = ''; raceLog.quali.forEach(result => { const driver = getDriverById(result.driverId); const team = getTeamById(driver?.teamId); const row = tbody.insertRow(); row.style.backgroundColor = driver?.teamId === gameState.playerTeamId ? 'rgba(77, 171, 247, 0.1)' : ''; row.innerHTML = `<td>${result.position}</td><td>${driver?.name || '??'}</td><td style="color:${team?.color || '#fff'}; font-weight: bold;">${team?.name || 'N/A'}</td><td>${result.lapTime.toFixed(3)}</td>`; }); }
    function populateFinalRaceResultsTable() { const tbody = document.getElementById('race-results-tbody'); const trackNameEl = document.getElementById('final-results-track-name'); const currentRace = season?.races?.[gameState.currentRaceIndex]; if (trackNameEl && currentRace) { trackNameEl.textContent = currentRace.name; } else if (trackNameEl) { trackNameEl.textContent = "N/A"; } const raceLog = gameState.raceResultsLog.find(r => r.raceId === currentRace?.id); if (!tbody || !raceLog || !raceLog.race || raceLog.race.length === 0) { tbody.innerHTML = '<tr><td colspan="6">Race not run yet or data missing.</td></tr>'; return; } tbody.innerHTML = ''; const sortedResults = [...raceLog.race].sort((a, b) => a.position - b.position); sortedResults.forEach(result => { const driver = getDriverById(result.driverId); const team = getTeamById(driver?.teamId); const row = tbody.insertRow(); let statusClass = ''; if (result.status === 'Retired') statusClass = 'text-negative'; else if (result.status === 'Finished') statusClass = 'text-positive'; else statusClass = 'text-secondary'; row.style.backgroundColor = driver?.teamId === gameState.playerTeamId ? 'rgba(77, 171, 247, 0.1)' : ''; row.innerHTML = `<td>${result.position}</td><td>${driver?.name || '??'}</td><td style="color:${team?.color || '#fff'}; font-weight: bold;">${team?.name || 'N/A'}</td><td class="${statusClass}">${result.status}</td><td>${result.points || 0}</td><td>${result.lapsCompleted}</td>`; }); }
    function updateRaceSimUI() { if (!liveLeaderboardData || !document.getElementById('RaceSim')?.classList.contains('active-content')) return; const lapDisplay = document.getElementById('race-lap-display'); if(lapDisplay) lapDisplay.textContent = `Lap: ${liveLeaderboardData.lap || 0} / ${liveLeaderboardData.totalLaps || 'N/A'}`; const leaderboardDiv = document.getElementById('race-sim-leaderboard'); if (leaderboardDiv) { leaderboardDiv.innerHTML = ''; liveLeaderboardData.drivers.forEach((driverData, index) => { const driver = getDriverById(driverData.driverId); const team = getTeamById(driver?.teamId); const pos = index + 1; const gap = index === 0 || driverData.gapToLeader === Infinity ? '+0.000' : `+${(driverData.gapToLeader || 0).toFixed(3)}`; const interval = index === 0 || driverData.gapToPrevious === Infinity ? '-' : `+${(driverData.gapToPrevious || 0).toFixed(3)}`; const tyre = driverData.currentTyre; const tyreInfo = tyre ? `<span style="color: ${tyreSpecs[tyre.compound]?.color || '#fff'}; font-weight: bold; background: #333; padding: 0 2px; border-radius: 2px;">${tyre.compound.slice(0,1)}</span>(${tyre.age})` : 'N/A'; let statusClass = ''; let pointsText = ''; if (driverData.status === 'Retired') statusClass = 'text-negative'; else if (driverData.status === 'Pitting') statusClass = 'text-accent'; else if (driverData.status === 'Finished') { statusClass = 'text-secondary'; pointsText = ` (${driverData.points || 0}pts)`; } leaderboardDiv.innerHTML += `<p>${pos}. <strong style="color:${team?.color || '#fff'};">${driver?.name || '???' }</strong> | ${gap} | Int: ${interval} | Last: ${driverData.lastLapTime?.toFixed(3) || '-'} | ${tyreInfo} ${driverData.pitStops}P | <span class="${statusClass}">${driverData.status}${pointsText}</span></p>`; }); } const eventsUl = document.getElementById('race-sim-events'); if (eventsUl) { eventsUl.innerHTML = ''; liveLeaderboardData.events?.slice(-10).reverse().forEach(event => { const li = document.createElement('li'); li.textContent = event; eventsUl.appendChild(li); }); } }
    function updateUI() { try { updateHeader(); const activeTabContent = document.querySelector('.tab-content.active-content'); if (activeTabContent) { const tabId = activeTabContent.id; const displayFunctionName = `display${tabId}`; const overviewUpdateName = `updateOverviewTab`; if (typeof window[displayFunctionName] === 'function') { window[displayFunctionName](); } else if (tabId === 'Overview' && typeof window[overviewUpdateName] === 'function') { window[overviewUpdateName](); } else { if (typeof updateOverviewTab === 'function') updateOverviewTab(); } } else { if (typeof updateOverviewTab === 'function') updateOverviewTab(); } const requiresStrategy = (gameState.currentGameStage === 'PreRace' && !gameState.playerStrategy); const requiresSponsors = (gameState.currentGameStage === 'PreSeason' && (!gameState.activeSponsorContracts || gameState.activeSponsorContracts.length === 0)); setTimeout(() => { if (requiresStrategy) { addPlayerMessage("Select Race Strategy on Race tab!", "warning"); } if (requiresSponsors) { addPlayerMessage("Select Sponsors on Sponsors tab!", "warning"); } }, 100); } catch (error) { console.error("Error during UI Update:", error); addPlayerMessage("Error updating UI. Check console.", "error"); } }

    // ==========================================================================
    // DRIVER MARKET FUNCTIONS (PreSeason Only)
    // ==========================================================================
    function initiateDriverReplace(outgoingDriverId) { if (gameState.currentGameStage !== 'PreSeason' || gameState.driverReplacementInProgress) { return; } const playerDrivers = drivers.filter(d => d.teamId === gameState.playerTeamId); const otherPlayerDriver = playerDrivers.find(d => d.id !== outgoingDriverId); gameState.driverReplacementInProgress = { outgoingDriverId: outgoingDriverId, otherPlayerDriverId: otherPlayerDriver?.id }; addPlayerMessage(`Select a replacement for ${getDriverById(outgoingDriverId)?.name}. Check driver list for 'Hire' options.`, 'info'); displayDrivers(); updateHeader(); }
    function cancelDriverReplace() { if (gameState.driverReplacementInProgress) { addPlayerMessage('Driver replacement cancelled.', 'info'); gameState.driverReplacementInProgress = null; displayDrivers(); updateHeader(); } }
    function calculateReplacementCost(outgoingDriverId, incomingDriverId) { const outgoingDriver = getDriverById(outgoingDriverId); const incomingDriver = getDriverById(incomingDriverId); const playerTeam = getTeamById(gameState.playerTeamId); if (!outgoingDriver || !incomingDriver || !playerTeam) { return { total: Infinity, breakFee: Infinity, hireFee: Infinity }; } let breakFee = 0; const remainingYears = outgoingDriver.contract.expiryYear - gameState.currentYear; if (remainingYears > 0) { breakFee = remainingYears * outgoingDriver.contract.salaryPerRace * RACES_PER_SEASON * 0.5; } let hireFee = 0; const baseHireFee = calculateSalaryPerRace(incomingDriver, playerTeam.reputation) * 5; const repPenalty = Math.max(0, (75 - playerTeam.reputation) * 200000); hireFee += baseHireFee + repPenalty; if (incomingDriver.teamId && incomingDriver.teamId !== gameState.playerTeamId) { hireFee += Math.max(5000000, incomingDriver.contract.salaryPerRace * RACES_PER_SEASON * 0.8); } return { total: Math.round(breakFee + hireFee), breakFee: Math.round(breakFee), hireFee: Math.round(hireFee) }; }
    function confirmDriverHire(incomingDriverId) { if (!gameState.driverReplacementInProgress) return; const outgoingDriverId = gameState.driverReplacementInProgress.outgoingDriverId; const outgoingDriver = getDriverById(outgoingDriverId); const incomingDriver = getDriverById(incomingDriverId); const playerTeam = getTeamById(gameState.playerTeamId); if (!outgoingDriver || !incomingDriver || !playerTeam) { addPlayerMessage("Error finding drivers for transfer.", "error"); return; } const cost = calculateReplacementCost(outgoingDriverId, incomingDriverId); if (gameState.finances.budget < cost.total) { addPlayerMessage(`Insufficient funds to hire ${incomingDriver.name}. Need ${formatCurrency(cost.total)}.`, "warning"); return; } const confirmationMessage = `Replace ${outgoingDriver.name} with ${incomingDriver.name}?\n\nCost Breakdown:\n- Contract Break Fee: ${formatCurrency(cost.breakFee)}\n- Hiring Fee: ${formatCurrency(cost.hireFee)}\n- TOTAL COST: ${formatCurrency(cost.total)}\n\nConfirm transfer?`; if (confirm(confirmationMessage)) { gameState.finances.budget -= cost.total; gameState.finances.seasonExpenses += cost.total; logTransaction(`Driver Transfer: Hire ${incomingDriver.name}, Release ${outgoingDriver.name}`, -cost.total, gameState.finances.budget); outgoingDriver.teamId = null; outgoingDriver.morale = Math.max(10, outgoingDriver.morale - 5); // Morale hit (was -25)
        outgoingDriver.contract.salaryPerRace = 0; incomingDriver.teamId = gameState.playerTeamId; incomingDriver.morale = Math.min(100, incomingDriver.morale + 5); // Morale boost (was +10)
        incomingDriver.contract.salaryPerRace = calculateSalaryPerRace(incomingDriver, playerTeam.reputation); incomingDriver.contract.expiryYear = gameState.currentYear + 2; addPlayerMessage(`Successfully hired ${incomingDriver.name} and released ${outgoingDriver.name}! Cost: ${formatCurrency(cost.total)}`, "success"); gameState.driverReplacementInProgress = null; displayDrivers(); updateOverviewTab(); updateHeader(); } }

    // ==========================================================================
    // CORE GAME LOOP & STATE CHANGES (Implementations)
    // ==========================================================================
    // START OF FUNCTION advanceTime (Updated for Stat Change Clearing)
    function advanceTime() {
        const requiresStrategy = (gameState.currentGameStage === 'PreRace' && !gameState.playerStrategy);
        const requiresSponsors = (gameState.currentGameStage === 'PreSeason' && (!gameState.activeSponsorContracts || gameState.activeSponsorContracts.length === 0));
         if (gameState.currentGameStage === 'Race' || requiresStrategy || requiresSponsors || gameState.driverReplacementInProgress) {
            console.warn("Cannot advance time. Stage:", gameState.currentGameStage, "Requires Strategy:", requiresStrategy, "Requires Sponsors:", requiresSponsors, "Replacing Driver:", !!gameState.driverReplacementInProgress);
             updateUI(); return;
        }

        let nextStage = ''; let nextWeek = gameState.currentWeek; let nextRaceIndex = gameState.currentRaceIndex; let nextYear = gameState.currentYear; let stageChanged = true;
        const previousStage = gameState.currentGameStage;

        switch (previousStage) {
            case 'PreSeason': nextStage = 'StartOfWeek'; nextWeek = 1; break;
            case 'StartOfWeek': nextStage = 'Qualifying'; break;
            case 'Qualifying': nextStage = 'PreRace'; break;
            case 'PreRace': nextStage = 'Race'; break;
            case 'Race': nextStage = 'PostRace'; break;
            case 'PostRace':
                if (gameState.currentRaceIndex >= season.races.length - 1) { nextStage = 'EndOfSeason'; }
                else { nextStage = 'StartOfWeek'; nextWeek++; nextRaceIndex++; }
                break;
            case 'EndOfSeason': nextStage = 'PreSeason'; nextYear = gameState.currentYear + 1; nextRaceIndex = 0; nextWeek = 0; break;
            default: console.error("Unknown game stage:", previousStage); stageChanged = false; break;
        }

        if (!stageChanged) return;
        console.log(`Advancing Time from ${previousStage} (Wk ${gameState.currentWeek}) to ${nextStage} (Wk ${nextWeek})`);

        try { processCompletedDevelopment(nextWeek, nextStage); processCompletedStaffTraining(nextWeek, nextStage); }
        catch (error) { console.error("Error processing completed tasks:", error); addPlayerMessage("Error processing development/training. Check console.", "error"); }

        if (previousStage === 'EndOfSeason' && nextStage === 'PreSeason') {
            handleEndOfSeason(); // Process stats, contracts etc. *before* year change
            handleYearChange(); // Increment year, reset budgets, degrade cars, etc.
        } else {
            gameState.currentWeek = nextWeek; gameState.currentRaceIndex = nextRaceIndex;
        }
        gameState.currentGameStage = nextStage;

        try {
            switch (gameState.currentGameStage) {
                case 'StartOfWeek': updateSponsorObjectiveStatus(true); runAIActions(); break;
                case 'Qualifying': runQualifyingSimulation(); openTab(null, 'RaceSim'); break;
                case 'PreRace': break;
                case 'Race': initializeRaceSimulation(); runRaceSimulation(); break;
                case 'PostRace': console.log("Entered PostRace stage."); break;
                case 'EndOfSeason': break; // Logic now in handleEndOfSeason
                case 'PreSeason': gameState.selectedSponsors = []; gameState.playerStrategy = null; gameState.activeSponsorContracts = []; ensureFullGrid(); break;
            }
        } catch (error) { console.error(`Error during ${gameState.currentGameStage} stage actions:`, error); addPlayerMessage(`Error during ${gameState.currentGameStage} stage. Check console.`, "error"); }

        // --- Actions when LEAVING the PREVIOUS stage ---
        if (previousStage === 'PostRace') {
             deductSalaries(); gameState.playerStrategy = null; recordPerformanceHistory();
        }
        // ADDED: Clear previous stats when leaving PreSeason
        if (previousStage === 'PreSeason') {
            console.log("Leaving PreSeason, clearing previous driver stats indicators.");
            drivers.forEach(driver => {
                delete driver.previousStats;
            });
        }
        // END ADDED

        updateUI();

        if (previousStage === 'PostRace') { console.log("Transitioned from PostRace, switching to Overview tab."); openTab(null, 'Overview'); }
    }
    // END OF FUNCTION advanceTime

    // START OF FUNCTION handleYearChange (Updated for Age Increment)
    function handleYearChange() {
        // --- Increment driver age ---
        drivers.forEach(driver => {
            driver.age++;
        });
        console.log("Incremented driver ages.");
        // --- END Age Increment ---

        gameState.finances.seasonIncome = 0; gameState.finances.seasonExpenses = 0; transactionLog = [];
        gameState.raceResultsLog = []; gameState.activeSponsorContracts = [];
        gameState.currentYear++; season.year = gameState.currentYear; gameState.currentRaceIndex = 0; gameState.currentWeek = 0;
        leaderboard.drivers.forEach(d => d.points = 0); leaderboard.teams.forEach(t => t.points = 0);
        gameState.performanceHistory = {}; teams.forEach(t => { gameState.performanceHistory[t.id] = []; });
        addPlayerMessage(`Welcome to the ${gameState.currentYear} season!`, "success");

        playerCar.baseStats.aero = Math.max(40, playerCar.baseStats.aero - 5);
        playerCar.baseStats.engine = Math.max(40, playerCar.baseStats.engine - 3);
        playerCar.baseStats.chassis = Math.max(40, playerCar.baseStats.chassis - 4);
        playerCar.baseStats.reliability = Math.max(70, playerCar.baseStats.reliability - 10);
        playerCar.appliedUpgrades = []; gameState.inProgressDevelopment = []; gameState.inProgressStaffTraining = [];

        const finalTeamStandings = [...leaderboard.teams].sort((a, b) => b.points - a.points);
        teams.forEach((team, index) => {
             if (team.id !== gameState.playerTeamId) {
                 const car = aiCarData[team.id];
                 if (car) {
                     car.baseStats.aero = Math.max(40, car.baseStats.aero - 5);
                     car.baseStats.engine = Math.max(40, car.baseStats.engine - 3);
                     car.baseStats.chassis = Math.max(40, car.baseStats.chassis - 4);
                     car.baseStats.reliability = Math.max(70, car.baseStats.reliability - 10);
                     car.appliedUpgrades = [];
                 }
                 const rank = finalTeamStandings.findIndex(t => t.teamId === team.id) + 1 || teams.length;
                 const prizeMoney = Math.max(0, (teams.length - rank + 1) * 4000000);
                 const reputationBonus = team.reputation * 200000;
                 const currentBudget = team.budget || 50000000;
                 team.budget = Math.max(30000000, currentBudget * 0.5) + prizeMoney + reputationBonus;
                 console.log(`AI Team ${team.name} Year Start Budget: ${formatCurrency(team.budget)} (Rank ${rank})`);
             }
        });
        recordPerformanceHistory(); shuffleAndAssignRaceCalendar();
    }
    // END OF FUNCTION handleYearChange

    // ==========================================================================
    // DEVELOPMENT & INFRASTRUCTURE & STAFF TRAINING (Implementations)
    // ==========================================================================
    function findUpgradeByIdRecursive(upgradeId) { if (!playerCar?.development) return null; for (const partType in playerCar.development) { const found = playerCar.development[partType]?.find(upg => upg.id === upgradeId); if (found) return found; } return null; }
    function calculateUpgradeCost(upgrade) { if (!upgrade) return Infinity; let cost = upgrade.cost; const playerInfra = infrastructure; const facilityKey = upgrade.requiredInfra?.facility; if (facilityKey && playerInfra[facilityKey]?.benefits.includes("Reduces")) { const facility = playerInfra[facilityKey]; const discountPerLevel = 0.05; cost *= Math.max(0.5, 1.0 - ((facility.level - 1) * discountPerLevel)); } const factory = playerInfra.factory; if (factory && factory.benefits.includes("Reduces cost")) { const factoryDiscountPerLevel = 0.02; cost *= Math.max(0.8, 1.0 - ((factory.level - 1) * factoryDiscountPerLevel)); } return Math.max(1, Math.round(cost)); }
    function calculateDevelopmentDuration(upgrade) { let weeks = upgrade.durationWeeks; const factory = infrastructure.factory; if (factory && factory.benefits.includes("Reduces upgrade *duration*")) { const reductionPerLevel = 0.03; weeks *= Math.max(0.5, 1.0 - ((factory.level - 1) * reductionPerLevel)); } return Math.max(1, Math.round(weeks)); }
    function calculateSuccessChance(baseChance) { let chance = baseChance; const techDir = getTeamById(gameState.playerTeamId)?.staff.find(s => s.role === 'Technical Director'); if(techDir && techDir.statEffect?.RDSuccessRate) { chance += (techDir.statEffect.RDSuccessRate * techDir.level * 0.001); } return Math.min(0.99, Math.max(0.10, chance)); }
    function startDevelopment(upgradeId) { const upgrade = findUpgradeByIdRecursive(upgradeId); if (!upgrade) { addPlayerMessage(`Upgrade [${upgradeId}] not found.`, "error"); return; } if (!upgrade.unlocked){ addPlayerMessage(`Cannot start locked development: ${upgrade.name}.`, "warning"); return; } if (gameState.inProgressDevelopment.some(d => d.upgradeId === upgradeId)){ addPlayerMessage(`${upgrade.name} is already in development.`, "warning"); return; } if (playerCar.appliedUpgrades.includes(upgradeId)){ addPlayerMessage(`${upgrade.name} has already been applied.`, "warning"); return; } const cost = calculateUpgradeCost(upgrade); if (gameState.finances.budget < cost) { addPlayerMessage(`Insufficient funds to develop ${upgrade.name}. Need ${formatCurrency(cost)}.`, "warning"); return; } gameState.finances.budget -= cost; gameState.finances.seasonExpenses += cost; logTransaction(`Start R&D: ${upgrade.name}`, -cost, gameState.finances.budget); const durationWeeks = calculateDevelopmentDuration(upgrade); const completionTime = calculateCompletionTime(gameState.currentWeek, gameState.currentGameStage, durationWeeks, 0); const successChance = calculateSuccessChance(upgrade.baseSuccessChance); gameState.inProgressDevelopment.push({ upgradeId: upgradeId, name: upgrade.name, targetCompletionWeek: completionTime.week, targetCompletionStage: completionTime.stage, successChance: successChance, }); addPlayerMessage(`Started development: ${upgrade.name}. ETA: Wk ${completionTime.week}`, "success"); updateUI(); }
    function processCompletedDevelopment(currentWeek, currentStage) { const completed = []; gameState.inProgressDevelopment = gameState.inProgressDevelopment.filter(dev => { if (isTimeReached(currentWeek, currentStage, dev.targetCompletionWeek, dev.targetCompletionStage)) { completed.push(dev); return false; } return true; }); let statsChanged = false; completed.forEach(dev => { const upgrade = findUpgradeByIdRecursive(dev.upgradeId); if (!upgrade) { addPlayerMessage(`Completed development data mismatch for ID ${dev.upgradeId}.`, "error"); return; } const success = Math.random() < dev.successChance; if (success) { addPlayerMessage(`Development SUCCESS: ${upgrade.name}! Performance improved.`, "success"); applyUpgradeEffect(playerCar, upgrade); playerCar.appliedUpgrades.push(dev.upgradeId); statsChanged = true; } else { addPlayerMessage(`Development FAILED: ${upgrade.name}! Resources wasted.`, "error"); } }); if (statsChanged) { calculateTeamStats(gameState.playerTeamId); } if (completed.length > 0) updateUI(); }
    function investInfrastructure(facilityKey) { const facility = infrastructure[facilityKey]; if (!facility || facility.level >= facility.maxLevel) { addPlayerMessage(`Cannot invest further in ${facility?.name || 'unknown facility'}.`, "warning"); return; } const cost = facility.costPerLevel[facility.level]; if (gameState.finances.budget < cost) { addPlayerMessage(`Insufficient funds to upgrade ${facility.name}. Need ${formatCurrency(cost)}.`, "warning"); return; } gameState.finances.budget -= cost; gameState.finances.seasonExpenses += cost; logTransaction(`Infrastructure Upgrade: ${facility.name} Lvl ${facility.level + 1}`, -cost, gameState.finances.budget); facility.level++; addPlayerMessage(`Upgraded ${facility.name} to Level ${facility.level}!`, "success"); calculateTeamStats(gameState.playerTeamId); updateUI(); }
    function startStaffTraining(staffId, trainingId) { const staff = getStaffById(gameState.playerTeamId, staffId); const trainingOption = staffTrainingOptions[staff?.role]?.find(t => t.id === trainingId); if (!staff || !trainingOption || gameState.inProgressStaffTraining.some(t => t.staffId === staff.id)) { addPlayerMessage(`Cannot start training for ${staff?.name || 'unknown staff'}.`, "error"); return; } if (staff.level < trainingOption.levelReq) { addPlayerMessage(`${staff.name} does not meet level requirement for ${trainingOption.name}.`, "warning"); return; } const cost = trainingOption.cost; if (gameState.finances.budget < cost) { addPlayerMessage(`Insufficient funds for ${trainingOption.name}. Need ${formatCurrency(cost)}.`, "warning"); return; } gameState.finances.budget -= cost; gameState.finances.seasonExpenses += cost; logTransaction(`Start Staff Training: ${staff.name} - ${trainingOption.name}`, -cost, gameState.finances.budget); const completionTime = calculateCompletionTime(gameState.currentWeek, gameState.currentGameStage, trainingOption.durationWeeks, 0); const successChance = trainingOption.successChance; gameState.inProgressStaffTraining.push({ staffId: staffId, trainingId: trainingId, trainingName: trainingOption.name, targetCompletionWeek: completionTime.week, targetCompletionStage: completionTime.stage, successChance: successChance, effect: trainingOption.effect }); addPlayerMessage(`Started training ${staff.name} in ${trainingOption.name}. ETA: Wk ${completionTime.week}`, "success"); updateUI(); }
    function processCompletedStaffTraining(currentWeek, currentStage) { const completed = []; gameState.inProgressStaffTraining = gameState.inProgressStaffTraining.filter(train => { if (isTimeReached(currentWeek, currentStage, train.targetCompletionWeek, train.targetCompletionStage)) { completed.push(train); return false; } return true; }); let statsChanged = false; completed.forEach(train => { const staff = getStaffById(gameState.playerTeamId, train.staffId); if (!staff) { addPlayerMessage(`Completed training data mismatch for Staff ID ${train.staffId}.`, "error"); return; } const success = Math.random() < train.successChance; if (success) { const oldLevel = staff.level; staff.level = Math.min(10, staff.level + 1); addPlayerMessage(`Training SUCCESS: ${staff.name} completed ${train.trainingName}! Level ${oldLevel}->${staff.level}.`, "success"); statsChanged = true; } else { addPlayerMessage(`Training FAILED: ${staff.name}'s ${train.trainingName} training was unsuccessful.`, "error"); } }); if (statsChanged) calculateTeamStats(gameState.playerTeamId); if (completed.length > 0) updateUI(); }

    // ==========================================================================
    // TIME CALCULATION HELPERS
    // ==========================================================================
     const stageOrder = ['StartOfWeek', 'Qualifying', 'PreRace', 'Race', 'PostRace']; const fullStageOrder = ['PreSeason', ...stageOrder, 'EndOfSeason'];
    function calculateCompletionTime(startWeek, startStage, durationWeeks, durationStages = 0) { let currentStageIndex = stageOrder.indexOf(startStage); if (startStage === 'PreSeason' || startStage === 'EndOfSeason') { currentStageIndex = -1; startWeek = (startStage === 'PreSeason') ? 1 : startWeek; } if (currentStageIndex === -1) currentStageIndex = -1; let totalStagesToAdd = (durationWeeks * stageOrder.length) + durationStages; let targetWeek = startWeek; let targetStageIndex = currentStageIndex; for (let i = 0; i < totalStagesToAdd; i++) { targetStageIndex++; if (targetStageIndex >= stageOrder.length) { targetStageIndex = 0; targetWeek++; } } let targetStage = stageOrder[targetStageIndex] || 'StartOfWeek'; return { week: targetWeek, stage: targetStage }; }
    function isTimeReached(currentWeek, currentStage, targetWeek, targetStage) { if (currentWeek > targetWeek) return true; if (currentWeek < targetWeek) return false; return fullStageOrder.indexOf(currentStage) >= fullStageOrder.indexOf(targetStage); }

    // ==========================================================================
    // FINANCE & SPONSORS (Implementations)
    // ==========================================================================
     function toggleSponsorSelection(sponsorId) { if (gameState.currentGameStage !== 'PreSeason') return; const index = gameState.selectedSponsors.indexOf(sponsorId); if (index > -1) { gameState.selectedSponsors.splice(index, 1); } else if (gameState.selectedSponsors.length < SPONSOR_SLOTS) { gameState.selectedSponsors.push(sponsorId); } displaySponsors(); }
     function confirmSponsorSelection() { if (gameState.currentGameStage !== 'PreSeason' || gameState.selectedSponsors.length !== SPONSOR_SLOTS) { addPlayerMessage("Select exactly " + SPONSOR_SLOTS + " sponsors.", "warning"); return; } gameState.activeSponsorContracts = gameState.selectedSponsors.map(sponsorId => { const sponsor = potentialSponsors.find(s => s.id === sponsorId); return { sponsorId: sponsor.id, basePayoutPerRace: sponsor.basePayoutPerRace, startWeek: 1, objectives: sponsor.objectives.map(obj => ({ ...obj, progress: 0, achieved: false, complete: false, expired: false })) }; }); gameState.selectedSponsors = []; addPlayerMessage(`Selected ${gameState.activeSponsorContracts.length} sponsors for the season!`, "success"); updateUI(); }
    function updateSponsorObjectiveStatus(isStartOfWeek) { const currentWeek = gameState.currentWeek; const currentRaceIndex = gameState.currentRaceIndex; const raceCheckIndex = isStartOfWeek ? currentRaceIndex -1 : currentRaceIndex ; const lastRaceLog = gameState.raceResultsLog.find(r => r.raceId === season.races[raceCheckIndex]?.id); gameState.activeSponsorContracts?.forEach(contract => { contract.objectives.forEach(obj => { if (obj.complete || obj.expired) return; const deadlineWeek = contract.startWeek + (obj.durationWeeks || 0) - 1; if (isStartOfWeek && obj.durationWeeks < 24 && currentWeek > deadlineWeek) { if (!obj.achieved) { obj.expired = true; addPlayerMessage(`Sponsor objective '${obj.description}' expired unmet.`, "warning"); } return; } if (!isStartOfWeek && lastRaceLog && obj.durationWeeks < 24) { let objectiveMetThisRace = false; const playerResults = lastRaceLog.race?.filter(r => getDriverById(r.driverId)?.teamId === gameState.playerTeamId) || []; const playerQualiResults = lastRaceLog.quali?.filter(r => getDriverById(r.driverId)?.teamId === gameState.playerTeamId) || []; switch (obj.type) { case 'race_pos': objectiveMetThisRace = playerResults.some(r => r.position > 0 && r.position <= obj.target); break; case 'quali_pos': objectiveMetThisRace = playerQualiResults.some(r => r.position > 0 && r.position <= obj.target); break; case 'finish_both': objectiveMetThisRace = playerResults.length === 2 && playerResults.every(r => r.status === 'Finished'); break; case 'both_cars_in_points': objectiveMetThisRace = playerResults.length === 2 && playerResults.every(r => r.position > 0 && r.position <= 10); break; case 'consecutive_points': const scoredPointsThisRace = playerResults.some(r => r.points > 0); if (scoredPointsThisRace) { obj.progress = (obj.progress || 0) + 1; } else if (obj.durationWeeks > 1) { obj.progress = 0; } objectiveMetThisRace = obj.progress >= obj.target; break; case 'podium_finish': objectiveMetThisRace = playerResults.some(r => r.position > 0 && r.position <= 3); obj.achieved = objectiveMetThisRace || obj.achieved; break; case 'win_race': objectiveMetThisRace = playerResults.some(r => r.position === 1); obj.achieved = objectiveMetThisRace || obj.achieved; break; } if (obj.type === 'podium_finish' || obj.type === 'win_race' || obj.type === 'consecutive_points') { if (obj.achieved || objectiveMetThisRace) { objectiveMetThisRace = true; } } if (objectiveMetThisRace && !obj.complete) { gameState.finances.budget += obj.reward; gameState.finances.seasonIncome += obj.reward; logTransaction(`Sponsor Bonus: ${obj.description}`, obj.reward, gameState.finances.budget); addPlayerMessage(`Sponsor objective complete: ${obj.description}! +${formatCurrency(obj.reward)}`, "success"); obj.complete = true; obj.achieved = true; } } }); }); }
    function payBaseSponsorIncome() { let income = gameState.finances.incomePerRaceBase; gameState.activeSponsorContracts?.forEach(contract => { income += contract.basePayoutPerRace; }); if (income > 0) { gameState.finances.budget += income; gameState.finances.seasonIncome += income; logTransaction(`Race Income (Base + Sponsors)`, income, gameState.finances.budget); } }

    // ==========================================================================
    // MORALE & REPUTATION (Implementations) - WITH MODIFIED MORALE LOGIC
    // ==========================================================================
    function updateMorale() { const playerTeamRank = getCurrentTeamRank(gameState.playerTeamId) || Math.ceil(teams.length / 2); drivers.forEach(driver => { let moraleChange = (Math.random() * 5) - 2; const raceCheckIndex = gameState.currentRaceIndex; const lastRaceLog = gameState.raceResultsLog.find(r => r.raceId === season.races[raceCheckIndex]?.id); const driverResult = lastRaceLog?.race?.find(r => r.driverId === driver.id); if(driverResult && driverResult.position > 0) { let expectedPos = 10; const teamRank = getCurrentTeamRank(driver.teamId) || Math.ceil(teams.length / 2); expectedPos = Math.max(1, Math.min(18, teamRank * 2 - 1)); const delta = expectedPos - driverResult.position; moraleChange += delta * 0.25; if (driverResult.status !== 'Finished') { moraleChange -= 10; } if (driverResult.mistakePenalty > 1.0) { moraleChange -= 1; } } else if (driverResult && driverResult.status === 'Retired') { moraleChange -= 10; } driver.morale = Math.max(10, Math.min(100, Math.round(driver.morale + moraleChange))); }); }
    function updateTeamReputation() { teams.forEach((team, index) => { let repChange = 0; const raceCheckIndex = gameState.currentRaceIndex; const lastRaceLog = gameState.raceResultsLog.find(r => r.raceId === season.races[raceCheckIndex]?.id); if (!lastRaceLog) return; const teamDrivers = drivers.filter(d => d.teamId === team.id); const teamResults = lastRaceLog.race?.filter(r => teamDrivers.some(d => d.id === r.driverId)) || []; if (teamResults.length > 0) { const teamPoints = teamResults.reduce((sum, r) => sum + (r.points || 0), 0); repChange += teamPoints * 0.05; if (teamResults.some(r => r.position <= 3)) repChange += 0.3; if (teamResults.every(r => r.position > 15 && r.status === 'Finished')) repChange -= 0.3; if (teamResults.every(r => r.status === 'Retired')) repChange -= 0.5; } else { repChange -= 0.5; } team.reputation = Math.max(20, Math.min(100, team.reputation + repChange)); }); }
    function getCurrentTeamRank(teamId) { leaderboard.teams.forEach(teamEntry => { teamEntry.points = leaderboard.drivers.filter(d => d.teamId === teamEntry.teamId).reduce((sum, d) => sum + d.points, 0); }); const sortedTeams = [...leaderboard.teams].sort((a, b) => b.points - a.points); const rankIndex = sortedTeams.findIndex(t => t.teamId === teamId); return rankIndex !== -1 ? rankIndex + 1 : null; }
    function calculateSalaryPerRace(driver, teamReputation) { if (!driver) return 0; const BASE_SALARY_PER_RACE = 20000; let paceFactor = Math.pow(driver.stats.pace / 75.0, 2.5); let expFactor = driver.stats.experience * 200; let repFactor = (teamReputation / 100) * 10000; let salary = BASE_SALARY_PER_RACE + (paceFactor * 5000) + expFactor + repFactor; salary *= (1.1 - (driver.morale / 200.0)); return Math.max(10000, Math.round(salary / 1000) * 1000); }

    // ==========================================================================
    // AI LOGIC (Implementations)
    // ==========================================================================
    function runAIActions() { console.log(`--- Running AI Actions for Week ${gameState.currentWeek} ---`); teams.forEach(team => { if (team.id === gameState.playerTeamId) return; const aiBudget = team.budget || 0; const car = aiCarData[team.id]; const teamInfra = aiInfrastructureData[team.id]; if (!car || !teamInfra) { console.warn(`Missing car or infra data for AI team ${team.name}`); return; } const weeklyIncome = Math.round(team.reputation * 10000); team.budget += weeklyIncome; const infraUpgradeChance = 0.2; if (aiBudget > 5000000 && Math.random() < infraUpgradeChance) { let potentialInfraUpgrades = []; for (const key in teamInfra) { const currentLevel = teamInfra[key]; const facilityDef = infrastructure[key]; if (facilityDef && currentLevel < facilityDef.maxLevel) { const cost = facilityDef.costPerLevel[currentLevel]; if (aiBudget >= cost) { potentialInfraUpgrades.push({ key: key, cost: cost, currentLevel: currentLevel, def: facilityDef }); } } } if (potentialInfraUpgrades.length > 0) { let chosenInfra = null; const neededRDLevels = {}; for (const partType in car.development) { if (!car.development[partType]) continue; car.development[partType].forEach(upgrade => { if (!car.appliedUpgrades.includes(upgrade.id)) { const req = upgrade.requiredInfra; if (req && teamInfra[req.facility] < req.level) { if (!neededRDLevels[req.facility] || req.level > neededRDLevels[req.facility]) { neededRDLevels[req.facility] = req.level; } } } }); } const unlockableUpgrades = potentialInfraUpgrades.filter(upg => neededRDLevels[upg.key]); if (unlockableUpgrades.length > 0) { unlockableUpgrades.sort((a, b) => neededRDLevels[b.key] - neededRDLevels[a.key]); chosenInfra = unlockableUpgrades[0]; } else { const factoryUpgrade = potentialInfraUpgrades.find(upg => upg.key === 'factory'); if (factoryUpgrade && Math.random() < 0.4) { chosenInfra = factoryUpgrade; } else { const otherAffordable = potentialInfraUpgrades.filter(upg => upg.key !== 'factory'); if(otherAffordable.length > 0) { chosenInfra = otherAffordable[Math.floor(Math.random() * otherAffordable.length)]; } } } if (chosenInfra) { team.budget -= chosenInfra.cost; aiInfrastructureData[team.id][chosenInfra.key]++; console.log(`>>> AI Action: ${team.name} upgraded ${chosenInfra.key} to Level ${aiInfrastructureData[team.id][chosenInfra.key]}. Cost: ${formatCurrency(chosenInfra.cost)}. Budget Left: ${formatCurrency(team.budget)}`); calculateTeamStats(team.id); } } } const carDevChance = 0.4; if (gameState.currentRaceIndex < 20 && aiBudget > 1000000 && Math.random() < carDevChance) { const affordableDevelopments = []; for (const partType in car.development) { if (!car.development[partType]) continue; car.development[partType].forEach(upgrade => { const req = upgrade.requiredInfra; const isUnlocked = req ? (teamInfra[req.facility] && teamInfra[req.facility] >= req.level) : true; if (isUnlocked && !car.appliedUpgrades.includes(upgrade.id)) { const cost = upgrade.cost; if (aiBudget >= cost) { const boostSum = Object.values(upgrade.performanceBoost).reduce((s, v) => s + v, 0); const value = cost > 0 ? boostSum / cost : boostSum * 1000; affordableDevelopments.push({ ...upgrade, cost: cost, value: value }); } } }); } if (affordableDevelopments.length > 0) { affordableDevelopments.sort((a, b) => b.value - a.value); const chosenUpgrade = affordableDevelopments[0]; team.budget -= chosenUpgrade.cost; applyUpgradeEffect(car, chosenUpgrade); car.appliedUpgrades.push(chosenUpgrade.id); console.log(`>>> AI Action: ${team.name} developed ${chosenUpgrade.name}. Cost: ${formatCurrency(chosenUpgrade.cost)}. Budget Left: ${formatCurrency(team.budget)}`); calculateTeamStats(team.id); } } }); console.log(`--- Finished AI Actions ---`); }
    function applyUpgradeEffect(carObject, upgrade) { if (!carObject || !carObject.baseStats || !upgrade || !upgrade.performanceBoost) { console.warn("Missing data in applyUpgradeEffect", { carObject, upgrade }); return; } for (const stat in upgrade.performanceBoost) { if (carObject.baseStats.hasOwnProperty(stat)) { const boostValue = upgrade.performanceBoost[stat]; let currentValue = carObject.baseStats[stat]; let newValue = currentValue + boostValue; if (stat === 'reliability') { newValue = Math.min(99, newValue); } else { newValue = Math.min(110, newValue); } carObject.baseStats[stat] = newValue; } else { console.warn(`Stat ${stat} from upgrade ${upgrade.id} not found in car baseStats.`); } } }

    // ==========================================================================
    // RACE & QUALIFYING SIMULATION (Implementations)
    // ==========================================================================
    function runQualifyingSimulation() { console.log("Running Qualifying Simulation..."); const currentRace = season.races[gameState.currentRaceIndex]; const track = currentRace; let qualiResults = []; drivers.forEach(driver => { const team = getTeamById(driver.teamId); const car = getCarData(driver.teamId); if (!team || !car || !driver.teamId) return; let baseIndicator = calculatePerformanceIndicator(driver, car, team, track); baseIndicator *= (1 + (Math.random() * 0.04 - 0.02)); let timePenalty = (track.basePenaltySpan || 5.0) * (1.0 - baseIndicator); let lapTime = track.fastestLaptime + timePenalty; lapTime = Math.max(track.fastestLaptime * 0.98, lapTime); qualiResults.push({ driverId: driver.id, teamId: driver.teamId, lapTime: lapTime }); }); qualiResults.sort((a, b) => a.lapTime - b.lapTime); qualiResults.forEach((result, index) => { result.position = index + 1; }); let raceLog = gameState.raceResultsLog.find(r => r.raceId === currentRace.id); if (!raceLog) { raceLog = { raceId: currentRace.id, quali: [], race: [] }; gameState.raceResultsLog.push(raceLog); } raceLog.quali = qualiResults; addPlayerMessage(`Qualifying complete for ${currentRace.name}.`, "info"); console.log("Qualifying Results:", qualiResults.map(r => `${r.position}. ${getDriverById(r.driverId)?.name} (${r.lapTime.toFixed(3)})`).join(', ')); }
    function calculatePerformanceIndicator(driver, car, team, track) { let driverFactor = (driver.stats.pace / 100.0); let totalDependency = (track.aeroDep || 0.5) + (track.engineDep || 0.5) + (track.chassisDep || 0.5); let carFactor = 0; if (totalDependency > 0 && car && car.baseStats) { carFactor = ( ((car.baseStats.aero / 100.0) * (track.aeroDep || 0.5)) + ((car.baseStats.engine / 100.0) * (track.engineDep || 0.5)) + ((car.baseStats.chassis / 100.0) * (track.chassisDep || 0.5)) ) / totalDependency; } else if (!car || !car.baseStats) { console.warn("Missing car data for perf calc", driver.name); carFactor = 0.5; } let moraleFactor = 0.8 + (driver.morale / 100.0) * 0.4; let teamFactor = (team.teamStats?.calculatedOverallStat || 50) / 100.0; let indicator = (driverFactor * 0.40) + (carFactor * 0.40) + (teamFactor * 0.10); indicator *= moraleFactor; indicator = Math.max(0.1, Math.min(1.5, indicator)); return indicator; }
    function calculateTyreEffect(driver, currentTyre, track) { if (!currentTyre || !tyreSpecs[currentTyre.compound]) return 0; let spec = tyreSpecs[currentTyre.compound]; let baseDegThisLap = spec.degRate * (track.tyreWearRate || 1.0); let driverDegReduction = (driver.stats.tyreManagement / 200.0); let actualDegThisLap = baseDegThisLap * (1.0 - driverDegReduction); currentTyre.degradation += actualDegThisLap; currentTyre.age += 1; let degradationPenalty = Math.pow(currentTyre.degradation * 2.0, 2); let tyrePerfImpact = spec.basePerfModifier - degradationPenalty; return tyrePerfImpact; }
    function applyFollowAdvantage(currentPerformance, gapToCarAhead) { const FOLLOW_THRESHOLD_MS = 750; const FOLLOW_PERF_BOOST = 1.010; if (gapToCarAhead !== null && gapToCarAhead >= 0 && (gapToCarAhead * 1000) < FOLLOW_THRESHOLD_MS) { return currentPerformance * FOLLOW_PERF_BOOST; } return currentPerformance; }
    function checkForMistake(driver, track) { const BASE_MISTAKE_CHANCE = 0.03; let driverConsistencyFactor = (driver.stats.consistency / 150.0); let mistakeChance = BASE_MISTAKE_CHANCE * (1.0 - driverConsistencyFactor); mistakeChance *= (1.2 - (driver.morale / 500.0)); if (Math.random() < Math.max(0.005, mistakeChance)) { let penalty = 0.5 + Math.random() * 2.0; return penalty; } return 0; }
    function calculateDriverLapTime(driver, car, team, track, currentTyre, gapToCarAhead) { let perfIndicator = calculatePerformanceIndicator(driver, car, team, track); let tyreImpact = calculateTyreEffect(driver, currentTyre, track); perfIndicator += tyreImpact; perfIndicator = applyFollowAdvantage(perfIndicator, gapToCarAhead); perfIndicator = Math.max(0.1, Math.min(1.5, perfIndicator)); let timePenalty = (track.basePenaltySpan || 5.0) * (1.0 - perfIndicator); let lapTime = track.fastestLaptime + timePenalty; let mistakePenaltyTime = checkForMistake(driver, track); lapTime += mistakePenaltyTime; lapTime *= (1.0 + (Math.random() * 0.02 - 0.01)); lapTime = Math.max(track.fastestLaptime * 0.97, lapTime); return { lapTime: lapTime, mistakePenalty: mistakePenaltyTime }; }
    function getBaseStrategies() { return [ { name: "Soft -> Medium (1 Stop)", stops: 1, stints: [{compound: 'Soft'}, {compound: 'Medium'}] }, { name: "Medium -> Hard (1 Stop)", stops: 1, stints: [{compound: 'Medium'}, {compound: 'Hard'}] }, { name: "Soft -> Hard (1 Stop)", stops: 1, stints: [{compound: 'Soft'}, {compound: 'Hard'}] }, { name: "Soft -> Medium -> Soft (2 Stop)", stops: 2, stints: [{compound: 'Soft'}, {compound: 'Medium'}, {compound: 'Soft'}] }, { name: "Medium -> Soft -> Soft (2 Stop)", stops: 2, stints: [{compound: 'Medium'}, {compound: 'Soft'}, {compound: 'Soft'}] }, { name: "Medium -> Medium -> Soft (2 Stop)", stops: 2, stints: [{compound: 'Medium'}, {compound: 'Medium'}, {compound: 'Soft'}] }, ]; }
    function calculateTargetLapsForStrategy(strategy, totalLaps) { const numStints = strategy.stints.length; const numStops = strategy.stops; if (numStints !== numStops + 1) { console.warn(`Strategy ${strategy.name} has mismatching stints (${numStints}) and stops (${numStops}). Assuming stops based on stints.`); } const stopsToUse = numStints - 1; let calculatedStrategy = JSON.parse(JSON.stringify(strategy)); calculatedStrategy.stints.forEach((stint, i) => { if (i < stopsToUse) { stint.targetLap = Math.round(totalLaps * (i + 1) / (stopsToUse + 1)); stint.targetLap += Math.floor(Math.random() * 3) - 1; stint.targetLap = Math.max(1, Math.min(totalLaps - 1, stint.targetLap)); } else { delete stint.targetLap; } }); return calculatedStrategy; }
    function populateStrategyOptions(race) { const listDiv = document.getElementById('strategy-options-list'); if (!listDiv || !race) return; listDiv.innerHTML = ''; const strategies = getBaseStrategies(); strategies.forEach((baseStrat, index) => { let strat = calculateTargetLapsForStrategy(baseStrat, race.laps); let estimatedDesc = ""; strat.stints.forEach((stint, i) => { estimatedDesc += stint.targetLap ? `${stint.compound} (Pit ~Lap ${stint.targetLap}) -> ` : `${stint.compound} (To Finish)`; }); listDiv.innerHTML += `<div style="padding: 5px; border-bottom: 1px dotted var(--tab-border);"><input type="radio" name="strategy" id="strat-${index}" value="${index}" ${gameState.playerStrategy?.name === strat.name ? 'checked' : ''}><label for="strat-${index}">${strat.name}</label><p style="font-size: 0.85em; margin-left: 20px; color: var(--secondary-color);">${estimatedDesc}</p></div>`; }); const selectedStratEl = document.getElementById('selected-strategy-display'); if (selectedStratEl) selectedStratEl.textContent = gameState.playerStrategy?.name || 'None'; }
    function confirmStrategy() { const selectedRadio = document.querySelector('input[name="strategy"]:checked'); if (selectedRadio) { const index = parseInt(selectedRadio.value); const baseStrategies = getBaseStrategies(); const selectedBaseStrat = baseStrategies[index]; const currentRace = season.races[gameState.currentRaceIndex]; gameState.playerStrategy = calculateTargetLapsForStrategy(selectedBaseStrat, currentRace.laps); addPlayerMessage(`Strategy confirmed: ${gameState.playerStrategy.name}`, "success"); updateUI(); } else { addPlayerMessage("Please select a strategy.", "warning"); } }
    function initializeRaceSimulation() { console.log("Initializing Race Simulation..."); const currentRace = season.races[gameState.currentRaceIndex]; const raceLog = gameState.raceResultsLog.find(r => r.raceId === currentRace.id); const qualiResults = raceLog?.quali; if (!qualiResults) { addPlayerMessage("Qualifying results missing! Cannot start race.", "error"); gameState.currentGameStage = 'PreRace'; return; } if (!gameState.playerStrategy) { addPlayerMessage("Player strategy not set! Select a strategy before starting the race.", "warning"); gameState.currentGameStage = 'PreRace'; updateUI(); return; } const aiStrategies = {}; teams.forEach(t => { if (t.id !== gameState.playerTeamId) { const baseStrategies = getBaseStrategies(); const chosenBaseStrat = baseStrategies[Math.random() < 0.7 ? Math.floor(Math.random() * 3) : 3 + Math.floor(Math.random() * (baseStrategies.length - 3))]; aiStrategies[t.id] = calculateTargetLapsForStrategy(chosenBaseStrat, currentRace.laps); } }); liveLeaderboardData = { raceId: currentRace.id, lap: 0, totalLaps: currentRace.laps, events: [`Race Start: ${currentRace.name}`], drivers: [] }; qualiResults.forEach(qr => { const driver = getDriverById(qr.driverId); if (!driver) return; const strategy = driver.teamId === gameState.playerTeamId ? gameState.playerStrategy : aiStrategies[driver.teamId]; const startingTyreCompound = strategy?.stints[0]?.compound || 'Medium'; liveLeaderboardData.drivers.push({ driverId: qr.driverId, teamId: qr.teamId, position: qr.position, gridPos: qr.position, status: 'Racing', totalRaceTime: 0, lastLapTime: null, gapToLeader: 0, gapToPrevious: 0, currentTyre: { compound: startingTyreCompound, age: 0, degradation: 0 }, strategy: strategy, stintIndex: 0, pitStops: 0, mistakePenalty: 0, lapsCompleted: 0, points: 0 }); }); for(let i = 1; i < liveLeaderboardData.drivers.length; i++) { liveLeaderboardData.drivers[i].totalRaceTime = i * 0.1; liveLeaderboardData.drivers[i].gapToLeader = liveLeaderboardData.drivers[i].totalRaceTime; liveLeaderboardData.drivers[i].gapToPrevious = liveLeaderboardData.drivers[i].totalRaceTime - liveLeaderboardData.drivers[i-1].totalRaceTime; } addPlayerMessage(`Race starting: ${currentRace.name} (${currentRace.laps} laps)`, "info"); updateUI(); }
    function simulateTimeStep() { liveLeaderboardData.lap++; const currentLap = liveLeaderboardData.lap; const track = season.races[gameState.currentRaceIndex]; const lapPerformances = []; const previousOrder = [...liveLeaderboardData.drivers]; liveLeaderboardData.drivers.forEach((driverData) => { if (driverData.status !== 'Racing' && driverData.status !== 'Pitting') { lapPerformances.push({ ...driverData, lapTime: Infinity, lastLapTime: null }); return; } const driver = getDriverById(driverData.driverId); const team = getTeamById(driverData.teamId); const car = getCarData(driverData.teamId); const myIndexLastLap = previousOrder.findIndex(d => d.driverId === driverData.driverId); const carAheadData = myIndexLastLap > 0 ? previousOrder[myIndexLastLap - 1] : null; const gapToCarAhead = carAheadData && carAheadData.status !== 'Retired' ? (driverData.totalRaceTime - carAheadData.totalRaceTime) : null; let pitTimePenalty = 0; let performingPitStop = false; const currentStint = driverData.strategy?.stints[driverData.stintIndex]; let shouldPit = false; if (currentStint && driverData.stintIndex < driverData.strategy.stints.length - 1) { const targetPitLap = currentStint.targetLap; if ( targetPitLap && ( (currentLap >= targetPitLap - 1 && currentLap <= targetPitLap + 1 && Math.random() < 0.85) || (driverData.currentTyre.degradation > 0.75) ) ) { shouldPit = true; } } if (shouldPit && driverData.status === 'Racing') { performingPitStop = true; driverData.stintIndex++; const nextStint = driverData.strategy.stints[driverData.stintIndex]; if (!nextStint) { console.error("Error finding next stint for", driver.name); driverData.status = 'Retired'; lapPerformances.push({ ...driverData, lapTime: Infinity, lastLapTime: null }); return; } const oldCompound = driverData.currentTyre.compound; driverData.currentTyre = { compound: nextStint.compound, age: 0, degradation: 0 }; driverData.pitStops++; driverData.status = 'Pitting'; logRaceEvent(`${driver.name} pits on lap ${currentLap-1} (from ${oldCompound} to ${nextStint.compound})`); const pitCrewChief = team.staff?.find(s => s.role === 'Pit Crew Chief'); const basePitTime = 20.0; const stopTimeEffect = pitCrewChief ? (pitCrewChief.statEffect?.PitStopTime || 0) * (pitCrewChief.level / 5.0) : 0; const randomVariance = (Math.random() * 1.0 - 0.5); const stopTime = (team.teamStats?.calculatedPitStopTime || 2.8) + stopTimeEffect + randomVariance; pitTimePenalty = Math.max(18.0, basePitTime + stopTime); } let result = { lapTime: Infinity, mistakePenalty: 0 }; if (performingPitStop) { result.lapTime = (track.fastestLaptime * 1.1) + pitTimePenalty; driverData.currentTyre.age = 1; driverData.status = 'Racing'; } else if (driverData.status === 'Racing') { result = calculateDriverLapTime(driver, car, team, track, driverData.currentTyre, gapToCarAhead); if (car && car.baseStats) { const reliability = car.baseStats.reliability; const baseFailChance = 0.0005 + (Math.max(0, driverData.currentTyre.degradation - 0.5) * 0.001); const failMultiplier = Math.pow(2.5, (100 - reliability) / 20.0); const failChance = baseFailChance * failMultiplier; if (Math.random() < failChance) { driverData.status = 'Retired'; result.lapTime = Infinity; logRaceEvent(`${driver.name} has retired! (Reliability @ ${reliability.toFixed(1)}%)`); } } else { console.warn("Missing car data for reliability check:", driver.name); } } lapPerformances.push({ ...driverData, lapTime: result.lapTime, totalRaceTime: driverData.totalRaceTime + result.lapTime, lastLapTime: (driverData.status === 'Racing' && result.lapTime !== Infinity) ? result.lapTime : null, mistakePenalty: result.mistakePenalty, lapsCompleted: (driverData.status !== 'Retired' ? currentLap : driverData.lapsCompleted), status: driverData.status }); }); lapPerformances.sort((a, b) => { if (a.lapsCompleted !== b.lapsCompleted) { return b.lapsCompleted - a.lapsCompleted; } return a.totalRaceTime - b.totalRaceTime; }); let leaderTime = -1; let leaderLaps = -1; lapPerformances.forEach((driverData, index) => { driverData.position = index + 1; if (leaderLaps < 0 && driverData.status !== 'Retired') { leaderLaps = driverData.lapsCompleted; } if (driverData.status === 'Finished' || driverData.status === 'Retired' || driverData.lapsCompleted < leaderLaps) { driverData.gapToLeader = Infinity; driverData.gapToPrevious = Infinity; } else if (leaderTime < 0) { leaderTime = driverData.totalRaceTime; driverData.gapToLeader = 0; driverData.gapToPrevious = 0; } else { driverData.gapToLeader = driverData.totalRaceTime - leaderTime; let prevRacingIndex = index - 1; while(prevRacingIndex >= 0 && (lapPerformances[prevRacingIndex].status === 'Retired' || lapPerformances[prevRacingIndex].lapsCompleted < leaderLaps)) { prevRacingIndex--; } const prevRacingCarTime = prevRacingIndex >= 0 ? lapPerformances[prevRacingIndex].totalRaceTime : leaderTime; driverData.gapToPrevious = driverData.totalRaceTime - prevRacingCarTime; } if (driverData.lapsCompleted >= liveLeaderboardData.totalLaps && driverData.status === 'Racing') { driverData.status = 'Finished'; logRaceEvent(`${getDriverById(driverData.driverId)?.name} finishes the race!`); } }); liveLeaderboardData.drivers = lapPerformances; }
    function setRaceSpeed(multiplier) { if (gameState.currentGameStage !== 'Race') return; gameState.raceSpeedMultiplier = multiplier; console.log(`Setting race speed to x${multiplier}`); startRaceIntervalTimer(); updateSpeedButtonUI(); }
    function updateSpeedButtonUI() { document.querySelectorAll('#race-speed-controls .speed-btn').forEach(btn => { const speed = parseInt(btn.textContent.replace('x','')); if (speed === gameState.raceSpeedMultiplier) { btn.classList.add('active'); btn.classList.remove('btn-secondary'); } else { btn.classList.remove('active'); btn.classList.add('btn-secondary'); } }); }
    function startRaceIntervalTimer() { if (raceSimulationInterval) { clearInterval(raceSimulationInterval); } const intervalDuration = Math.max(50, RACE_SIM_INTERVAL_MS / gameState.raceSpeedMultiplier); console.log(`Starting race interval timer with duration: ${intervalDuration}ms (Speed: x${gameState.raceSpeedMultiplier})`); raceSimulationInterval = setInterval(() => { try { if (gameState.currentGameStage !== 'Race') { clearInterval(raceSimulationInterval); raceSimulationInterval = null; return; } simulateTimeStep(); updateRaceSimUI(); const leader = liveLeaderboardData.drivers?.[0]; const raceFinished = leader && leader.lapsCompleted >= liveLeaderboardData.totalLaps; if (raceFinished || liveLeaderboardData.drivers.every(d => d.status !== 'Racing' && d.status !== 'Pitting')) { clearInterval(raceSimulationInterval); raceSimulationInterval = null; console.log("Race Finished! Process post-race actions."); liveLeaderboardData.drivers.forEach(d => { if(d.status === 'Racing') d.status = 'Finished'; }); liveLeaderboardData.drivers.sort((a, b) => { if (a.lapsCompleted !== b.lapsCompleted) { return b.lapsCompleted - a.lapsCompleted; } if (a.status === 'Finished' && b.status !== 'Finished') return -1; if (a.status !== 'Finished' && b.status === 'Finished') return 1; return a.totalRaceTime - b.totalRaceTime; }); liveLeaderboardData.drivers.forEach((d, i) => d.position = i + 1); finalizeRaceResults(); addPlayerMessage(`Race concluded for ${season.races[gameState.currentRaceIndex].name}.`, "success"); updateRaceSimUI(); updateMorale(); updateTeamReputation(); payBaseSponsorIncome(); updateSponsorObjectiveStatus(false); if (gameState.currentGameStage === 'Race') { console.log("Advancing state to PostRace..."); gameState.currentGameStage = 'PostRace'; updateUI(); } else { console.warn("Tried to transition to PostRace, but stage was already:", gameState.currentGameStage); } } } catch (error) { console.error("Error during race simulation step:", error); addPlayerMessage("Error during race sim. Check console.", "error"); clearInterval(raceSimulationInterval); raceSimulationInterval = null; gameState.currentGameStage = 'PostRace'; try { finalizeRaceResults(); updateMorale(); updateTeamReputation(); payBaseSponsorIncome(); updateSponsorObjectiveStatus(false); } catch(finalError){ console.error("Error during post-sim finalization:", finalError);} updateUI(); } }, intervalDuration); }
    function runRaceSimulation() { if (gameState.currentGameStage !== 'Race') return; console.log("Race Simulation Started (Initial call)..."); gameState.raceSpeedMultiplier = 1; updateSpeedButtonUI(); startRaceIntervalTimer(); }
    function finalizeRaceResults() { const raceCheckIndex = gameState.currentRaceIndex; const currentRace = season.races[raceCheckIndex]; if (!currentRace) { console.error("Cannot finalize results, race not found for index", raceCheckIndex); return; } const raceId = currentRace.id; const finalStandings = liveLeaderboardData.drivers; let raceLog = gameState.raceResultsLog.find(r => r.raceId === raceId); if (!raceLog) { raceLog = { raceId: currentRace.id, quali: [], race: [] }; gameState.raceResultsLog.push(raceLog); } let fastestLapDriverId = null; let fastestLapValue = Infinity; finalStandings.forEach(result => { if (result.lastLapTime && result.lastLapTime < fastestLapValue) { fastestLapValue = result.lastLapTime; fastestLapDriverId = result.driverId; } result.points = 0; }); finalStandings.forEach(result => { if (result.status === 'Finished' && result.position <= pointsSystem.length) { result.points = pointsSystem[result.position - 1]; } }); if (fastestLapDriverId && fastestLapValue !== Infinity) { const flDriverResult = finalStandings.find(r => r.driverId === fastestLapDriverId); if (flDriverResult && flDriverResult.position <= 10 && flDriverResult.status === 'Finished') { flDriverResult.points += fastestLapPoint; logRaceEvent(`${getDriverById(flDriverResult.driverId)?.name} gets fastest lap point! (${fastestLapValue.toFixed(3)}s)`); } } finalStandings.forEach(result => { const driverLb = leaderboard.drivers.find(d => d.driverId === result.driverId); if (driverLb) { const prevPoints = raceLog.race?.find(r => r.driverId === result.driverId)?.points || 0; driverLb.points = (driverLb.points - prevPoints) + (result.points || 0); } }); raceLog.race = finalStandings.map(r => ({ driverId: r.driverId, teamId: r.teamId, position: r.position, status: r.status, points: r.points || 0, lapsCompleted: r.lapsCompleted, mistakePenalty: r.mistakePenalty, })); console.log("Final Race Results (Saved to Log):", raceLog.race); }
    function logRaceEvent(message) { if (liveLeaderboardData && liveLeaderboardData.events) { const eventMessage = `Lap ${liveLeaderboardData.lap}: ${message}`; liveLeaderboardData.events.push(eventMessage); if (liveLeaderboardData.events.length > 50) { liveLeaderboardData.events.shift(); } if (document.getElementById('RaceSim')?.classList.contains('active-content')) { const eventsUl = document.getElementById('race-sim-events'); if(eventsUl) { const li = document.createElement('li'); li.textContent = eventMessage; eventsUl.insertBefore(li, eventsUl.firstChild); if(eventsUl.children.length > 10) { eventsUl.removeChild(eventsUl.lastChild); } } } } console.log(`Race Event (Lap ${liveLeaderboardData.lap}): ${message}`); }

    // ==========================================================================
    // END OF SEASON & STAFF CHANGES (Implementations) - WITH STAT PROGRESSION
    // ==========================================================================
    // START OF FUNCTION handleEndOfSeason (Updated for Stat Changes)
    function handleEndOfSeason() {
        addPlayerMessage(`The ${gameState.currentYear} season has concluded! Review performance and prepare for next year.`, "success");

        // Final sponsor objective check
        gameState.activeSponsorContracts?.forEach(contract => {
             contract.objectives.forEach(obj => {
                 if (!obj.complete && !obj.expired && (obj.type === 'team_standing_top' || obj.type === 'team_standing_mid')) {
                     const finalRank = getCurrentTeamRank(gameState.playerTeamId);
                     if (finalRank && finalRank <= obj.target) {
                         obj.complete = true; obj.achieved = true;
                         gameState.finances.budget += obj.reward; gameState.finances.seasonIncome += obj.reward;
                         logTransaction(`Sponsor Bonus (Season): ${obj.description}`, obj.reward, gameState.finances.budget);
                         addPlayerMessage(`Sponsor objective complete: ${obj.description}! +${formatCurrency(obj.reward)}`, "success");
                     } else {
                         obj.expired = true; addPlayerMessage(`Sponsor objective failed: ${obj.description}.`, "warning");
                     }
                 }
             });
        });

        // Staff level changes
         teams.forEach(team => {
            if (!team.staff) team.staff = createInitialStaff(team.id);
            team.staff.forEach(staff => {
                let changeChance = 0.05; let levelChange = 0;
                const teamInfra = team.id === gameState.playerTeamId ? infrastructure : aiInfrastructureData[team.id] || {};
                const factoryLevel = teamInfra.factory || 1;
                changeChance += (factoryLevel - 1) * 0.01;
                const teamRank = getCurrentTeamRank(team.id) || Math.ceil(teams.length / 2);
                const performanceFactor = 1.0 - (teamRank / (teams.length * 2));
                changeChance *= (0.5 + performanceFactor);
                if (Math.random() < Math.max(0.01, changeChance)) {
                    levelChange = Math.random() < (0.3 + performanceFactor * 0.5) ? 1 : -1;
                    const newLevel = Math.max(1, Math.min(10, staff.level + levelChange));
                    if (newLevel !== staff.level) {
                        if (team.id === gameState.playerTeamId) {
                            addPlayerMessage(`Staff Change: ${staff.name} (${staff.role}) level ${levelChange > 0 ? 'increased' : 'decreased'} to ${newLevel}.`, levelChange > 0 ? "info" : "warning");
                        }
                        staff.level = newLevel;
                    }
                }
            });
            calculateTeamStats(team.id);
        });

        // --- START: Driver Stat Progression ---
        console.log("--- Processing End of Season Driver Stat Progression ---");
        drivers.forEach(driver => {
             const oldPotential = driver.potential;
             const potentialChange = calculatePotentialChange(driver);
             driver.potential = Math.max(10, Math.min(100, oldPotential + potentialChange)); // Clamp potential

             // ADDED: Store previous stats before updating
             driver.previousStats = {
                 pace: driver.stats.pace,
                 consistency: driver.stats.consistency,
                 tyreManagement: driver.stats.tyreManagement,
                 overtaking: driver.stats.overtaking,
                 defending: driver.stats.defending,
                 experience: driver.stats.experience
             };
             // END ADDED

             if (driver.teamId === gameState.playerTeamId && driver.potential !== oldPotential) {
                 addPlayerMessage(`${driver.name}'s potential changed from ${oldPotential} to ${driver.potential} (${potentialChange > 0 ? '+' : ''}${potentialChange}).`, potentialChange > 0 ? 'info' : 'warning');
             }

             updateDriverStats(driver); // Update core stats based on new potential and age
        });
         console.log("--- Finished Processing Driver Stat Progression ---");
        // --- END: Driver Stat Progression ---


        // --- Driver Contract Expiry Logic ---
        console.log("--- Processing End of Season Driver Contracts ---");
        const currentYear = gameState.currentYear;
        drivers.forEach(driver => {
            if (driver.teamId) {
                if (driver.contract.expiryYear <= currentYear) {
                    const team = getTeamById(driver.teamId);
                    if (driver.teamId === gameState.playerTeamId) {
                        addPlayerMessage(`Contract expiring: ${driver.name}! Replace during Pre-Season.`, "warning");
                    } else {
                        const stayChance = 0.50;
                        if (Math.random() < stayChance) {
                            const newExpiry = currentYear + Math.floor(Math.random() * 2) + 1;
                            driver.contract.expiryYear = newExpiry;
                            driver.contract.salaryPerRace = calculateSalaryPerRace(driver, team.reputation);
                            console.log(`AI Driver ${driver.name} contract renewed with ${team.name} until ${newExpiry}.`);
                            addPlayerMessage(`${driver.name} renewed their contract with ${team.name}.`, 'secondary');
                        } else {
                            console.log(`AI Driver ${driver.name}'s contract with ${team.name} expired. Becomes Free Agent.`);
                            addPlayerMessage(`${driver.name} did not renew with ${team.name} and is now a Free Agent.`, 'secondary');
                            driver.teamId = null;
                            driver.contract.salaryPerRace = 0;
                            // No morale hit for AI contract expiry
                        }
                    }
                }
            }
        });
        console.log("--- Finished Processing Driver Contracts ---");

        gameState.currentGameStage = 'EndOfSeason';
        updateUI();
    }
    // END OF FUNCTION handleEndOfSeason

    function calculateTeamStats(teamId) { const team = getTeamById(teamId); if (!team || !team.staff) return; const teamInfra = teamId === gameState.playerTeamId ? infrastructure : aiInfrastructureData[teamId] || {}; let totalLevel = 0; let pitTimeBase = 2.8; let rdSuccessBonus = 0; let aeroEff = 0, engineEff = 0, chassisEff = 0; team.staff.forEach(staff => { totalLevel += staff.level; if(staff.statEffect?.RDSuccessRate) rdSuccessBonus += staff.statEffect.RDSuccessRate * (staff.level / 10.0); if(staff.statEffect?.AeroDevEffectiveness) aeroEff += staff.statEffect.AeroDevEffectiveness * (staff.level / 10.0); if(staff.statEffect?.EngineDevEffectiveness) engineEff += staff.statEffect.EngineDevEffectiveness * (staff.level / 10.0); if(staff.statEffect?.ChassisDevEffectiveness) chassisEff += staff.statEffect.ChassisDevEffectiveness * (staff.level / 10.0); if(staff.statEffect?.PitStopTime) pitTimeBase += staff.statEffect.PitStopTime * (staff.level / 10.0); }); const factoryLevel = teamInfra.factory || 1; rdSuccessBonus += (factoryLevel - 1) * 0.5; pitTimeBase -= (factoryLevel - 1) * 0.02; team.teamStats = { averageStaffLevel: totalLevel / (team.staff.length || 1), calculatedPitStopTime: Math.max(1.8, pitTimeBase), calculatedRDSuccessBonus: rdSuccessBonus, calculatedAeroEff: 1.0 + (aeroEff / 100.0), calculatedEngineEff: 1.0 + (engineEff / 100.0), calculatedChassisEff: 1.0 + (chassisEff / 100.0), calculatedOverallStat: Math.min(100, Math.max(0, (team.reputation + ((totalLevel / (team.staff.length || 1)) * 5)) / 1.5)) }; }
    function deductSalaries() { let totalSalaryCost = 0; drivers.forEach(driver => { if (driver.teamId === gameState.playerTeamId) { totalSalaryCost += driver.contract.salaryPerRace; } }); if (totalSalaryCost > 0) { gameState.finances.budget -= totalSalaryCost; gameState.finances.seasonExpenses += totalSalaryCost; logTransaction(`Paid Driver Salaries (Race ${gameState.currentRaceIndex + 1})`, -totalSalaryCost, gameState.finances.budget); addPlayerMessage(`Paid driver salaries: ${formatCurrency(totalSalaryCost)}`, "info"); } }

    // ==========================================================================
    // PRE-SEASON GRID MANAGEMENT
    // ==========================================================================
     function ensureFullGrid() { console.log("--- Running Pre-Season Grid Check ---"); let changesMade = false; let freeAgents = drivers.filter(d => !d.teamId); freeAgents.sort((a, b) => calculateDriverOverall(b) - calculateDriverOverall(a)); console.log(`Found ${freeAgents.length} Free Agents.`); let teamsWithVacancies = []; teams.forEach(team => { if (team.id === gameState.playerTeamId) return; const teamDriverCount = drivers.filter(d => d.teamId === team.id).length; if (teamDriverCount < 2) { teamsWithVacancies.push({ team: team, needed: 2 - teamDriverCount }); } }); teamsWithVacancies.sort((a, b) => b.team.reputation - a.team.reputation); console.log(`Found ${teamsWithVacancies.length} AI teams with vacancies.`); teamsWithVacancies.forEach(({ team, needed }) => { console.log(`AI Team ${team.name} needs ${needed} driver(s).`); for (let i = 0; i < needed; i++) { if (freeAgents.length === 0) { console.warn(`Cannot fill remaining vacancies for ${team.name} - No more Free Agents!`); addPlayerMessage(`AI team ${team.name} could not fill all driver seats due to lack of Free Agents!`, "error"); break; } const selectedAgentIndex = 0; const agentToHire = freeAgents.splice(selectedAgentIndex, 1)[0]; agentToHire.teamId = team.id; agentToHire.contract.expiryYear = gameState.currentYear + Math.floor(Math.random() * 2) + 1; agentToHire.contract.salaryPerRace = calculateSalaryPerRace(agentToHire, team.reputation); agentToHire.morale = Math.min(100, agentToHire.morale + 5); // Morale boost (was +20)
        console.log(`>>> AI Hiring: ${team.name} hired Free Agent ${agentToHire.name} (OVR: ${calculateDriverOverall(agentToHire)}) until ${agentToHire.contract.expiryYear}. Salary: ${formatCurrency(agentToHire.contract.salaryPerRace)}`); addPlayerMessage(`AI team ${team.name} signed Free Agent ${agentToHire.name}.`, 'secondary'); changesMade = true; } }); const totalDriversOnTeams = drivers.filter(d => d.teamId).length; if (totalDriversOnTeams < teams.length * 2) { console.warn(`Grid not full after Pre-Season check! Teams: ${teams.length}, Drivers: ${totalDriversOnTeams}`); } else { console.log("Grid check complete. All team seats filled."); } console.log("--- Finished Pre-Season Grid Check ---"); return changesMade; }

    // ==========================================================================
    // INITIALIZATION & EVENT LISTENERS
    // ==========================================================================
    function initializeGame() { console.log("Starting Setup Initialization..."); try { defineInitialDataStructures(); populateTeamSelect(); populateDriverSelects(); document.getElementById('game-setup').classList.remove('hidden'); document.querySelector('.main-header').classList.add('hidden'); document.querySelector('.tabs').classList.add('hidden'); document.getElementById('main-content').classList.add('hidden'); document.getElementById('driver-filter-name')?.addEventListener('input', displayDrivers); document.getElementById('driver-filter-status')?.addEventListener('change', displayDrivers); console.log("Setup screen ready."); } catch (error) { console.error("Error during setup initialization:", error); document.body.innerHTML = `<div style='color: red; padding: 20px; font-family: sans-serif;'><h1>Initialization Error</h1><p>Failed to initialize setup screen. Check console.</p><pre>${error.stack}</pre></div>`; } }
    document.addEventListener('DOMContentLoaded', initializeGame);
    window.onerror = function(message, source, lineno, colno, error) { console.error("Unhandled Error:", message, "at", source, lineno, colno, error); addPlayerMessage("An unexpected error occurred. Check the console.", "error"); if (raceSimulationInterval) { clearInterval(raceSimulationInterval); raceSimulationInterval = null; } };

    </script>

</body>
</html>